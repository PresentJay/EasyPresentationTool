{"version":3,"file":"debug.umd.js","sources":["../src/check-props.js","../src/devtools/custom.js","../src/constants.js","../src/debug.js","../src/devtools/renderer.js","../src/devtools/index.js","../src/index.js"],"sourcesContent":["const ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nlet loggedTypeFailures = {};\n\nexport function checkPropTypes(\n\ttypeSpecs,\n\tvalues,\n\tlocation,\n\tcomponentName,\n\tgetStack\n) {\n\tObject.keys(typeSpecs).forEach(typeSpecName => {\n\t\tlet error;\n\t\ttry {\n\t\t\terror = typeSpecs[typeSpecName](\n\t\t\t\tvalues,\n\t\t\t\ttypeSpecName,\n\t\t\t\tcomponentName,\n\t\t\t\tlocation,\n\t\t\t\tnull,\n\t\t\t\tReactPropTypesSecret\n\t\t\t);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\t\tif (error && !(error.message in loggedTypeFailures)) {\n\t\t\tloggedTypeFailures[error.message] = true;\n\t\t\tconsole.error(\n\t\t\t\t`Failed ${location} type: ${error.message}${(getStack && getStack()) ||\n\t\t\t\t\t''}`\n\t\t\t);\n\t\t}\n\t});\n}\n","/* istanbul ignore file */\nimport { Component, Fragment } from 'preact';\n\n/**\n * Get the type/category of a vnode\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').NodeType}\n */\nexport function getNodeType(vnode) {\n\tif (vnode.type === Fragment) return 'Wrapper';\n\telse if (typeof vnode.type === 'function') return 'Composite';\n\telse if (typeof vnode.type === 'string') return 'Native';\n\treturn 'Text';\n}\n\n/**\n * Get human readable name of the component/dom element\n * @param {import('../internal').VNode} vnode\n * @returns {string}\n */\nexport function getDisplayName(vnode) {\n\tif (vnode.type === Fragment) {\n\t\treturn 'Fragment';\n\t} else if (typeof vnode.type === 'function') {\n\t\treturn vnode.type.displayName || vnode.type.name;\n\t} else if (typeof vnode.type === 'string') {\n\t\treturn vnode.type;\n\t}\n\n\treturn '#text';\n}\n\n/**\n * Deeply mutate a property by walking down an array of property keys\n * @param {object} obj\n * @param {Array<string | number>} path\n * @param {any} value\n */\nexport function setIn(obj, path, value) {\n\tlet last = path.pop();\n\tlet parent = path.reduce((acc, attr) => (acc ? acc[attr] : null), obj);\n\tif (parent) {\n\t\tparent[last] = value;\n\t}\n}\n\n/**\n * Get devtools compatible data from vnode\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').DevtoolData}\n */\nexport function getData(vnode) {\n\tlet c = vnode._component;\n\n\t/** @type {import('../internal').DevtoolsUpdater | null} */\n\tlet updater = null;\n\n\tif (c != null && c instanceof Component) {\n\t\t// These functions will be called when the user changes state, props or\n\t\t// context values via the devtools ui panel\n\t\tupdater = {\n\t\t\tsetState: c.setState.bind(c),\n\t\t\tforceUpdate: c.forceUpdate.bind(c),\n\t\t\tsetInState(path, value) {\n\t\t\t\tc.setState(prev => {\n\t\t\t\t\tsetIn(prev, path, value);\n\t\t\t\t\treturn prev;\n\t\t\t\t});\n\t\t\t},\n\t\t\tsetInProps(path, value) {\n\t\t\t\tsetIn(vnode.props, path, value);\n\t\t\t\tc.setState({});\n\t\t\t},\n\t\t\tsetInContext(path, value) {\n\t\t\t\tsetIn(c.context, path, value);\n\t\t\t\tc.setState({});\n\t\t\t}\n\t\t};\n\t}\n\n\tlet children = getChildren(vnode);\n\n\tlet duration = vnode.endTime - vnode.startTime;\n\treturn {\n\t\tnodeType: getNodeType(vnode),\n\t\ttype: vnode.type,\n\t\tname: getDisplayName(vnode),\n\t\tref: vnode.ref || null,\n\t\tkey: vnode.key || null,\n\t\tupdater,\n\t\ttext: vnode.type === null ? vnode.props : null,\n\t\tstate: c != null && c instanceof Component ? c.state : null,\n\t\tprops: vnode.props,\n\t\t// The devtools inline text children if they are the only child\n\t\tchildren:\n\t\t\tvnode.type !== null\n\t\t\t\t? children != null && children.length == 1 && children[0].type === null\n\t\t\t\t\t? children[0].props\n\t\t\t\t\t: children\n\t\t\t\t: null,\n\t\tpublicInstance: getInstance(vnode),\n\t\tmemoizedInteractions: [],\n\n\t\t// Profiler data\n\t\tactualDuration: duration,\n\t\tactualStartTime: vnode.startTime,\n\t\ttreeBaseDuration: duration\n\t};\n}\n\n/**\n * Get all rendered vnode children as an array. Moreover we need to filter\n * out `null` or other falsy children.\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').VNode[]}\n */\nexport function getChildren(vnode) {\n\tif (vnode._component == null) {\n\t\treturn vnode._children != null ? vnode._children.filter(Boolean) : [];\n\t}\n\n\treturn vnode._children != null ? vnode._children.filter(Boolean) : null;\n}\n\n/**\n * Check if a vnode is a root node\n * @param {import('../internal').VNode} vnode\n * @returns {boolean}\n */\nexport function isRoot(vnode) {\n\t// Timings of root vnodes will never be set\n\treturn vnode.type === Fragment && vnode._parent === null;\n}\n\n/**\n * Cache a vnode by its instance and retrieve previous vnodes by the next\n * instance.\n *\n * We need this to be able to identify the previous vnode of a given instance.\n * For components we want to check if we already rendered it and use the class\n * instance as key. For html elements we use the dom node as key.\n *\n * @param {import('../internal').VNode} vnode\n * @returns {import('../internal').Component | import('../internal').PreactElement | Text | null}\n */\nexport function getInstance(vnode) {\n\t// Use the parent element as instance for root nodes\n\tif (isRoot(vnode)) {\n\t\t// Edge case: When the tree only consists of components that have not rendered\n\t\t// anything into the DOM we revert to using the vnode as instance.\n\t\treturn vnode._children.length > 0 &&\n\t\t\tvnode._children[0] != null &&\n\t\t\tvnode._children[0]._dom != null\n\t\t\t? /** @type {import('../internal').PreactElement | null} */\n\t\t\t  (vnode._children[0]._dom.parentNode)\n\t\t\t: vnode;\n\t}\n\tif (vnode._component != null) return vnode._component;\n\tif (vnode.type === Fragment) return vnode.props;\n\treturn vnode._dom;\n}\n\n/**\n * Compare two objects\n * @param {object} a\n * @param {object} b\n * @param {boolean} [isProps]\n * @returns {boolean}\n */\nexport function shallowEqual(a, b, isProps) {\n\tif (a == null || b == null) return false;\n\n\tfor (let key in a) {\n\t\tif (isProps && key == 'children' && b[key] != null) continue;\n\t\tif (a[key] !== b[key]) return false;\n\t}\n\n\tif (Object.keys(a).length !== Object.keys(b).length) return false;\n\treturn true;\n}\n\n/**\n * Check if a vnode was actually updated\n * @param {import('../internal').VNode} next\n * @param {import('../internal').VNode} prev\n * @returns {boolean}\n */\nexport function hasDataChanged(prev, next) {\n\treturn (\n\t\t(prev.props !== next.props &&\n\t\t\t!shallowEqual(prev.props, next.props, true)) ||\n\t\t(prev._component != null &&\n\t\t\t!shallowEqual(next._component._prevState, next._component.state)) ||\n\t\tprev._dom !== next._dom ||\n\t\tprev.ref !== next.ref\n\t);\n}\n","export const ELEMENT_NODE = 1;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n","import { checkPropTypes } from './check-props';\nimport { getDisplayName } from './devtools/custom';\nimport { options, Component } from 'preact';\nimport {\n\tELEMENT_NODE,\n\tDOCUMENT_NODE,\n\tDOCUMENT_FRAGMENT_NODE\n} from './constants';\n\nconst isWeakMapSupported = typeof WeakMap === 'function';\n\nfunction getClosestDomNodeParent(parent) {\n\tif (!parent) return {};\n\tif (typeof parent.type === 'function') {\n\t\treturn getClosestDomNodeParent(parent._parent);\n\t}\n\treturn parent;\n}\n\nexport function initDebug() {\n\t/* eslint-disable no-console */\n\tlet oldBeforeDiff = options._diff;\n\tlet oldDiffed = options.diffed;\n\tlet oldVnode = options.vnode;\n\tlet oldCatchError = options._catchError;\n\tlet oldRoot = options._root;\n\tlet oldHook = options._hook;\n\tconst warnedComponents = !isWeakMapSupported\n\t\t? null\n\t\t: {\n\t\t\t\tuseEffect: new WeakMap(),\n\t\t\t\tuseLayoutEffect: new WeakMap(),\n\t\t\t\tlazyPropTypes: new WeakMap()\n\t\t  };\n\n\toptions._catchError = (error, vnode, oldVNode) => {\n\t\tlet component = vnode && vnode._component;\n\t\tif (component && typeof error.then === 'function') {\n\t\t\tconst promise = error;\n\t\t\terror = new Error(\n\t\t\t\t`Missing Suspense. The throwing component was: ${getDisplayName(vnode)}`\n\t\t\t);\n\n\t\t\tlet parent = vnode;\n\t\t\tfor (; parent; parent = parent._parent) {\n\t\t\t\tif (parent._component && parent._component._childDidSuspend) {\n\t\t\t\t\terror = promise;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We haven't recovered and we know at this point that there is no\n\t\t\t// Suspense component higher up in the tree\n\t\t\tif (error instanceof Error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\n\t\toldCatchError(error, vnode, oldVNode);\n\t};\n\n\toptions._root = (vnode, parentNode) => {\n\t\tif (!parentNode) {\n\t\t\tthrow new Error(\n\t\t\t\t'Undefined parent passed to render(), this is the second argument.\\n' +\n\t\t\t\t\t'Check if the element is available in the DOM/has the correct id.'\n\t\t\t);\n\t\t}\n\t\tlet isValid;\n\t\tswitch (parentNode.nodeType) {\n\t\t\tcase ELEMENT_NODE:\n\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\tcase DOCUMENT_NODE:\n\t\t\t\tisValid = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tisValid = false;\n\t\t}\n\t\tif (!isValid) {\n\t\t\tlet componentName = getDisplayName(vnode);\n\t\t\tthrow new Error(\n\t\t\t\t`Expected a valid HTML node as a second argument to render.\tReceived ${parentNode} instead: render(<${componentName} />, ${parentNode});`\n\t\t\t);\n\t\t}\n\n\t\tif (oldRoot) oldRoot(vnode, parentNode);\n\t};\n\n\toptions._diff = vnode => {\n\t\tlet { type, _parent: parent } = vnode;\n\t\tlet parentVNode = getClosestDomNodeParent(parent);\n\n\t\tif (type === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t'Undefined component passed to createElement()\\n\\n' +\n\t\t\t\t\t'You likely forgot to export your component or might have mixed up default and named imports' +\n\t\t\t\t\tserializeVNode(vnode)\n\t\t\t);\n\t\t} else if (type != null && typeof type === 'object') {\n\t\t\tif (type._lastDomChild !== undefined && type._dom !== undefined) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Invalid type passed to createElement(): ${type}\\n\\n` +\n\t\t\t\t\t\t'Did you accidentally pass a JSX literal as JSX twice?\\n\\n' +\n\t\t\t\t\t\t`  let My${getDisplayName(vnode)} = ${serializeVNode(type)};\\n` +\n\t\t\t\t\t\t`  let vnode = <My${getDisplayName(vnode)} />;\\n\\n` +\n\t\t\t\t\t\t'This usually happens when you export a JSX literal and not the component.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t'Invalid type passed to createElement(): ' +\n\t\t\t\t\t(Array.isArray(type) ? 'array' : type)\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\t(type === 'thead' || type === 'tfoot' || type === 'tbody') &&\n\t\t\tparentVNode.type !== 'table'\n\t\t) {\n\t\t\tconsole.error(\n\t\t\t\t'Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent.' +\n\t\t\t\t\tserializeVNode(vnode)\n\t\t\t);\n\t\t} else if (\n\t\t\ttype === 'tr' &&\n\t\t\t(parentVNode.type !== 'thead' &&\n\t\t\t\tparentVNode.type !== 'tfoot' &&\n\t\t\t\tparentVNode.type !== 'tbody' &&\n\t\t\t\tparentVNode.type !== 'table')\n\t\t) {\n\t\t\tconsole.error(\n\t\t\t\t'Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent.' +\n\t\t\t\t\tserializeVNode(vnode)\n\t\t\t);\n\t\t} else if (type === 'td' && parentVNode.type !== 'tr') {\n\t\t\tconsole.error(\n\t\t\t\t'Improper nesting of table. Your <td> should have a <tr> parent.' +\n\t\t\t\t\tserializeVNode(vnode)\n\t\t\t);\n\t\t} else if (type === 'th' && parentVNode.type !== 'tr') {\n\t\t\tconsole.error(\n\t\t\t\t'Improper nesting of table. Your <th> should have a <tr>.' +\n\t\t\t\t\tserializeVNode(vnode)\n\t\t\t);\n\t\t}\n\n\t\tif (\n\t\t\tvnode.ref !== undefined &&\n\t\t\ttypeof vnode.ref !== 'function' &&\n\t\t\ttypeof vnode.ref !== 'object' &&\n\t\t\t!('$$typeof' in vnode) // allow string refs when preact-compat is installed\n\t\t) {\n\t\t\tthrow new Error(\n\t\t\t\t`Component's \"ref\" property should be a function, or an object created ` +\n\t\t\t\t\t`by createRef(), but got [${typeof vnode.ref}] instead\\n` +\n\t\t\t\t\tserializeVNode(vnode)\n\t\t\t);\n\t\t}\n\n\t\tif (typeof vnode.type === 'string') {\n\t\t\tfor (const key in vnode.props) {\n\t\t\t\tif (\n\t\t\t\t\tkey[0] === 'o' &&\n\t\t\t\t\tkey[1] === 'n' &&\n\t\t\t\t\ttypeof vnode.props[key] !== 'function' &&\n\t\t\t\t\tvnode.props[key] != null\n\t\t\t\t) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Component's \"${key}\" property should be a function, ` +\n\t\t\t\t\t\t\t`but got [${typeof vnode.props[key]}] instead\\n` +\n\t\t\t\t\t\t\tserializeVNode(vnode)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check prop-types if available\n\t\tif (typeof vnode.type === 'function' && vnode.type.propTypes) {\n\t\t\tif (\n\t\t\t\tvnode.type.displayName === 'Lazy' &&\n\t\t\t\twarnedComponents &&\n\t\t\t\t!warnedComponents.lazyPropTypes.has(vnode.type)\n\t\t\t) {\n\t\t\t\tconst m =\n\t\t\t\t\t'PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ';\n\t\t\t\ttry {\n\t\t\t\t\tconst lazyVNode = vnode.type();\n\t\t\t\t\twarnedComponents.lazyPropTypes.set(vnode.type, true);\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\tm + `Component wrapped in lazy() is ${getDisplayName(lazyVNode)}`\n\t\t\t\t\t);\n\t\t\t\t} catch (promise) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\tm + \"We will log the wrapped component's name once it is loaded.\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckPropTypes(\n\t\t\t\tvnode.type.propTypes,\n\t\t\t\tvnode.props,\n\t\t\t\tgetDisplayName(vnode),\n\t\t\t\tserializeVNode(vnode)\n\t\t\t);\n\t\t}\n\n\t\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n\t};\n\n\toptions._hook = comp => {\n\t\tif (!comp) {\n\t\t\tthrow new Error('Hook can only be invoked from render methods.');\n\t\t}\n\n\t\tif (oldHook) oldHook(comp);\n\t};\n\n\tconst warn = (property, err) => ({\n\t\tget() {\n\t\t\tthrow new Error(`getting vnode.${property} is deprecated, ${err}`);\n\t\t},\n\t\tset() {\n\t\t\tthrow new Error(`setting vnode.${property} is not allowed, ${err}`);\n\t\t}\n\t});\n\n\tconst deprecatedAttributes = {\n\t\tnodeName: warn('nodeName', 'use vnode.type'),\n\t\tattributes: warn('attributes', 'use vnode.props'),\n\t\tchildren: warn('children', 'use vnode.props.children')\n\t};\n\n\toptions.vnode = vnode => {\n\t\tlet source, self;\n\t\tif (vnode.props && vnode.props.__source) {\n\t\t\tsource = vnode.props.__source;\n\t\t\tdelete vnode.props.__source;\n\t\t}\n\t\tif (vnode.props && vnode.props.__self) {\n\t\t\tself = vnode.props.__self;\n\t\t\tdelete vnode.props.__self;\n\t\t}\n\t\tvnode.__self = self;\n\t\tvnode.__source = source;\n\t\tObject.defineProperties(vnode, deprecatedAttributes);\n\t\tif (oldVnode) oldVnode(vnode);\n\t};\n\n\toptions.diffed = vnode => {\n\t\t// Check if the user passed plain objects as children. Note that we cannot\n\t\t// move this check into `options.vnode` because components can receive\n\t\t// children in any shape they want (e.g.\n\t\t// `<MyJSONFormatter>{{ foo: 123, bar: \"abc\" }}</MyJSONFormatter>`).\n\t\t// Putting this check in `options.diffed` ensures that\n\t\t// `vnode._children` is set and that we only validate the children\n\t\t// that were actually rendered.\n\t\tif (vnode._children) {\n\t\t\tvnode._children.forEach(child => {\n\t\t\t\tif (child && child.type === undefined) {\n\t\t\t\t\t// Remove internal vnode keys that will always be patched\n\t\t\t\t\tdelete child._parent;\n\t\t\t\t\tdelete child._depth;\n\t\t\t\t\tconst keys = Object.keys(child).join(',');\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Objects are not valid as a child. Encountered an object with the keys {${keys}}.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/** @type {import('./internal').Component} */\n\t\tconst component = vnode._component;\n\t\tif (component && component.__hooks) {\n\t\t\tlet hooks = component.__hooks;\n\t\t\tif (Array.isArray(hooks._list)) {\n\t\t\t\thooks._list.forEach(hook => {\n\t\t\t\t\tif (hook._callback && (!hook._args || !Array.isArray(hook._args))) {\n\t\t\t\t\t\tlet componentName = getDisplayName(vnode);\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t`In ${componentName} you are calling useMemo/useCallback without passing arguments.\\n` +\n\t\t\t\t\t\t\t\t`This is a noop since it will not be able to memoize, it will execute it every render.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// After paint effects\n\t\t\tif (Array.isArray(hooks._pendingEffects)) {\n\t\t\t\thooks._pendingEffects.forEach(effect => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!Array.isArray(effect._args) &&\n\t\t\t\t\t\twarnedComponents &&\n\t\t\t\t\t\t!warnedComponents.useEffect.has(vnode.type)\n\t\t\t\t\t) {\n\t\t\t\t\t\twarnedComponents.useEffect.set(vnode.type, true);\n\t\t\t\t\t\tlet componentName = getDisplayName(vnode);\n\t\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\t'You should provide an array of arguments as the second argument to the \"useEffect\" hook.\\n\\n' +\n\t\t\t\t\t\t\t\t'Not doing so will invoke this effect on every render.\\n\\n' +\n\t\t\t\t\t\t\t\t`This effect can be found in the render of ${componentName}.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Layout Effects\n\t\t\tcomponent._renderCallbacks.forEach(possibleEffect => {\n\t\t\t\tif (\n\t\t\t\t\tpossibleEffect._value &&\n\t\t\t\t\t!Array.isArray(possibleEffect._args) &&\n\t\t\t\t\twarnedComponents &&\n\t\t\t\t\t!warnedComponents.useLayoutEffect.has(vnode.type)\n\t\t\t\t) {\n\t\t\t\t\twarnedComponents.useLayoutEffect.set(vnode.type, true);\n\t\t\t\t\tlet componentName = getDisplayName(vnode);\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t'You should provide an array of arguments as the second argument to the \"useLayoutEffect\" hook.\\n\\n' +\n\t\t\t\t\t\t\t'Not doing so will invoke this effect on every render.\\n\\n' +\n\t\t\t\t\t\t\t`This effect can be found in the render of ${componentName}.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (oldDiffed) oldDiffed(vnode);\n\n\t\tif (vnode._children != null) {\n\t\t\tconst keys = [];\n\t\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\t\tconst child = vnode._children[i];\n\t\t\t\tif (!child || child.key == null) continue;\n\n\t\t\t\tconst key = child.key;\n\t\t\t\tif (keys.indexOf(key) !== -1) {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Following component has two or more children with the ' +\n\t\t\t\t\t\t\t`same key attribute: \"${key}\". This may cause glitches and misbehavior ` +\n\t\t\t\t\t\t\t'in rendering process. Component: \\n\\n' +\n\t\t\t\t\t\t\tserializeVNode(vnode)\n\t\t\t\t\t);\n\n\t\t\t\t\t// Break early to not spam the console\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tkeys.push(key);\n\t\t\t}\n\t\t}\n\t};\n}\n\nconst setState = Component.prototype.setState;\nComponent.prototype.setState = function(update, callback) {\n\tif (this._vnode == null) {\n\t\tconsole.warn(\n\t\t\t`Calling \"this.setState\" inside the constructor of a component is a ` +\n\t\t\t\t`no-op and might be a bug in your application. Instead, set ` +\n\t\t\t\t`\"this.state = {}\" directly.`\n\t\t);\n\t} else if (this._parentDom == null) {\n\t\tconsole.warn(\n\t\t\t`Can't call \"this.setState\" on an unmounted component. This is a no-op, ` +\n\t\t\t\t`but it indicates a memory leak in your application. To fix, cancel all ` +\n\t\t\t\t`subscriptions and asynchronous tasks in the componentWillUnmount method.`\n\t\t);\n\t}\n\n\treturn setState.call(this, update, callback);\n};\n\nconst forceUpdate = Component.prototype.forceUpdate;\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode == null) {\n\t\tconsole.warn(\n\t\t\t`Calling \"this.forceUpdate\" inside the constructor of a component is a ` +\n\t\t\t\t`no-op and might be a bug in your application.`\n\t\t);\n\t} else if (this._parentDom == null) {\n\t\tconsole.warn(\n\t\t\t`Can't call \"this.setState\" on an unmounted component. This is a no-op, ` +\n\t\t\t\t`but it indicates a memory leak in your application. To fix, cancel all ` +\n\t\t\t\t`subscriptions and asynchronous tasks in the componentWillUnmount method.`\n\t\t);\n\t}\n\treturn forceUpdate.call(this, callback);\n};\n\n/**\n * Serialize a vnode tree to a string\n * @param {import('./internal').VNode} vnode\n * @returns {string}\n */\nexport function serializeVNode(vnode) {\n\tlet { props } = vnode;\n\tlet name = getDisplayName(vnode);\n\n\tlet attrs = '';\n\tfor (let prop in props) {\n\t\tif (props.hasOwnProperty(prop) && prop !== 'children') {\n\t\t\tlet value = props[prop];\n\n\t\t\t// If it is an object but doesn't have toString(), use Object.toString\n\t\t\tif (typeof value === 'function') {\n\t\t\t\tvalue = `function ${value.displayName || value.name}() {}`;\n\t\t\t}\n\n\t\t\tvalue =\n\t\t\t\tObject(value) === value && !value.toString\n\t\t\t\t\t? Object.prototype.toString.call(value)\n\t\t\t\t\t: value + '';\n\n\t\t\tattrs += ` ${prop}=${JSON.stringify(value)}`;\n\t\t}\n\t}\n\n\tlet children = props.children;\n\treturn `<${name}${attrs}${\n\t\tchildren && children.length ? '>..</' + name + '>' : ' />'\n\t}`;\n}\n","/* istanbul ignore file */\nimport {\n\tgetData,\n\tgetChildren,\n\tgetInstance,\n\thasDataChanged,\n\tisRoot\n} from './custom';\n\n/**\n * Custom renderer tailored for Preact. It converts updated vnode trees\n * to events the devtools can understand.\n * @class Renderer\n */\nexport class Renderer {\n\tconstructor(hook, rid) {\n\t\t/** @type {string} */\n\t\tthis.rid = rid;\n\t\tthis.hook = hook;\n\n\t\t/** @type {Array<import('../internal').DevtoolsEvent>} */\n\t\tthis.pending = [];\n\n\t\t/**\n\t\t * Store the instance of a vnode. This will be later used to decide if a\n\t\t * vnode needs to be mounted or updated. For components the instance refers\n\t\t * to the actual class instance whereas for dom nodes it refers to the\n\t\t * underlying dom element.\n\t\t * @type {WeakMap<import('../internal').Component | import('../internal').PreactElement | HTMLElement | Text, import('../internal').VNode>}\n\t\t */\n\t\tthis.inst2vnode = new WeakMap();\n\t\tthis.connected = false;\n\t}\n\n\t/**\n\t * Mark the connection status as ready so that we can proceed\n\t * to actually flush events.\n\t */\n\tmarkConnected() {\n\t\tthis.connected = true;\n\t\tthis.flushPendingEvents();\n\t}\n\n\t/**\n\t * Flush all queued events\n\t */\n\tflushPendingEvents() {\n\t\tif (!this.connected) return;\n\n\t\tlet events = this.pending;\n\t\tthis.pending = [];\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tlet event = events[i];\n\t\t\tthis.hook.emit(event.type, event);\n\t\t}\n\t}\n\n\t/**\n\t * Recursively mount a vnode tree. Note that the devtools expects the tree to\n\t * be mounted from the bottom up, otherwise the order will be messed up.\n\t * Therefore we mount children prior to mounting the vnode itself.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\tmount(vnode) {\n\t\tthis.inst2vnode.set(getInstance(vnode), vnode);\n\t\tlet data = getData(vnode);\n\n\t\t/** @type {Array<import('../internal').DevtoolsEvent>} */\n\t\tlet work = [\n\t\t\t{\n\t\t\t\tinternalInstance: vnode,\n\t\t\t\tdata,\n\t\t\t\trenderer: this.rid,\n\t\t\t\ttype: 'mount'\n\t\t\t}\n\t\t];\n\n\t\t// Children must be mounted first\n\t\tif (Array.isArray(data.children)) {\n\t\t\tlet stack = data.children.slice();\n\t\t\tlet item;\n\t\t\twhile ((item = stack.pop()) != null) {\n\t\t\t\tlet children = getChildren(item);\n\t\t\t\tstack.push(...children);\n\n\t\t\t\tthis.inst2vnode.set(getInstance(item), item);\n\n\t\t\t\tlet data = getData(item);\n\n\t\t\t\twork.push({\n\t\t\t\t\tinternalInstance: item,\n\t\t\t\t\tdata,\n\t\t\t\t\trenderer: this.rid,\n\t\t\t\t\ttype: 'mount'\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = work.length; --i >= 0; ) {\n\t\t\tthis.pending.push(work[i]);\n\t\t}\n\n\t\t// Special event if we have a root\n\t\tif (isRoot(vnode)) {\n\t\t\tthis.pending.push({\n\t\t\t\tinternalInstance: vnode,\n\t\t\t\tdata,\n\t\t\t\trenderer: this.rid,\n\t\t\t\ttype: 'root'\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Update a vnode tree\n\t * @param {import('../internal').VNode} vnode\n\t */\n\tupdate(vnode) {\n\t\tlet data = getData(vnode);\n\n\t\t// Children must be updated first\n\t\tif (Array.isArray(data.children)) {\n\t\t\tfor (let i = 0; i < data.children.length; i++) {\n\t\t\t\tlet child = data.children[i];\n\t\t\t\tlet inst = getInstance(child);\n\n\t\t\t\tlet prevChild = this.inst2vnode.get(inst);\n\t\t\t\tif (prevChild == null) this.mount(child);\n\t\t\t\telse this.update(child);\n\n\t\t\t\t// Mutate child to keep referential equality intact\n\t\t\t\tdata.children[i] = this.inst2vnode.get(inst);\n\t\t\t}\n\t\t}\n\n\t\tlet prev = this.inst2vnode.get(data.publicInstance);\n\n\t\t// The `updateProfileTimes` event is a faster version of `updated` and\n\t\t// is processed much quicker inside the devtools extension.\n\t\tif (!hasDataChanged(prev, vnode)) {\n\t\t\t// Always assume profiling data has changed. When we skip an event here\n\t\t\t// the devtools element picker will somehow break.\n\t\t\tthis.pending.push({\n\t\t\t\t// This property is only used as an id inside the devtools. The\n\t\t\t\t// relevant data will be read from `.data` instead which is a\n\t\t\t\t// normalized structure that every react release adheres to. This\n\t\t\t\t// makes backwards-compatibility easier instead of relying on internal\n\t\t\t\t// vnode/fiber shape.\n\t\t\t\tinternalInstance: prev,\n\t\t\t\tdata,\n\t\t\t\trenderer: this.rid,\n\t\t\t\ttype: 'updateProfileTimes'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tthis.pending.push({\n\t\t\t// This property is only used as an id inside the devtools. The\n\t\t\t// relevant data will be read from `.data` instead which is a\n\t\t\t// normalized structure that every react release adheres to. This\n\t\t\t// makes backwards-compatibility easier instead of relying on internal\n\t\t\t// vnode/fiber shape.\n\t\t\tinternalInstance: prev,\n\t\t\tdata,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'update'\n\t\t});\n\t}\n\n\t/**\n\t * Pass a rendered tree to the devtools. At this point elements have already\n\t * unmounted, so we don't need to check for removals and only update vs mount\n\t * instead.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\thandleCommitFiberRoot(vnode) {\n\t\tlet inst = getInstance(vnode);\n\n\t\tif (this.inst2vnode.has(inst)) this.update(vnode);\n\t\telse this.mount(vnode);\n\n\t\t// The devtools checks via the existence of this property if the devtools\n\t\t// profiler should be enabled or not. If it is missing from the first root\n\t\t// node the \"Profiler\" tab won't show up.\n\t\t/** @type {import('../internal').VNode} */\n\t\tlet root = null;\n\t\tif (isRoot(vnode)) {\n\t\t\t/** @type {*} */\n\t\t\t(vnode).treeBaseDuration = 0;\n\t\t\troot = vnode;\n\t\t} else {\n\t\t\t// \"rootCommitted\" always needs the actual root node for the profiler\n\t\t\t// to be able to collect timings. The `_parent` property will\n\t\t\t// point to a vnode for a root node.\n\t\t\troot = vnode;\n\t\t\twhile (root._parent != null) {\n\t\t\t\troot = root._parent;\n\t\t\t}\n\t\t}\n\n\t\tthis.pending.push({\n\t\t\tinternalInstance: root,\n\t\t\trenderer: this.rid,\n\t\t\tdata: getData(root),\n\t\t\ttype: 'rootCommitted'\n\t\t});\n\n\t\tthis.flushPendingEvents();\n\t\treturn vnode;\n\t}\n\n\t/**\n\t * Unmount a vnode recursively. Contrary to mounting or updating unmounting needs\n\t * to push the events in parent-first order. Because `options.unmount` is\n\t * already fired in parent-first order we don't need to traverse anything here.\n\t * @param {import('../internal').VNode} vnode\n\t */\n\thandleCommitFiberUnmount(vnode) {\n\t\tlet inst = getInstance(vnode);\n\t\tthis.inst2vnode.delete(inst);\n\n\t\t// Special case when unmounting a root (most prominently caused by webpack's\n\t\t// `hot-module-reloading`). If this happens we need to unmount the virtual\n\t\t// `Fragment` we're wrapping around each root just for the devtools.\n\n\t\tthis.pending.push({\n\t\t\tinternalInstance: vnode,\n\t\t\trenderer: this.rid,\n\t\t\ttype: 'unmount'\n\t\t});\n\t}\n\n\t/**\n\t * Get the dom element by a vnode\n\t * @param {import('../internal').VNode} vnode\n\t * @returns {import('../internal').PreactElement | Text}\n\t */\n\tgetNativeFromReactElement(vnode) {\n\t\treturn vnode._dom;\n\t}\n\n\t/**\n\t * Get a vnode by a dom element\n\t * @param {import('../internal').PreactElement | Text} dom\n\t * @returns {import('../internal').VNode | null}\n\t */\n\tgetReactElementFromNative(dom) {\n\t\treturn this.inst2vnode.get(dom) || null;\n\t}\n\n\t// Unused, but devtools expects it to be there\n\t/* istanbul ignore next */\n\twalkTree() {}\n\n\t// Unused, but devtools expects it to be there\n\t/* istanbul ignore next */\n\tcleanup() {}\n}\n","/* istanbul ignore file */\nimport { options, Component, Fragment } from 'preact';\nimport { Renderer } from './renderer';\n\n/**\n * Wrap function with generic error logging\n *\n * @param {*} fn\n * @returns\n */\nfunction catchErrors(fn) {\n\treturn function(...args) {\n\t\ttry {\n\t\t\treturn fn(...args);\n\t\t} catch (e) {\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.error('The react devtools encountered an error');\n\t\t\t/* istanbul ignore next */\n\t\t\tconsole.error(e); // eslint-disable-line no-console\n\t\t}\n\t};\n}\n\n/* istanbul ignore next */\nlet noop = () => undefined;\n\nexport function initDevTools() {\n\t// This global variable is injected by the devtools\n\t/** @type {import('../internal').DevtoolsWindow} */\n\tlet hook = (window).__REACT_DEVTOOLS_GLOBAL_HOOK__;\n\tif (hook == null) return;\n\n\t/** @type {(vnode: import('../internal').VNode) => void} */\n\tlet onCommitRoot = noop;\n\n\t/** @type {(vnode: import('../internal').VNode) => void} */\n\tlet onCommitUnmount = noop;\n\n\t// Initialize our custom renderer\n\tlet rid = Math.random()\n\t\t.toString(16)\n\t\t.slice(2);\n\tlet preactRenderer = new Renderer(hook, rid);\n\n\tcatchErrors(() => {\n\t\tlet isDev = false;\n\t\ttry {\n\t\t\tisDev = process.env.NODE_ENV !== 'production';\n\t\t} catch (e) {}\n\n\t\t// Tell devtools which bundle type we run in\n\t\twindow.parent.postMessage(\n\t\t\t{\n\t\t\t\tsource: 'react-devtools-detector',\n\t\t\t\treactBuildType: /* istanbul ignore next */ isDev\n\t\t\t\t\t? 'development'\n\t\t\t\t\t: 'production'\n\t\t\t},\n\t\t\t'*'\n\t\t);\n\n\t\tlet renderer = {\n\t\t\tbundleType: /* istanbul ignore next */ isDev ? 1 : 0,\n\t\t\tversion: '16.5.2',\n\t\t\trendererPackageName: 'preact',\n\t\t\t// We don't need this, but the devtools `attachRenderer` function relies on\n\t\t\t// it being there.\n\t\t\tfindHostInstanceByFiber(vnode) {\n\t\t\t\treturn vnode._dom;\n\t\t\t},\n\t\t\t// We don't need this, but the devtools `attachRenderer` function relies on\n\t\t\t// it being there.\n\t\t\tfindFiberByHostInstance(instance) {\n\t\t\t\treturn preactRenderer.inst2vnode.get(instance) || null;\n\t\t\t}\n\t\t};\n\n\t\tif (!hook._renderers) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.info(\n\t\t\t\t'Preact is not compatible with your version of react-devtools. We ' +\n\t\t\t\t\t'will address this in future releases.'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\thook._renderers[rid] = renderer;\n\n\t\t// We can't bring our own `attachRenderer` function therefore we simply\n\t\t// prevent the devtools from overwriting our custom renderer by creating\n\t\t// a noop setter.\n\t\tObject.defineProperty(hook.helpers, rid, {\n\t\t\tget: () => preactRenderer,\n\t\t\tset: () => {\n\t\t\t\tif (!preactRenderer.connected) {\n\t\t\t\t\thelpers.markConnected();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tlet helpers = hook.helpers[rid];\n\n\t\t// Tell the devtools that we are ready to start\n\t\thook.emit('renderer-attached', {\n\t\t\tid: rid,\n\t\t\trenderer,\n\t\t\thelpers\n\t\t});\n\n\t\tonCommitRoot = catchErrors(root => {\n\t\t\t// Empty root\n\t\t\tif (root.type === Fragment && root._children.length == 0) return;\n\n\t\t\tlet roots = hook.getFiberRoots(rid);\n\t\t\troot = helpers.handleCommitFiberRoot(root);\n\t\t\tif (!roots.has(root)) roots.add(root);\n\t\t});\n\n\t\tonCommitUnmount = catchErrors(vnode => {\n\t\t\thook.onCommitFiberUnmount(rid, vnode);\n\t\t});\n\t})();\n\n\t// Store (possible) previous hooks so that we don't overwrite them\n\tlet prevVNodeHook = options.vnode;\n\tlet prevCommitRoot = options._commit;\n\tlet prevBeforeUnmount = options.unmount;\n\tlet prevBeforeDiff = options._diff;\n\tlet prevAfterDiff = options.diffed;\n\n\toptions.vnode = vnode => {\n\t\t// Tiny performance improvement by initializing fields as doubles\n\t\t// from the start. `performance.now()` will always return a double.\n\t\t// See https://github.com/facebook/react/issues/14365\n\t\t// and https://slidr.io/bmeurer/javascript-engine-fundamentals-the-good-the-bad-and-the-ugly\n\t\tvnode.startTime = NaN;\n\t\tvnode.endTime = NaN;\n\n\t\tvnode.startTime = 0;\n\t\tvnode.endTime = -1;\n\t\tif (prevVNodeHook) prevVNodeHook(vnode);\n\t};\n\n\toptions._diff = vnode => {\n\t\tvnode.startTime = now();\n\t\tif (prevBeforeDiff != null) prevBeforeDiff(vnode);\n\t};\n\n\toptions.diffed = vnode => {\n\t\tvnode.endTime = now();\n\t\tif (prevAfterDiff != null) prevAfterDiff(vnode);\n\t};\n\n\toptions._commit = catchErrors((vnode, commitQueue) => {\n\t\t// Call previously defined hook\n\t\tif (prevCommitRoot != null) prevCommitRoot(vnode, commitQueue);\n\n\t\t// These cases are already handled by `unmount`\n\t\tif (vnode == null) return;\n\t\tonCommitRoot(vnode);\n\t});\n\n\toptions.unmount = catchErrors(vnode => {\n\t\t// Call previously defined hook\n\t\tif (prevBeforeUnmount != null) prevBeforeUnmount(vnode);\n\t\tonCommitUnmount(vnode);\n\t});\n\n\t// Inject tracking into setState\n\tconst setState = Component.prototype.setState;\n\tComponent.prototype.setState = function(update, callback) {\n\t\t// Duplicated in setState() but doesn't matter due to the guard.\n\t\tlet s =\n\t\t\t(this._nextState !== this.state && this._nextState) ||\n\t\t\t(this._nextState = Object.assign({}, this.state));\n\n\t\t// Needed in order to check if state has changed after the tree has been committed:\n\t\tthis._prevState = Object.assign({}, s);\n\n\t\treturn setState.call(this, update, callback);\n\t};\n}\n\n/**\n * Get current timestamp in ms. Used for profiling.\n * @returns {number}\n */\nexport let now = Date.now;\n\ntry {\n\t/* istanbul ignore else */\n\tnow = performance.now.bind(performance);\n} catch (e) {}\n","import { initDebug } from './debug';\nimport { initDevTools } from './devtools';\n\nif (process.env.NODE_ENV === 'development') {\n\tinitDebug();\n\tinitDevTools();\n}\n"],"names":["loggedTypeFailures","getNodeType","vnode","type","Fragment","getDisplayName","displayName","name","setIn","obj","path","value","last","pop","parent","reduce","acc","attr","getData","c","_component","updater","Component","setState","bind","forceUpdate","setInState","prev","setInProps","props","setInContext","context","children","getChildren","duration","endTime","startTime","nodeType","ref","key","text","state","length","publicInstance","getInstance","memoizedInteractions","actualDuration","actualStartTime","treeBaseDuration","_children","filter","Boolean","isRoot","_parent","_dom","parentNode","shallowEqual","a","b","isProps","Object","keys","isWeakMapSupported","WeakMap","prototype","update","callback","this","_vnode","console","warn","_parentDom","call","serializeVNode","attrs","prop","hasOwnProperty","toString","JSON","stringify","Renderer","hook","rid","pending","inst2vnode","connected","markConnected","flushPendingEvents","events","i","event","emit","mount","set","data","work","internalInstance","renderer","Array","isArray","item","stack","slice","push","child","inst","get","next","_prevState","hasDataChanged","handleCommitFiberRoot","has","root","handleCommitFiberUnmount","delete","getNativeFromReactElement","getReactElementFromNative","dom","walkTree","cleanup","catchErrors","fn","e","error","noop","now","Date","performance","process","env","NODE_ENV","oldBeforeDiff","options","_diff","oldDiffed","diffed","oldVnode","oldCatchError","_catchError","oldRoot","_root","oldHook","_hook","warnedComponents","useEffect","useLayoutEffect","lazyPropTypes","oldVNode","then","promise","Error","_childDidSuspend","isValid","componentName","typeSpecs","values","location","parentVNode","getClosestDomNodeParent","undefined","_lastDomChild","propTypes","m","lazyVNode","forEach","typeSpecName","message","comp","property","err","deprecatedAttributes","nodeName","attributes","source","self","__source","__self","defineProperties","_depth","join","component","__hooks","hooks","_list","_callback","_args","_pendingEffects","effect","_renderCallbacks","possibleEffect","_value","indexOf","initDebug","window","__REACT_DEVTOOLS_GLOBAL_HOOK__","onCommitRoot","onCommitUnmount","Math","random","preactRenderer","isDev","postMessage","reactBuildType","bundleType","version","rendererPackageName","findHostInstanceByFiber","findFiberByHostInstance","instance","_renderers","defineProperty","helpers","id","roots","getFiberRoots","add","onCommitFiberUnmount","info","prevVNodeHook","prevCommitRoot","_commit","prevBeforeUnmount","unmount","prevBeforeDiff","prevAfterDiff","NaN","commitQueue","s","_nextState","assign","initDevTools"],"mappings":"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"}