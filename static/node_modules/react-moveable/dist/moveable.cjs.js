/*
Copyright (c) 2019 Daybrush
name: react-moveable
license: MIT
author: Daybrush
repository: https://github.com/daybrush/moveable/blob/master/packages/react-moveable
version: 0.15.0
*/
'use strict';

var React = require('react');
var frameworkUtils = require('framework-utils');
var getAgent = require('@egjs/agent');
var utils = require('@daybrush/utils');
var matrix = require('@moveable/matrix');
var styler = require('react-css-styler');
var Dragger = require('@daybrush/drag');
var ChildrenDiffer = require('@egjs/children-differ');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

/* global Reflect, Promise */
var extendStatics = function (d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return extendStatics(d, b);
};

function __extends(d, b) {
  extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

var agent = getAgent();
var isWebkit = agent.os.name.indexOf("ios") > -1 || agent.browser.name.indexOf("safari") > -1;
var PREFIX = "moveable-";
var MOVEABLE_CSS = frameworkUtils.prefixCSS(PREFIX, "\n{\n\tposition: fixed;\n\twidth: 0;\n\theight: 0;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 3000;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n\tleft: 0;\n\ttop: 0;\n}\n.control {\n\tposition: absolute;\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n\tbackground: #4af;\n\tmargin-top: -7px;\n    margin-left: -7px;\n    z-index: 10;\n    will-change: transform;\n}\n.line {\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tbackground: #4af;\n\ttransform-origin: 0px 0.5px;\n}\n.line.rotation-line {\n\theight: 40px;\n\twidth: 1px;\n\ttransform-origin: 0.5px 39.5px;\n}\n.line.rotation-line .control {\n\tborder-color: #4af;\n\tbackground:#fff;\n\tcursor: alias;\n}\n.line.vertical.bold {\n    width: 2px;\n    margin-left: -1px;\n}\n.line.horizontal.bold {\n    height: 2px;\n    margin-top: -1px;\n}\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n\tmargin-left: -6px;\n\tpointer-events: none;\n}\n.direction.e, .direction.w {\n\tcursor: ew-resize;\n}\n.direction.s, .direction.n {\n\tcursor: ns-resize;\n}\n.direction.nw, .direction.se, :host.reverse .direction.ne, :host.reverse .direction.sw {\n\tcursor: nwse-resize;\n}\n.direction.ne, .direction.sw, :host.reverse .direction.nw, :host.reverse .direction.se {\n\tcursor: nesw-resize;\n}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n" + (isWebkit ? ":global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}" : "") + "\n");
var NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]];
var TINY_NUM = 0.0000001;
var MIN_SCALE = 0.000000001;
var MAX_NUM = Math.pow(10, 10);
var MIN_NUM = -MAX_NUM;
var DIRECTION_INDEXES = {
  n: [0, 1],
  s: [2, 3],
  w: [2, 0],
  e: [1, 3],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
};

function multiply2(pos1, pos2) {
  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];
}
function prefix() {
  var classNames = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    classNames[_i] = arguments[_i];
  }

  return frameworkUtils.prefixNames.apply(void 0, [PREFIX].concat(classNames));
}
function createIdentityMatrix3() {
  return matrix.createIdentityMatrix(3);
}
function getTransformMatrix(transform) {
  if (!transform || transform === "none") {
    return [1, 0, 0, 1, 0, 0];
  }

  if (utils.isObject(transform)) {
    return transform;
  }

  var value = utils.splitBracket(transform).value;
  return value.split(/s*,\s*/g).map(function (v) {
    return parseFloat(v);
  });
}
function getAbsoluteMatrix(matrix$1, n, origin) {
  return matrix.multiplies(n, matrix.createOriginMatrix(origin, n), matrix$1, matrix.createOriginMatrix(origin.map(function (a) {
    return -a;
  }), n));
}
function measureSVGSize(el, unit, isHorizontal) {
  if (unit === "%") {
    var viewBox = el.ownerSVGElement.viewBox.baseVal;
    return viewBox[isHorizontal ? "width" : "height"] / 100;
  }

  return 1;
}
function getBeforeTransformOrigin(el) {
  var relativeOrigin = getTransformOrigin(getComputedStyle(el, ":before"));
  return relativeOrigin.map(function (o, i) {
    var _a = utils.splitUnit(o),
        value = _a.value,
        unit = _a.unit;

    return value * measureSVGSize(el, unit, i === 0);
  });
}
function getTransformOrigin(style) {
  var transformOrigin = style.transformOrigin;
  return transformOrigin ? transformOrigin.split(" ") : ["0", "0"];
}
function getOffsetInfo(el, lastParent, isParent) {
  var body = document.body;
  var target = !el || isParent ? el : el.parentElement;
  var isEnd = false;
  var position = "relative";

  while (target && target !== body) {
    if (lastParent === target) {
      isEnd = true;
    }

    var style = getComputedStyle(target);
    var transform = style.transform;
    position = style.position;

    if (position !== "static" || transform && transform !== "none") {
      break;
    }

    target = target.parentElement;
    position = "relative";
  }

  return {
    isStatic: position === "static",
    isEnd: isEnd || !target || target === body,
    offsetParent: target || body
  };
}
function caculateMatrixStack(target, container, prevMatrix, prevN) {
  var _a;

  var el = target;
  var matrixes = [];
  var isSVGGraphicElement = el.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in el;
  var originalContainer = container || document.body;
  var isEnd = false;
  var is3d = false;
  var n = 3;
  var transformOrigin;
  var targetMatrix;
  var offsetContainer = getOffsetInfo(container, container, true).offsetParent;

  if (prevMatrix) {
    container = target.parentElement;
  }

  while (el && !isEnd) {
    var style = getComputedStyle(el);
    var tagName = el.tagName.toLowerCase();
    var position = style.position;
    var isFixed = position === "fixed";
    var styleTransform = style.transform;
    var matrix$1 = matrix.convertCSStoMatrix(getTransformMatrix(styleTransform));

    if (!is3d && matrix$1.length === 16) {
      is3d = true;
      n = 4;
      var matrixesLength = matrixes.length;

      for (var i = 0; i < matrixesLength; ++i) {
        matrixes[i] = matrix.convertDimension(matrixes[i], 3, 4);
      }
    }

    if (is3d && matrix$1.length === 9) {
      matrix$1 = matrix.convertDimension(matrix$1, 3, 4);
    }

    var offsetLeft = el.offsetLeft;
    var offsetTop = el.offsetTop;

    if (isFixed) {
      var containerRect = (container || document.documentElement).getBoundingClientRect();
      offsetLeft -= containerRect.left;
      offsetTop -= containerRect.top;
    } // svg


    var isSVG = utils.isUndefined(offsetLeft);
    var hasNotOffset = isSVG;
    var origin = void 0; // inner svg element

    if (hasNotOffset && tagName !== "svg") {
      origin = isWebkit ? getBeforeTransformOrigin(el) : getTransformOrigin(style).map(function (pos) {
        return parseFloat(pos);
      });
      hasNotOffset = false;

      if (tagName === "g") {
        offsetLeft = 0;
        offsetTop = 0;
      } else {
        _a = getSVGGraphicsOffset(el, origin), offsetLeft = _a[0], offsetTop = _a[1], origin[0] = _a[2], origin[1] = _a[3];
      }
    } else {
      origin = getTransformOrigin(style).map(function (pos) {
        return parseFloat(pos);
      });
    }

    if (tagName === "svg" && targetMatrix) {
      matrixes.push(getSVGMatrix(el, n), matrix.createIdentityMatrix(n));
    }

    var _b = getOffsetInfo(el, container),
        offsetParent = _b.offsetParent,
        isOffsetEnd = _b.isEnd,
        isStatic = _b.isStatic;

    if (isWebkit && !hasNotOffset && !isSVG && isStatic && position === "relative") {
      offsetLeft -= offsetParent.offsetLeft;
      offsetTop -= offsetParent.offsetTop;
      isEnd = isEnd || isOffsetEnd;
    }

    var parentClientLeft = 0;
    var parentClientTop = 0;

    if (!hasNotOffset && offsetContainer !== offsetParent) {
      parentClientLeft = offsetParent.clientLeft;
      parentClientTop = offsetParent.clientTop;
    }

    matrixes.push(getAbsoluteMatrix(matrix$1, n, origin), matrix.createOriginMatrix([hasNotOffset ? el : offsetLeft - el.scrollLeft + parentClientLeft, hasNotOffset ? origin : offsetTop - el.scrollTop + parentClientTop], n));

    if (!targetMatrix) {
      targetMatrix = matrix$1;
    }

    if (!transformOrigin) {
      transformOrigin = origin;
    }

    if (isEnd || isFixed) {
      break;
    } else {
      el = offsetParent;
      isEnd = isOffsetEnd;
    }
  }

  var mat = prevMatrix ? matrix.convertDimension(prevMatrix, prevN, n) : matrix.createIdentityMatrix(n);
  var beforeMatrix = prevMatrix ? matrix.convertDimension(prevMatrix, prevN, n) : matrix.createIdentityMatrix(n);
  var offsetMatrix = matrix.createIdentityMatrix(n);
  var length = matrixes.length;
  var endContainer = getOffsetInfo(originalContainer, originalContainer, true).offsetParent;
  matrixes.reverse();
  matrixes.forEach(function (matrix$1, i) {
    var _a;

    if (length - 2 === i) {
      beforeMatrix = mat.slice();
    }

    if (length - 1 === i) {
      offsetMatrix = mat.slice();
    }

    if (utils.isObject(matrix$1[n - 1])) {
      _a = getSVGOffset(matrix$1[n - 1], endContainer, n, matrix$1[2 * n - 1], mat, matrixes[i + 1]), matrix$1[n - 1] = _a[0], matrix$1[2 * n - 1] = _a[1];
    }

    mat = matrix.multiply(mat, matrix$1, n);
  });
  var isMatrix3d = !isSVGGraphicElement && is3d;
  var transform = (isMatrix3d ? "matrix3d" : "matrix") + "(" + matrix.convertMatrixtoCSS(isSVGGraphicElement && targetMatrix.length === 16 ? matrix.convertDimension(targetMatrix, 4, 3) : targetMatrix) + ")";
  return [beforeMatrix, offsetMatrix, mat, targetMatrix, transform, transformOrigin, is3d];
}
function getSVGMatrix(el, n) {
  var clientWidth = el.clientWidth;
  var clientHeight = el.clientHeight;
  var viewBox = el.viewBox.baseVal;
  var viewBoxWidth = viewBox.width || clientWidth;
  var viewBoxHeight = viewBox.height || clientHeight;
  var scaleX = clientWidth / viewBoxWidth;
  var scaleY = clientHeight / viewBoxHeight;
  var preserveAspectRatio = el.preserveAspectRatio.baseVal; // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio

  var align = preserveAspectRatio.align; // 1 : meet 2: slice

  var meetOrSlice = preserveAspectRatio.meetOrSlice;
  var svgOrigin = [0, 0];
  var scale = [scaleX, scaleY];
  var translate = [0, 0];

  if (align !== 1) {
    var xAlign = (align - 2) % 3;
    var yAlign = Math.floor((align - 2) / 3);
    svgOrigin[0] = viewBoxWidth * xAlign / 2;
    svgOrigin[1] = viewBoxHeight * yAlign / 2;
    var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);
    scale[0] = scaleDimension;
    scale[1] = scaleDimension;
    translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;
    translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;
  }

  var scaleMatrix = matrix.createScaleMatrix(scale, n);
  scaleMatrix[n - 1] = translate[0], scaleMatrix[2 * n - 1] = translate[1];
  return getAbsoluteMatrix(scaleMatrix, n, svgOrigin);
}
function getSVGGraphicsOffset(el, origin) {
  if (!el.getBBox) {
    return [0, 0];
  }

  var bbox = el.getBBox();
  var svgElement = el.ownerSVGElement;
  var viewBox = svgElement.viewBox.baseVal;
  var left = bbox.x - viewBox.x;
  var top = bbox.y - viewBox.y;
  return [left, top, origin[0] - left, origin[1] - top];
}
function caculatePosition(matrix$1, pos, n) {
  return matrix.caculate(matrix$1, matrix.convertPositionMatrix(pos, n), n);
}
function caculatePoses(matrix, width, height, n) {
  var pos1 = caculatePosition(matrix, [0, 0], n);
  var pos2 = caculatePosition(matrix, [width, 0], n);
  var pos3 = caculatePosition(matrix, [0, height], n);
  var pos4 = caculatePosition(matrix, [width, height], n);
  return [pos1, pos2, pos3, pos4];
}
function getRect(poses) {
  var posesX = poses.map(function (pos) {
    return pos[0];
  });
  var posesY = poses.map(function (pos) {
    return pos[1];
  });
  var left = Math.min.apply(Math, posesX);
  var top = Math.min.apply(Math, posesY);
  var right = Math.max.apply(Math, posesX);
  var bottom = Math.max.apply(Math, posesY);
  var rectWidth = right - left;
  var rectHeight = bottom - top;
  return {
    left: left,
    top: top,
    right: right,
    bottom: bottom,
    width: rectWidth,
    height: rectHeight
  };
}
function caculateRect(matrix, width, height, n) {
  var poses = caculatePoses(matrix, width, height, n);
  return getRect(poses);
}
function getSVGOffset(el, container, n, origin, beforeMatrix, absoluteMatrix) {
  var _a;

  var _b = getSize(el),
      width = _b[0],
      height = _b[1];

  var containerRect = container.getBoundingClientRect();
  var rect = el.getBoundingClientRect();
  var rectLeft = rect.left - containerRect.left + container.scrollLeft;
  var rectTop = rect.top - containerRect.top + container.scrollTop;
  var rectWidth = rect.width;
  var rectHeight = rect.height;
  var mat = matrix.multiplies(n, beforeMatrix, absoluteMatrix);

  var _c = caculateRect(mat, width, height, n),
      prevLeft = _c.left,
      prevTop = _c.top,
      prevWidth = _c.width,
      prevHeight = _c.height;

  var posOrigin = caculatePosition(mat, origin, n);
  var prevOrigin = matrix.minus(posOrigin, [prevLeft, prevTop]);
  var rectOrigin = [rectLeft + prevOrigin[0] * rectWidth / prevWidth, rectTop + prevOrigin[1] * rectHeight / prevHeight];
  var offset = [0, 0];
  var count = 0;

  while (++count < 10) {
    var inverseBeforeMatrix = matrix.invert(beforeMatrix, n);
    _a = matrix.minus(caculatePosition(inverseBeforeMatrix, rectOrigin, n), caculatePosition(inverseBeforeMatrix, posOrigin, n)), offset[0] = _a[0], offset[1] = _a[1];
    var mat2 = matrix.multiplies(n, beforeMatrix, matrix.createOriginMatrix(offset, n), absoluteMatrix);

    var _d = caculateRect(mat2, width, height, n),
        nextLeft = _d.left,
        nextTop = _d.top;

    var distLeft = nextLeft - rectLeft;
    var distTop = nextTop - rectTop;

    if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {
      break;
    }

    rectOrigin[0] -= distLeft;
    rectOrigin[1] -= distTop;
  }

  return offset.map(function (p) {
    return Math.round(p);
  });
}
function caculateMoveablePosition(matrix$1, origin, width, height) {
  var is3d = matrix$1.length === 16;
  var n = is3d ? 4 : 3;

  var _a = caculatePoses(matrix$1, width, height, n),
      _b = _a[0],
      x1 = _b[0],
      y1 = _b[1],
      _c = _a[1],
      x2 = _c[0],
      y2 = _c[1],
      _d = _a[2],
      x3 = _d[0],
      y3 = _d[1],
      _e = _a[3],
      x4 = _e[0],
      y4 = _e[1];

  var _f = caculatePosition(matrix$1, origin, n),
      originX = _f[0],
      originY = _f[1];

  var left = Math.min(x1, x2, x3, x4);
  var top = Math.min(y1, y2, y3, y4);
  var right = Math.max(x1, x2, x3, x4);
  var bottom = Math.max(y1, y2, y3, y4);
  x1 = x1 - left || 0;
  x2 = x2 - left || 0;
  x3 = x3 - left || 0;
  x4 = x4 - left || 0;
  y1 = y1 - top || 0;
  y2 = y2 - top || 0;
  y3 = y3 - top || 0;
  y4 = y4 - top || 0;
  originX = originX - left || 0;
  originY = originY - top || 0;
  var center = [(x1 + x2 + x3 + x4) / 4, (y1 + y2 + y3 + y4) / 4];
  var pos1Rad = matrix.getRad(center, [x1, y1]);
  var pos2Rad = matrix.getRad(center, [x2, y2]);
  var direction = pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI || pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI ? 1 : -1;
  return [[left, top, right, bottom], [originX, originY], [x1, y1], [x2, y2], [x3, y3], [x4, y4], direction];
}
function getLineStyle(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var width = Math.sqrt(distX * distX + distY * distY);
  var rad = matrix.getRad(pos1, pos2);
  return {
    transform: "translate(" + pos1[0] + "px, " + pos1[1] + "px) rotate(" + rad + "rad)",
    width: width + "px"
  };
}
function getControlTransform(rotation) {
  var poses = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    poses[_i - 1] = arguments[_i];
  }

  var length = poses.length;
  var x = poses.reduce(function (prev, pos) {
    return prev + pos[0];
  }, 0) / length;
  var y = poses.reduce(function (prev, pos) {
    return prev + pos[1];
  }, 0) / length;
  return {
    transform: "translate(" + x + "px, " + y + "px) rotate(" + rotation + "deg)"
  };
}
function getCSSSize(target) {
  var style = window.getComputedStyle(target);
  return [parseFloat(style.width), parseFloat(style.height)];
}
function getSize(target, style, isOffset, isBoxSizing) {
  if (style === void 0) {
    style = window.getComputedStyle(target);
  }

  if (isBoxSizing === void 0) {
    isBoxSizing = isOffset || style.boxSizing === "border-box";
  }

  var width = target.offsetWidth;
  var height = target.offsetHeight;
  var hasOffset = !utils.isUndefined(width);

  if ((isOffset || isBoxSizing) && hasOffset) {
    return [width, height];
  }

  width = target.clientWidth;
  height = target.clientHeight;

  if (!hasOffset && !width && !height) {
    var bbox = target.getBBox();
    return [bbox.width, bbox.height];
  }

  if (isOffset || isBoxSizing) {
    var borderLeft = parseFloat(style.borderLeftWidth) || 0;
    var borderRight = parseFloat(style.borderRightWidth) || 0;
    var borderTop = parseFloat(style.borderTopWidth) || 0;
    var borderBottom = parseFloat(style.borderBottomWidth) || 0;
    return [width + borderLeft + borderRight, height + borderTop + borderBottom];
  } else {
    var paddingLeft = parseFloat(style.paddingLeft) || 0;
    var paddingRight = parseFloat(style.paddingRight) || 0;
    var paddingTop = parseFloat(style.paddingTop) || 0;
    var paddingBottom = parseFloat(style.paddingBottom) || 0;
    return [width - paddingLeft - paddingRight, height - paddingTop - paddingBottom];
  }
}
function getRotationRad(poses, direction) {
  return matrix.getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);
}
function getTargetInfo(target, container, parentContainer, state) {
  var _a, _b, _c, _d, _e;

  var left = 0;
  var top = 0;
  var right = 0;
  var bottom = 0;
  var origin = [0, 0];
  var pos1 = [0, 0];
  var pos2 = [0, 0];
  var pos3 = [0, 0];
  var pos4 = [0, 0];
  var offsetMatrix = createIdentityMatrix3();
  var beforeMatrix = createIdentityMatrix3();
  var matrix$1 = createIdentityMatrix3();
  var targetMatrix = createIdentityMatrix3();
  var width = 0;
  var height = 0;
  var transformOrigin = [0, 0];
  var direction = 1;
  var beforeDirection = 1;
  var is3d = false;
  var targetTransform = "";
  var beforeOrigin = [0, 0];
  var clientRect = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    width: 0,
    height: 0
  };
  var containerRect = {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    width: 0,
    height: 0
  };
  var rotation = 0;
  var prevMatrix = state ? state.beforeMatrix : undefined;
  var prevN = state ? state.is3d ? 4 : 3 : undefined;

  if (target) {
    if (state) {
      width = state.width;
      height = state.height;
    } else {
      var style = getComputedStyle(target);
      width = target.offsetWidth;
      height = target.offsetHeight;

      if (utils.isUndefined(width)) {
        _a = getSize(target, style, true), width = _a[0], height = _a[1];
      }
    }

    _b = caculateMatrixStack(target, container, prevMatrix, prevN), beforeMatrix = _b[0], offsetMatrix = _b[1], matrix$1 = _b[2], targetMatrix = _b[3], targetTransform = _b[4], transformOrigin = _b[5], is3d = _b[6];
    _c = caculateMoveablePosition(matrix$1, transformOrigin, width, height), _d = _c[0], left = _d[0], top = _d[1], right = _d[2], bottom = _d[3], origin = _c[1], pos1 = _c[2], pos2 = _c[3], pos3 = _c[4], pos4 = _c[5], direction = _c[6];
    var n = is3d ? 4 : 3;
    var beforePos = [0, 0];
    _e = caculateMoveablePosition(offsetMatrix, matrix.plus(transformOrigin, matrix.getOrigin(targetMatrix, n)), width, height), beforePos = _e[0], beforeOrigin = _e[1], beforeDirection = _e[6];
    beforeOrigin = [beforeOrigin[0] + beforePos[0] - left, beforeOrigin[1] + beforePos[1] - top];
    clientRect = getClientRect(target);
    containerRect = getClientRect(getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body);
    rotation = getRotationRad([pos1, pos2], direction);
  }

  return {
    rotation: rotation,
    containerRect: containerRect,
    beforeDirection: beforeDirection,
    direction: direction,
    target: target,
    left: left,
    top: top,
    right: right,
    bottom: bottom,
    pos1: pos1,
    pos2: pos2,
    pos3: pos3,
    pos4: pos4,
    width: width,
    height: height,
    beforeMatrix: beforeMatrix,
    matrix: matrix$1,
    targetTransform: targetTransform,
    offsetMatrix: offsetMatrix,
    targetMatrix: targetMatrix,
    is3d: is3d,
    beforeOrigin: beforeOrigin,
    origin: origin,
    transformOrigin: transformOrigin,
    clientRect: clientRect
  };
}
function getClientRect(el) {
  var _a = el.getBoundingClientRect(),
      left = _a.left,
      width = _a.width,
      top = _a.top,
      bottom = _a.bottom,
      right = _a.right,
      height = _a.height;

  return {
    left: left,
    right: right,
    top: top,
    bottom: bottom,
    width: width,
    height: height
  };
}
function getDirection(target) {
  if (!target) {
    return;
  }

  var direciton = target.getAttribute("data-direction");

  if (!direciton) {
    return;
  }

  var dir = [0, 0];
  direciton.indexOf("w") > -1 && (dir[0] = -1);
  direciton.indexOf("e") > -1 && (dir[0] = 1);
  direciton.indexOf("n") > -1 && (dir[1] = -1);
  direciton.indexOf("s") > -1 && (dir[1] = 1);
  return dir;
}
function getAbsolutePoses(poses, dist) {
  return [matrix.plus(dist, poses[0]), matrix.plus(dist, poses[1]), matrix.plus(dist, poses[2]), matrix.plus(dist, poses[3])];
}
function getAbsolutePosesByState(_a) {
  var left = _a.left,
      top = _a.top,
      pos1 = _a.pos1,
      pos2 = _a.pos2,
      pos3 = _a.pos3,
      pos4 = _a.pos4;
  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);
}
function throttle(num, unit) {
  if (!unit) {
    return num;
  }

  return Math.round(num / unit) * unit;
}
function throttleArray(nums, unit) {
  nums.forEach(function (_, i) {
    nums[i] = throttle(nums[i], unit);
  });
  return nums;
}
function unset(self, name) {
  if (self[name]) {
    self[name].unset();
    self[name] = null;
  }
}
function getOrientationDirection(pos, pos1, pos2) {
  return (pos[0] - pos1[0]) * (pos2[1] - pos1[1]) - (pos[1] - pos1[1]) * (pos2[0] - pos1[0]);
}
function isInside(pos, pos1, pos2, pos3, pos4) {
  var k1 = getOrientationDirection(pos, pos1, pos2);
  var k2 = getOrientationDirection(pos, pos2, pos4);
  var k3 = getOrientationDirection(pos, pos4, pos1);
  var k4 = getOrientationDirection(pos, pos2, pos4);
  var k5 = getOrientationDirection(pos, pos4, pos3);
  var k6 = getOrientationDirection(pos, pos3, pos2);
  var signs1 = [k1, k2, k3];
  var signs2 = [k4, k5, k6];

  if (signs1.every(function (sign) {
    return sign >= 0;
  }) || signs1.every(function (sign) {
    return sign <= 0;
  }) || signs2.every(function (sign) {
    return sign >= 0;
  }) || signs2.every(function (sign) {
    return sign <= 0;
  })) {
    return true;
  }

  return false;
}
function fillParams(moveable, e, params) {
  var datas = e.datas;

  if (!datas.datas) {
    datas.datas = {};
  }

  return __assign({}, params, {
    target: moveable.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: moveable,
    datas: datas.datas
  });
}
function triggerEvent(moveable, name, params) {
  return moveable.triggerEvent(name, params);
}
function getComputedStyle(el, pseudoElt) {
  return window.getComputedStyle(el, pseudoElt);
}
function filterAbles(ables, methods) {
  var enabledAbles = {};
  var ableGroups = {};
  return ables.filter(function (able) {
    var name = able.name;

    if (enabledAbles[name] || !methods.some(function (method) {
      return able[method];
    })) {
      return false;
    }

    if (able.ableGroup) {
      if (ableGroups[name]) {
        return false;
      }

      ableGroups[name] = true;
    }

    enabledAbles[name] = true;
    return true;
  });
}
function getKeepRatioHeight(width, isWidth, ratio) {
  return width * (isWidth ? ratio : 1 / ratio);
}
function getKeepRatioWidth(height, isWidth, ratio) {
  return height * (isWidth ? 1 / ratio : ratio);
}
function equals(a1, a2) {
  if (a1 === a2) {
    return true;
  } else if (a1 == null && a2 == null) {
    return true;
  } else {
    return false;
  }
}

function triggerRenderStart(moveable, isGroup, e) {
  var params = fillParams(moveable, e, {
    isPinch: !!e.isPinch
  });
  var eventAffix = isGroup ? "Group" : "";

  if (isGroup) {
    params.targets = moveable.props.targets;
  }

  triggerEvent(moveable, "onRender" + eventAffix + "Start", params);
}
function triggerRender(moveable, isGroup, e) {
  var params = fillParams(moveable, e, {
    isPinch: !!e.isPinch
  });
  var eventAffix = isGroup ? "Group" : "";

  if (isGroup) {
    params.targets = moveable.props.targets;
  }

  triggerEvent(moveable, "onRender" + eventAffix, params);
}
function triggerRenderEnd(moveable, isGroup, e) {
  var params = fillParams(moveable, e, {
    isPinch: !!e.sPinch,
    isDrag: e.isDrag
  });
  var eventAffix = isGroup ? "Group" : "";

  if (isGroup) {
    params.targets = moveable.props.targets;
  }

  triggerEvent(moveable, "onRender" + eventAffix + "End", params);
}

function triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e) {
  var isStart = eventType === "Start";

  if (isStart && eventAffix.indexOf("Control") > -1 && moveable.areaElement === e.inputEvent.target) {
    return false;
  }

  var eventName = "" + eventOperation + eventAffix + eventType;
  var conditionName = "" + eventOperation + eventAffix + "Condition";
  var isEnd = eventType === "End";
  var isAfter = eventType.indexOf("After") > -1;

  if (isStart) {
    moveable.updateRect(eventType, true, false);
  }

  var isGroup = eventAffix.indexOf("Group") > -1;
  var ables = moveable[ableType];
  var results = ables.filter(function (able) {
    var condition = isStart && able[conditionName];

    if (able[eventName] && (!condition || condition(e.inputEvent.target, moveable))) {
      return able[eventName](moveable, e);
    }

    return false;
  });
  var isUpdate = results.length;

  if (isStart) {
    triggerRenderStart(moveable, isGroup, e);
  } else if (isEnd) {
    triggerRenderEnd(moveable, isGroup, e);
  } else if (isUpdate) {
    triggerRender(moveable, isGroup, e);
  }

  if (isEnd) {
    moveable.state.dragger = null;
  }

  if (!isStart && isUpdate) {
    if (results.some(function (able) {
      return able.updateRect;
    }) && !isGroup) {
      moveable.updateRect(eventType, false, false);
    } else {
      moveable.updateRect(eventType, true, false);
    }
  }

  if (!isStart && isUpdate || isEnd && !isUpdate) {
    moveable.forceUpdate();
  }

  if (!isStart && !isEnd && !isAfter && isUpdate) {
    triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + "After", e);
  }
}

function getAbleDragger(moveable, target, ableType, eventAffix) {
  var options = {
    container: window,
    pinchThreshold: moveable.props.pinchThreshold
  };
  ["drag", "pinch"].forEach(function (eventOperation) {
    ["Start", "", "End"].forEach(function (eventType) {
      options["" + eventOperation + eventType.toLowerCase()] = function (e) {
        return triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);
      };
    });
  });
  return new Dragger(target, options);
}

var ControlBoxElement = styler("div", MOVEABLE_CSS);

function renderLine(direction, pos1, pos2, index) {
  return React.createElement("div", {
    key: "line" + index,
    className: prefix("line", "direction", direction),
    "data-direction": direction,
    style: getLineStyle(pos1, pos2)
  });
}

var MoveableManager =
/*#__PURE__*/
function (_super) {
  __extends(MoveableManager, _super);

  function MoveableManager() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = {
      conatainer: null,
      target: null,
      beforeMatrix: createIdentityMatrix3(),
      matrix: createIdentityMatrix3(),
      targetMatrix: createIdentityMatrix3(),
      targetTransform: "",
      is3d: false,
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      transformOrigin: [0, 0],
      direction: 1,
      beforeDirection: 1,
      beforeOrigin: [0, 0],
      origin: [0, 0],
      pos1: [0, 0],
      pos2: [0, 0],
      pos3: [0, 0],
      pos4: [0, 0],
      clientRect: {
        left: 0,
        top: 0,
        bottom: 0,
        right: 0,
        width: 0,
        height: 0
      },
      containerRect: {
        left: 0,
        top: 0,
        bottom: 0,
        right: 0,
        width: 0,
        height: 0
      },
      rotation: 0
    };
    _this.targetAbles = [];
    _this.controlAbles = [];
    return _this;
  }

  var __proto = MoveableManager.prototype;

  __proto.render = function () {
    var _a = this.props,
        edge = _a.edge,
        parentPosition = _a.parentPosition,
        className = _a.className;
    this.checkUpdate();

    var _b = parentPosition || {
      left: 0,
      top: 0
    },
        parentLeft = _b.left,
        parentTop = _b.top;

    var _c = this.state,
        left = _c.left,
        top = _c.top,
        pos1 = _c.pos1,
        pos2 = _c.pos2,
        pos3 = _c.pos3,
        pos4 = _c.pos4,
        target = _c.target,
        direction = _c.direction;
    return React.createElement(ControlBoxElement, {
      ref: frameworkUtils.ref(this, "controlBox"),
      className: prefix("control-box", direction === -1 ? "reverse" : "") + " " + className,
      style: {
        position: "absolute",
        display: target ? "block" : "none",
        transform: "translate(" + (left - parentLeft) + "px, " + (top - parentTop) + "px) translateZ(50px)"
      }
    }, this.renderAbles(), renderLine(edge ? "n" : "", pos1, pos2, 0), renderLine(edge ? "e" : "", pos2, pos4, 1), renderLine(edge ? "w" : "", pos1, pos3, 2), renderLine(edge ? "s" : "", pos3, pos4, 3));
  };

  __proto.componentDidMount = function () {
    this.controlBox.getElement();
    var props = this.props;
    var parentMoveable = props.parentMoveable,
        container = props.container;
    this.updateEvent(props);

    if (!container && !parentMoveable) {
      this.updateRect("End", false, true);
    }
  };

  __proto.componentDidUpdate = function (prevProps) {
    this.updateEvent(prevProps);
  };

  __proto.componentWillUnmount = function () {
    unset(this, "targetDragger");
    unset(this, "controlDragger");
  };

  __proto.getContainer = function () {
    var _a = this.props,
        parentMoveable = _a.parentMoveable,
        container = _a.container;
    return container || parentMoveable && parentMoveable.getContainer() || this.controlBox.getElement().parentElement;
  };

  __proto.isMoveableElement = function (target) {
    return target && (target.getAttribute("class") || "").indexOf(PREFIX) > -1;
  };

  __proto.dragStart = function (e) {
    if (this.targetDragger) {
      this.targetDragger.onDragStart(e);
    }
  };

  __proto.isInside = function (clientX, clientY) {
    var _a = this.state,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos3 = _a.pos3,
        pos4 = _a.pos4,
        target = _a.target;

    if (!target) {
      return false;
    }

    var _b = target.getBoundingClientRect(),
        left = _b.left,
        top = _b.top;

    var pos = [clientX - left, clientY - top];
    return isInside(pos, pos1, pos2, pos4, pos3);
  };

  __proto.updateRect = function (type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }

    var parentMoveable = this.props.parentMoveable;
    var state = this.state;
    var target = state.target || this.props.target;
    var container = this.getContainer();
    this.updateState(getTargetInfo(target, container, container, isTarget ? state : undefined), parentMoveable ? false : isSetState);
  };

  __proto.updateEvent = function (prevProps) {
    var controlBoxElement = this.controlBox.getElement();
    var hasTargetAble = this.targetAbles.length;
    var hasControlAble = this.controlAbles.length;
    var target = this.props.target;
    var prevTarget = prevProps.target;
    var dragArea = this.props.dragArea;
    var prevDragArea = prevProps.dragArea;
    var isTargetChanged = !dragArea && prevTarget !== target;
    var isUnset = !hasTargetAble && this.targetDragger || isTargetChanged || prevDragArea !== dragArea;

    if (isUnset) {
      unset(this, "targetDragger");
      this.updateState({
        dragger: null
      });
    }

    if (!hasControlAble) {
      unset(this, "controlDragger");
    }

    if (target && hasTargetAble && !this.targetDragger) {
      if (dragArea) {
        this.targetDragger = getAbleDragger(this, this.areaElement, "targetAbles", "");
      } else {
        this.targetDragger = getAbleDragger(this, target, "targetAbles", "");
      }
    }

    if (!this.controlDragger && hasControlAble) {
      this.controlDragger = getAbleDragger(this, controlBoxElement, "controlAbles", "Control");
    }

    if (isUnset) {
      this.unsetAbles();
    }
  };

  __proto.updateTarget = function (type) {
    this.updateRect(type, true);
  };

  __proto.getRect = function () {
    var state = this.state;
    var poses = getAbsolutePosesByState(this.state);
    var pos1 = poses[0],
        pos2 = poses[1],
        pos3 = poses[2],
        pos4 = poses[3];
    var rect = getRect(poses);
    var offsetWidth = state.width,
        offsetHeight = state.height;
    var width = rect.width,
        height = rect.height,
        left = rect.left,
        top = rect.top;
    return {
      width: width,
      height: height,
      left: left,
      top: top,
      pos1: pos1,
      pos2: pos2,
      pos3: pos3,
      pos4: pos4,
      offsetWidth: offsetWidth,
      offsetHeight: offsetHeight
    };
  };

  __proto.checkUpdate = function () {
    var _a = this.props,
        target = _a.target,
        container = _a.container,
        parentMoveable = _a.parentMoveable;
    var _b = this.state,
        stateTarget = _b.target,
        stateContainer = _b.container;

    if (!stateTarget && !target) {
      return;
    }

    this.updateAbles();
    var isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);

    if (!isChanged) {
      return;
    }

    this.updateState({
      target: target,
      container: container
    });

    if (!parentMoveable && (container || this.controlBox)) {
      this.updateRect("End", false, false);
    }
  };

  __proto.triggerEvent = function (name, e) {
    var callback = this.props[name];
    return callback && callback(e);
  };

  __proto.unsetAbles = function () {
    var _this = this;

    if (this.targetAbles.filter(function (able) {
      if (able.unset) {
        able.unset(_this);
        return true;
      }

      return false;
    }).length) {
      this.forceUpdate();
    }
  };

  __proto.updateAbles = function (ables, eventAffix) {
    if (ables === void 0) {
      ables = this.props.ables;
    }

    if (eventAffix === void 0) {
      eventAffix = "";
    }

    var props = this.props;
    var enabledAbles = ables.filter(function (able) {
      return able && props[able.name];
    });
    var dragStart = "drag" + eventAffix + "Start";
    var pinchStart = "pinch" + eventAffix + "Start";
    var dragControlStart = "drag" + eventAffix + "ControlStart";
    var targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart]);
    var controlAbles = filterAbles(enabledAbles, [dragControlStart]);
    this.targetAbles = targetAbles;
    this.controlAbles = controlAbles;
  };

  __proto.updateState = function (nextState, isSetState) {
    if (isSetState) {
      this.setState(nextState);
    } else {
      var state = this.state;

      for (var name in nextState) {
        state[name] = nextState[name];
      }
    }
  };

  __proto.renderAbles = function () {
    var _this = this;

    var props = this.props;
    var ables = props.ables;
    var enabledAbles = ables.filter(function (able) {
      return able && props[able.name];
    });
    return filterAbles(enabledAbles, ["render"]).map(function (_a) {
      var render = _a.render;
      return render(_this, React);
    });
  };

  MoveableManager.defaultProps = {
    target: null,
    container: null,
    origin: true,
    keepRatio: false,
    edge: false,
    parentMoveable: null,
    parentPosition: null,
    ables: [],
    pinchThreshold: 20,
    dragArea: false,
    transformOrigin: "",
    className: ""
  };
  return MoveableManager;
}(React.PureComponent);

function getRotatiion(touches) {
  return matrix.getRad([touches[0].clientX, touches[0].clientY], [touches[1].clientX, touches[1].clientY]) / Math.PI * 180;
}

var Pinchable = {
  name: "pinchable",
  updateRect: true,
  pinchStart: function (moveable, e) {
    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        touches = e.touches,
        inputEvent = e.inputEvent,
        targets = e.targets;
    var _a = moveable.props,
        pinchable = _a.pinchable,
        ables = _a.ables;

    if (!pinchable) {
      return false;
    }

    var eventName = "onPinch" + (targets ? "Group" : "") + "Start";
    var controlEventName = "drag" + (targets ? "Group" : "") + "ControlStart";
    var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function (able) {
      return pinchable.indexOf(able.name) > -1;
    })).filter(function (able) {
      return able.canPinch && able[controlEventName];
    });
    var params = fillParams(moveable, e, {});

    if (targets) {
      params.targets = targets;
    }

    var result = triggerEvent(moveable, eventName, params);
    datas.isPinch = result !== false;
    datas.ables = pinchAbles;
    var isPinch = datas.isPinch;

    if (!isPinch) {
      return false;
    }

    var parentRotate = getRotatiion(touches);
    pinchAbles.forEach(function (able) {
      datas[able.name + "Datas"] = {};
      var ableEvent = {
        datas: datas[able.name + "Datas"],
        clientX: clientX,
        clientY: clientY,
        inputEvent: inputEvent,
        parentRotate: parentRotate,
        pinchFlag: true
      };
      able[controlEventName](moveable, ableEvent);
    });
    moveable.state.snapDirection = [0, 0];
    return isPinch;
  },
  pinch: function (moveable, e) {
    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        pinchScale = e.scale,
        distance = e.distance,
        touches = e.touches,
        inputEvent = e.inputEvent,
        targets = e.targets;

    if (!datas.isPinch) {
      return;
    }

    var parentRotate = getRotatiion(touches);
    var parentDistance = distance * (1 - 1 / pinchScale);
    var params = fillParams(moveable, e, {});

    if (targets) {
      params.targets = targets;
    }

    var eventName = "onPinch" + (targets ? "Group" : "");
    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag" + (targets ? "Group" : "") + "Control";
    ables.forEach(function (able) {
      able[controlEventName](moveable, {
        clientX: clientX,
        clientY: clientY,
        datas: datas[able.name + "Datas"],
        inputEvent: inputEvent,
        parentDistance: parentDistance,
        parentRotate: parentRotate,
        pinchFlag: true
      });
    });
    return params;
  },
  pinchEnd: function (moveable, e) {
    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        isPinch = e.isPinch,
        inputEvent = e.inputEvent,
        targets = e.targets;

    if (!datas.isPinch) {
      return;
    }

    var eventName = "onPinch" + (targets ? "Group" : "") + "End";
    var params = fillParams(moveable, e, {
      isDrag: isPinch
    });

    if (targets) {
      params.targets = targets;
    }

    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag" + (targets ? "Group" : "") + "ControlEnd";
    ables.forEach(function (able) {
      able[controlEventName](moveable, {
        clientX: clientX,
        clientY: clientY,
        isDrag: isPinch,
        datas: datas[able.name + "Datas"],
        inputEvent: inputEvent,
        pinchFlag: true
      });
    });
    return isPinch;
  },
  pinchGroupStart: function (moveable, e) {
    return this.pinchStart(moveable, __assign({}, e, {
      targets: moveable.props.targets
    }));
  },
  pinchGroup: function (moveable, e) {
    return this.pinch(moveable, __assign({}, e, {
      targets: moveable.props.targets
    }));
  },
  pinchGroupEnd: function (moveable, e) {
    return this.pinchEnd(moveable, __assign({}, e, {
      targets: moveable.props.targets
    }));
  }
};

function triggerChildAble(moveable, able, type, datas, eachEvent, callback) {
  var name = able.name;
  var ableDatas = datas[name] || (datas[name] = []);
  var isEnd = !!type.match(/End$/g);
  var childs = moveable.moveables.map(function (child, i) {
    var childDatas = ableDatas[i] || (ableDatas[i] = {});
    var childEvent = utils.isFunction(eachEvent) ? eachEvent(child, childDatas) : eachEvent;
    var result = able[type](child, __assign({}, childEvent, {
      datas: childDatas,
      parentFlag: true
    }));
    result && callback && callback(child, childDatas, result, i);

    if (isEnd) {
      child.state.dragger = null;
    }

    return result;
  });
  return childs;
}
function directionCondition(target) {
  return utils.hasClass(target, prefix("direction"));
}

function setDragStart(moveable, _a) {
  var datas = _a.datas;
  var _b = moveable.state,
      matrix$1 = _b.matrix,
      beforeMatrix = _b.beforeMatrix,
      is3d = _b.is3d,
      left = _b.left,
      top = _b.top,
      origin = _b.origin,
      offsetMatrix = _b.offsetMatrix,
      targetMatrix = _b.targetMatrix,
      transformOrigin = _b.transformOrigin;
  var n = is3d ? 4 : 3;
  datas.is3d = is3d;
  datas.matrix = matrix$1;
  datas.targetMatrix = targetMatrix;
  datas.beforeMatrix = beforeMatrix;
  datas.offsetMatrix = offsetMatrix;
  datas.transformOrigin = transformOrigin;
  datas.inverseMatrix = matrix.invert(matrix$1, n);
  datas.inverseBeforeMatrix = matrix.invert(beforeMatrix, n);
  datas.absoluteOrigin = matrix.convertPositionMatrix(matrix.plus([left, top], origin), n);
  datas.startDragBeforeDist = matrix.caculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);
  datas.startDragDist = matrix.caculate(datas.inverseMatrix, datas.absoluteOrigin, n);
}
function getDragDist(_a, isBefore) {
  var datas = _a.datas,
      distX = _a.distX,
      distY = _a.distY;
  var inverseBeforeMatrix = datas.inverseBeforeMatrix,
      inverseMatrix = datas.inverseMatrix,
      is3d = datas.is3d,
      startDragBeforeDist = datas.startDragBeforeDist,
      startDragDist = datas.startDragDist,
      absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return matrix.minus(matrix.caculate(isBefore ? inverseBeforeMatrix : inverseMatrix, matrix.plus(absoluteOrigin, [distX, distY]), n), isBefore ? startDragBeforeDist : startDragDist);
}
function caculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin) {
  if (prevWidth === void 0) {
    prevWidth = width;
  }

  if (prevHeight === void 0) {
    prevHeight = height;
  }

  if (prevOrigin === void 0) {
    prevOrigin = [0, 0];
  }

  if (!transformOrigin) {
    return prevOrigin;
  }

  return transformOrigin.map(function (pos, i) {
    var _a = utils.splitUnit(pos),
        value = _a.value,
        unit = _a.unit;

    var prevSize = i ? prevHeight : prevWidth;
    var size = i ? height : width;

    if (pos === "%" || isNaN(value)) {
      // no value but %
      var measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;
      return size * measureRatio;
    } else if (unit !== "%") {
      return value;
    }

    return size * value / 100;
  });
}
function getPosIndexesByDirection(direction) {
  var indexes = [];

  if (direction[1] >= 0) {
    if (direction[0] >= 0) {
      indexes.push(3);
    }

    if (direction[0] <= 0) {
      indexes.push(2);
    }
  }

  if (direction[1] <= 0) {
    if (direction[0] >= 0) {
      indexes.push(1);
    }

    if (direction[0] <= 0) {
      indexes.push(0);
    }
  }

  return indexes;
}
function getPosesByDirection(poses, direction) {
  /*
  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)
  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)
  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)
  */
  return getPosIndexesByDirection(direction).map(function (index) {
    return poses[index];
  });
}
function getPosByDirection(poses, direction) {
  /*
  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)
  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)
  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)
  */
  var nextPoses = getPosesByDirection(poses, direction);
  return [matrix.average.apply(void 0, nextPoses.map(function (pos) {
    return pos[0];
  })), matrix.average.apply(void 0, nextPoses.map(function (pos) {
    return pos[1];
  }))];
}
function getPosByReverseDirection(_a, direction) {
  /*
  [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)
  [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)
  [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)
  */
  var pos1 = _a[0],
      pos2 = _a[1],
      pos3 = _a[2],
      pos4 = _a[3];
  return getPosByDirection([pos4, pos3, pos2, pos1], direction);
}

function getStartPos(poses, direction) {
  var startPos1 = poses[0],
      startPos2 = poses[1],
      startPos3 = poses[2],
      startPos4 = poses[3];
  return getPosByReverseDirection([startPos1, startPos2, startPos3, startPos4], direction);
}

function getDist(startPos, matrix, width, height, n, direction) {
  var poses = caculatePoses(matrix, width, height, n);
  var pos = getPosByReverseDirection(poses, direction);
  var distX = startPos[0] - pos[0];
  var distY = startPos[1] - pos[1];
  return [distX, distY];
}

function getNextMatrix(offsetMatrix, targetMatrix, origin, n) {
  return matrix.multiply(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);
}
function scaleMatrix(state, scale) {
  var transformOrigin = state.transformOrigin,
      offsetMatrix = state.offsetMatrix,
      is3d = state.is3d,
      targetMatrix = state.targetMatrix;
  var n = is3d ? 4 : 3;
  return getNextMatrix(offsetMatrix, matrix.multiply(targetMatrix, matrix.createScaleMatrix(scale, n), n), transformOrigin, n);
}
function getScaleDist(moveable, scale, direction, dragClient) {
  var state = moveable.state;
  var is3d = state.is3d,
      left = state.left,
      top = state.top,
      width = state.width,
      height = state.height;
  var n = is3d ? 4 : 3;
  var groupable = moveable.props.groupable;
  var nextMatrix = scaleMatrix(moveable.state, scale);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var startPos = dragClient ? dragClient : getStartPos(getAbsolutePosesByState(moveable.state), direction);
  var dist = getDist(startPos, nextMatrix, width, height, n, direction);
  return matrix.minus(dist, [groupLeft, groupTop]);
}
function getResizeDist(moveable, width, height, // prevWidth: number,
// prevHeight: number,
direction, fixedPosition, transformOrigin) {
  var groupable = moveable.props.groupable;
  var _a = moveable.state,
      prevOrigin = _a.transformOrigin,
      targetMatrix = _a.targetMatrix,
      offsetMatrix = _a.offsetMatrix,
      is3d = _a.is3d,
      prevWidth = _a.width,
      prevHeight = _a.height,
      left = _a.left,
      top = _a.top;
  var n = is3d ? 4 : 3;
  var nextOrigin = caculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);
  var dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);
  return matrix.minus(dist, [groupLeft, groupTop]);
}
function getStartDirection(moveable, direction) {
  var _a = moveable.props.baseDirection,
      baseDirection = _a === void 0 ? [-1, -1] : _a;
  return [direction[0] ? direction[0] : baseDirection[0] * -1, direction[1] ? direction[1] : baseDirection[1] * -1];
}
function getFixedPosition(moveable, direction) {
  return getStartPos(getAbsolutePosesByState(moveable.state), direction);
}

function snapStart(moveable) {
  var state = moveable.state;

  if (state.guidelines && state.guidelines.length) {
    return;
  }

  var _a = moveable.props,
      _b = _a.horizontalGuidelines,
      horizontalGuidelines = _b === void 0 ? [] : _b,
      _c = _a.verticalGuidelines,
      verticalGuidelines = _c === void 0 ? [] : _c,
      _d = _a.elementGuidelines,
      elementGuidelines = _d === void 0 ? [] : _d,
      bounds = _a.bounds,
      snapCenter = _a.snapCenter;

  if (!bounds && !horizontalGuidelines.length && !verticalGuidelines.length && !elementGuidelines.length) {
    return;
  }

  var _e = state.containerRect,
      containerWidth = _e.width,
      containerHeight = _e.height,
      containerTop = _e.top,
      containerLeft = _e.left,
      _f = state.clientRect,
      clientTop = _f.top,
      clientLeft = _f.left,
      targetLeft = state.left,
      targetTop = state.top;
  var distLeft = targetLeft - (clientLeft - containerLeft);
  var distTop = targetTop - (clientTop - containerTop);
  var guidelines = [];
  horizontalGuidelines.forEach(function (pos) {
    guidelines.push({
      type: "horizontal",
      pos: [0, pos],
      size: containerWidth
    });
  });
  verticalGuidelines.forEach(function (pos) {
    guidelines.push({
      type: "vertical",
      pos: [pos, 0],
      size: containerHeight
    });
  });
  elementGuidelines.forEach(function (el) {
    var rect = el.getBoundingClientRect();
    var top = rect.top,
        left = rect.left,
        width = rect.width,
        height = rect.height;
    var elementTop = top - containerTop;
    var elementBottom = elementTop + height;
    var elementLeft = left - containerLeft;
    var elementRight = elementLeft + width;
    guidelines.push({
      type: "vertical",
      element: el,
      pos: [elementLeft + distLeft, elementTop],
      size: height
    });
    guidelines.push({
      type: "vertical",
      element: el,
      pos: [elementRight + distLeft, elementTop],
      size: height
    });
    guidelines.push({
      type: "horizontal",
      element: el,
      pos: [elementLeft, elementTop + distTop],
      size: width
    });
    guidelines.push({
      type: "horizontal",
      element: el,
      pos: [elementLeft, elementBottom + distTop],
      size: width
    });

    if (snapCenter) {
      guidelines.push({
        type: "vertical",
        element: el,
        pos: [(elementLeft + elementRight) / 2 + distLeft, elementTop],
        size: height,
        center: true
      });
      guidelines.push({
        type: "horizontal",
        element: el,
        pos: [elementLeft, (elementTop + elementBottom) / 2 + distTop],
        size: width,
        center: true
      });
    }
  });
  state.guidelines = guidelines;
  state.enableSnap = true;
}

function checkBounds(moveable, verticalPoses, horizontalPoses, snapThreshold) {
  return {
    vertical: checkBound(moveable, verticalPoses, true, snapThreshold),
    horizontal: checkBound(moveable, horizontalPoses, false, snapThreshold)
  };
}

function checkBound(moveable, poses, isVertical, snapThreshold) {
  if (snapThreshold === void 0) {
    snapThreshold = 0;
  }

  var bounds = moveable.props.bounds;

  if (bounds) {
    var startPos = bounds[isVertical ? "left" : "top"];
    var endPos = bounds[isVertical ? "right" : "bottom"];
    var minPos = Math.min.apply(Math, poses);
    var maxPos = Math.max.apply(Math, poses);

    if (!utils.isUndefined(startPos) && startPos + snapThreshold > minPos) {
      return {
        isBound: true,
        offset: minPos - startPos,
        pos: startPos
      };
    }

    if (!utils.isUndefined(endPos) && endPos - snapThreshold < maxPos) {
      return {
        isBound: true,
        offset: maxPos - endPos,
        pos: endPos
      };
    }
  }

  return {
    isBound: false,
    offset: 0,
    pos: 0
  };
}

function checkSnap(guidelines, targetType, targetPoses, isSnapCenter, snapThreshold) {
  if (!guidelines) {
    return {
      isSnap: false,
      dist: -1,
      offset: 0,
      guidelines: [],
      snapPoses: []
    };
  }

  var snapGuidelines = [];
  var snapDist = Infinity;
  var snapOffset = 0;
  var isVertical = targetType === "vertical";
  var posType = isVertical ? 0 : 1;
  var snapPoses = targetPoses.filter(function (targetPos) {
    return guidelines.filter(function (guideline) {
      var type = guideline.type,
          pos = guideline.pos,
          center = guideline.center;

      if (!isSnapCenter && center || type !== targetType) {
        return false;
      }

      var offset = targetPos - pos[posType];
      var dist = Math.abs(offset);

      if (dist > snapThreshold) {
        return false;
      }

      if (snapDist > dist) {
        snapDist = dist;
        snapGuidelines = [];
      }

      if (snapDist === dist) {
        snapOffset = offset;
        snapGuidelines.push(guideline);
      }

      return true;
    }).length;
  });
  return {
    isSnap: !!snapGuidelines.length,
    dist: isFinite(snapDist) ? snapDist : -1,
    offset: snapOffset,
    guidelines: snapGuidelines,
    snapPoses: snapPoses
  };
}

function hasGuidelines(moveable, ableName) {
  var _a = moveable.props,
      snappable = _a.snappable,
      bounds = _a.bounds,
      _b = moveable.state,
      guidelines = _b.guidelines,
      enableSnap = _b.enableSnap;

  if (!snappable || !enableSnap || ableName && snappable !== true && snappable.indexOf(ableName) || !bounds && (!guidelines || !guidelines.length)) {
    return false;
  }

  return true;
}
function checkSnapPoses(moveable, posesX, posesY, isSnapCenter, customSnapThreshold) {
  var guidelines = moveable.state.guidelines;
  var snapThreshold = !utils.isUndefined(customSnapThreshold) ? customSnapThreshold : !utils.isUndefined(moveable.props.snapThreshold) ? moveable.props.snapThreshold : 5;
  return {
    vertical: checkSnap(guidelines, "vertical", posesX, isSnapCenter, snapThreshold),
    horizontal: checkSnap(guidelines, "horizontal", posesY, isSnapCenter, snapThreshold)
  };
}
function checkSnaps(moveable, rect, isCenter, customSnapThreshold) {
  var snapCenter = moveable.props.snapCenter;
  var isSnapCenter = snapCenter && isCenter;
  var verticalNames = ["left", "right"];
  var horizontalNames = ["top", "bottom"];

  if (isSnapCenter) {
    verticalNames.push("center");
    horizontalNames.push("middle");
  }

  verticalNames = verticalNames.filter(function (name) {
    return name in rect;
  });
  horizontalNames = horizontalNames.filter(function (name) {
    return name in rect;
  });
  return checkSnapPoses(moveable, verticalNames.map(function (name) {
    return rect[name];
  }), horizontalNames.map(function (name) {
    return rect[name];
  }), isSnapCenter, customSnapThreshold);
}

function checkBoundOneWayDist(moveable, pos) {
  var _a = checkBounds(moveable, [pos[0]], [pos[1]]),
      _b = _a.horizontal,
      isHorizontalBound = _b.isBound,
      horizontalBoundOffset = _b.offset,
      _c = _a.vertical,
      isVerticalBound = _c.isBound,
      verticalBoundOffset = _c.offset;

  if (isHorizontalBound || isVerticalBound) {
    var isVertical = void 0;

    if (isHorizontalBound && isVerticalBound) {
      isVertical = Math.abs(horizontalBoundOffset) < Math.abs(verticalBoundOffset);
    } else {
      isVertical = isVerticalBound;
    }

    var offset = isVertical ? verticalBoundOffset : horizontalBoundOffset;
    return {
      isVertical: isVertical,
      offset: offset,
      dist: Math.abs(offset)
    };
  }

  return;
}

function solveNextDist(pos1, pos2, offset, isVertical, isDirectionVertical, datas) {
  var sizeOffset = solveEquation(pos1, pos2, -offset, isVertical);

  if (!sizeOffset) {
    return NaN;
  }

  var _a = getDragDist({
    datas: datas,
    distX: sizeOffset[0],
    distY: sizeOffset[1]
  }),
      widthDist = _a[0],
      heightDist = _a[1];

  return isDirectionVertical ? heightDist : widthDist;
}

function getFixedPoses(matrix$1, width, height, fixedPos, direction, is3d) {
  var nextPoses = caculatePoses(matrix$1, width, height, is3d ? 4 : 3);
  var nextPos = getPosByReverseDirection(nextPoses, direction);
  return getAbsolutePoses(nextPoses, matrix.minus(fixedPos, nextPos));
}

function checkBoundOneWayPos(moveable, pos, reversePos, isDirectionVertical, datas) {
  var _a = checkSnapPoses(moveable, [pos[0]], [pos[1]]),
      _b = _a.horizontal,
      isHorizontalSnap = _b.isSnap,
      horizontalOffset = _b.offset,
      horizontalDist = _b.dist,
      _c = _a.vertical,
      isVerticalSnap = _c.isSnap,
      verticalOffset = _c.offset,
      verticalDist = _c.dist;

  var fixedHorizontal = reversePos[1] === pos[1];
  var fixedVertical = reversePos[0] === pos[0];
  var isVertical;

  if (!isHorizontalSnap && !isVerticalSnap) {
    // no snap
    return NaN;
  } else if (isHorizontalSnap && isVerticalSnap) {
    if (horizontalDist === 0 && fixedHorizontal) {
      isVertical = true;
    } else if (verticalOffset === 0 && fixedVertical) {
      isVertical = false;
    } else {
      isVertical = horizontalDist > verticalDist;
    }
  } else {
    isVertical = isVerticalSnap;
  }

  return solveNextDist(reversePos, pos, isVertical ? verticalOffset : horizontalOffset, isVertical, isDirectionVertical, datas);
}

function checkOneWayPos(moveable, poses, reversePoses, isDirectionVertical, datas) {
  var posOffset = 0;
  var boundInfo;
  var boundIndex = -1;
  var boundInfos = poses.map(function (pos) {
    return checkBoundOneWayDist(moveable, pos);
  });
  boundInfos.forEach(function (info, i) {
    if (!info) {
      return;
    }

    if (!boundInfo || boundInfo.dist < info.dist) {
      boundInfo = info;
      boundIndex = i;
    }
  });

  if (boundInfo) {
    var nextDist = solveNextDist(reversePoses[boundIndex], poses[boundIndex], boundInfo.offset, boundInfo.isVertical, isDirectionVertical, datas);

    if (!isNaN(nextDist)) {
      posOffset = nextDist;
    }
  } else {
    poses.some(function (pos, i) {
      var nextDist = checkBoundOneWayPos(moveable, pos, reversePoses[i], isDirectionVertical, datas);

      if (isNaN(nextDist)) {
        return false;
      }

      posOffset = nextDist;
      return true;
    });
  }

  return posOffset;
}
function checkOneWayDist(moveable, poses, direction, datas) {
  var directionIndex = direction[0] !== 0 ? 0 : 1;
  var isDirectionVertical = directionIndex > 0;
  var reversePoses = poses.slice().reverse();
  var directionPoses;
  var reverseDirectionPoses;

  if (moveable.props.keepRatio) {
    directionPoses = [getPosByDirection(poses, direction)];
    reverseDirectionPoses = [getPosByDirection(reversePoses, direction)];
  } else {
    directionPoses = getPosesByDirection(poses, direction);
    reverseDirectionPoses = getPosesByDirection(reversePoses, direction);
    directionPoses.push([(directionPoses[0][0] + directionPoses[1][0]) / 2, (directionPoses[0][1] + directionPoses[1][1]) / 2]);
    reverseDirectionPoses.reverse();
    reverseDirectionPoses.push([(reverseDirectionPoses[0][0] + reverseDirectionPoses[1][0]) / 2, (reverseDirectionPoses[0][1] + reverseDirectionPoses[1][1]) / 2]);
  }

  var posOffset = checkOneWayPos(moveable, directionPoses, reverseDirectionPoses, isDirectionVertical, datas);
  var offset = [0, 0];
  offset[directionIndex] = direction[directionIndex] * posOffset;
  return offset;
}
function checkTwoWayDist(moveable, poses, direction, datas, matrix, width, height, fixedPos, is3d) {
  var _a;

  var directionPoses = getPosesByDirection(poses, direction);
  var verticalDirection = [direction[0], direction[1] * -1];
  var horizontalDirection = [direction[0] * -1, direction[1]];
  var verticalPos = getPosByDirection(poses, verticalDirection);
  var horizontalPos = getPosByDirection(poses, horizontalDirection);

  var _b = checkBounds(moveable, [directionPoses[0][0]], [directionPoses[0][1]]),
      _c = _b.horizontal,
      isHorizontalBound = _c.isBound,
      horizontalBoundOffset = _c.offset,
      _d = _b.vertical,
      isVerticalBound = _d.isBound,
      verticalBoundOffset = _d.offset; // share drag event


  var widthDist = 0;
  var heightDist = 0;
  var verticalBoundInfo = checkBoundOneWayDist(moveable, verticalPos);
  var horizontalBoundInfo = checkBoundOneWayDist(moveable, horizontalPos);
  var isVeritcalDirectionBound = verticalBoundInfo && verticalBoundInfo.dist > Math.abs(verticalBoundOffset);
  var isHorizontalDirectionBound = horizontalBoundInfo && horizontalBoundInfo.dist > Math.abs(horizontalBoundOffset);

  if (!isVeritcalDirectionBound && !isHorizontalDirectionBound) {
    var _e = checkSnapPoses(moveable, [directionPoses[0][0]], [directionPoses[0][1]]),
        horizontalOffset = _e.horizontal.offset,
        verticalOffset = _e.vertical.offset;

    _a = getDragDist({
      datas: datas,
      distX: -(isVerticalBound ? verticalBoundOffset : verticalOffset),
      distY: -(isHorizontalBound ? horizontalBoundOffset : horizontalOffset)
    }), widthDist = _a[0], heightDist = _a[1];
  } else if (isVeritcalDirectionBound) {
    // left to right, right to left
    var reversePos = getPosByDirection(poses, [verticalDirection[0] * -1, verticalDirection[1]]);
    var nextDist = solveNextDist(reversePos, verticalPos, verticalBoundInfo.offset, verticalBoundInfo.isVertical, false, datas);

    if (!isNaN(nextDist)) {
      widthDist = nextDist;
    }

    var nextPoses = getFixedPoses(matrix, width + direction[0] * widthDist, height + direction[1] * heightDist, fixedPos, direction, is3d);
    heightDist = checkOneWayPos(moveable, [getPosByDirection(nextPoses, direction)], [getPosByDirection(nextPoses, verticalDirection)], true, datas);
  } else {
    // top to bottom, bottom to top
    var reversePos = getPosByDirection(poses, [horizontalDirection[0] * -1, horizontalDirection[1]]);
    var nextDist = solveNextDist(reversePos, verticalPos, horizontalBoundInfo.offset, horizontalBoundInfo.isVertical, true, datas);

    if (!isNaN(nextDist)) {
      heightDist = nextDist;
    }

    var nextPoses = getFixedPoses(matrix, width + direction[0] * widthDist, height + direction[1] * heightDist, fixedPos, direction, is3d);
    widthDist = checkOneWayPos(moveable, [getPosByDirection(nextPoses, direction)], [getPosByDirection(nextPoses, horizontalDirection)], false, datas);
  }

  return [direction[0] * widthDist, direction[1] * heightDist];
}
function checkSizeDist(moveable, matrix, width, height, direction, snapDirection, datas, is3d) {
  var poses = getAbsolutePosesByState(moveable.state);
  var fixedPos = getPosByReverseDirection(poses, snapDirection);
  var nextPoses = getFixedPoses(matrix, width, height, fixedPos, direction, is3d);

  if (direction[0] && direction[1]) {
    return checkTwoWayDist(moveable, nextPoses, direction, datas, matrix, width, height, fixedPos, is3d);
  } else {
    return checkOneWayDist(moveable, nextPoses, direction, datas);
  }
}
function checkSnapSize(moveable, width, height, direction, datas) {
  if (!hasGuidelines(moveable, "resizable")) {
    return [0, 0];
  }

  var _a = moveable.state,
      matrix = _a.matrix,
      is3d = _a.is3d;
  return checkSizeDist(moveable, matrix, width, height, direction, direction, datas, is3d);
}
function checkSnapScale(moveable, scale, direction, snapDirection, datas) {
  var width = datas.width,
      height = datas.height;

  if (!hasGuidelines(moveable, "scalable")) {
    return [0, 0];
  }

  var sizeDist = checkSizeDist(moveable, scaleMatrix(datas, scale), width, height, direction, snapDirection, datas, datas.is3d);
  return [sizeDist[0] / width, sizeDist[1] / height];
}
function solveEquation(pos1, pos2, snapOffset, isVertical) {
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];

  if (!dx) {
    // y = 0 * x + b
    // only horizontal
    if (!isVertical) {
      return [0, snapOffset];
    }

    return;
  }

  if (!dy) {
    // only vertical
    if (isVertical) {
      return [snapOffset, 0];
    }

    return;
  } // y = ax + b


  var a = dy / dx;
  var b = pos1[1] - a * pos1[0];

  if (isVertical) {
    // y = a * x + b
    var y = a * (pos2[0] + snapOffset) + b;
    return [snapOffset, y - pos2[1]];
  } else {
    // x = (y - b) / a
    var x = (pos2[1] + snapOffset - b) / a;
    return [x - pos2[0], snapOffset];
  }
}
function getSnapInfosByDirection(moveable, poses, snapDirection) {
  if (snapDirection === true) {
    var rect = getRect(poses);
    rect.middle = (rect.top + rect.bottom) / 2;
    rect.center = (rect.left + rect.right) / 2;
    return checkSnaps(moveable, rect, true, 1);
  } else if (!snapDirection[0] && !snapDirection[1]) {
    var alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];
    var nextPoses = [];

    for (var i = 0; i < 4; ++i) {
      nextPoses.push(alignPoses[i]);
      poses.push([(alignPoses[i][0] + alignPoses[i + 1][0]) / 2, (alignPoses[i][1] + alignPoses[i + 1][1]) / 2]);
    }

    return checkSnapPoses(moveable, nextPoses.map(function (pos) {
      return pos[0];
    }), nextPoses.map(function (pos) {
      return pos[1];
    }), true, 1);
  } else {
    var nextPoses = void 0;

    if (moveable.props.keepRatio) {
      nextPoses = [getPosByDirection(poses, snapDirection)];
    } else {
      nextPoses = getPosesByDirection(poses, snapDirection);

      if (nextPoses.length > 1) {
        nextPoses.push([(nextPoses[0][0] + nextPoses[1][0]) / 2, (nextPoses[0][1] + nextPoses[1][1]) / 2]);
      }
    }

    return checkSnapPoses(moveable, nextPoses.map(function (pos) {
      return pos[0];
    }), nextPoses.map(function (pos) {
      return pos[1];
    }), true, 1);
  }
}
function startCheckSnapDrag(moveable, datas) {
  datas.absolutePoses = getAbsolutePosesByState(moveable.state);
}
function checkSnapDrag(moveable, distX, distY, datas) {
  var snapVerticalInfo = {
    isSnap: false,
    offset: 0
  };
  var snapHorizontalInfo = {
    isSnap: false,
    offset: 0
  };

  if (!hasGuidelines(moveable, "draggable")) {
    return [snapVerticalInfo, snapHorizontalInfo];
  }

  var poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);

  var _a = getRect(poses),
      left = _a.left,
      right = _a.right,
      top = _a.top,
      bottom = _a.bottom;

  var snapInfos = checkSnaps(moveable, {
    left: left,
    right: right,
    top: top,
    bottom: bottom,
    center: (left + right) / 2,
    middle: (top + bottom) / 2
  }, true);
  var boundInfos = checkBounds(moveable, [left, right], [top, bottom]);

  if (boundInfos.vertical.isBound) {
    snapVerticalInfo.offset = boundInfos.vertical.offset;
    snapVerticalInfo.isSnap = true;
  } else if (snapInfos.vertical.isSnap) {
    // has vertical guidelines
    snapVerticalInfo.offset = snapInfos.vertical.offset;
    snapVerticalInfo.isSnap = true;
  }

  if (boundInfos.horizontal.isBound) {
    snapHorizontalInfo.offset = boundInfos.horizontal.offset;
    snapHorizontalInfo.isSnap = true;
  } else if (snapInfos.horizontal.isSnap) {
    // has horizontal guidelines
    snapHorizontalInfo.offset = snapInfos.horizontal.offset;
    snapHorizontalInfo.isSnap = true;
  }

  return [snapVerticalInfo, snapHorizontalInfo];
}
var Snappable = {
  name: "snappable",
  render: function (moveable, React) {
    var _a = moveable.state,
        targetTop = _a.top,
        targetLeft = _a.left,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos3 = _a.pos3,
        pos4 = _a.pos4,
        snapDirection = _a.snapDirection,
        clientRect = _a.clientRect,
        containerRect = _a.containerRect;
    var clientLeft = clientRect.left - containerRect.left;
    var clientTop = clientRect.top - containerRect.top;
    var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);
    var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);

    if (!snapDirection || !hasGuidelines(moveable, "")) {
      return [];
    }

    var poses = getAbsolutePosesByState(moveable.state);

    var _b = getRect(poses),
        width = _b.width,
        height = _b.height,
        top = _b.top,
        left = _b.left,
        bottom = _b.bottom,
        right = _b.right;

    var _c = getSnapInfosByDirection(moveable, poses, snapDirection),
        _d = _c.vertical,
        verticalGuildelines = _d.guidelines,
        verticalSnapPoses = _d.snapPoses,
        _e = _c.horizontal,
        horizontalGuidelines = _e.guidelines,
        horizontalSnapPoses = _e.snapPoses;

    var _f = checkBounds(moveable, [left, right], [top, bottom], 1),
        _g = _f.vertical,
        isVerticalBound = _g.isBound,
        verticalBoundPos = _g.pos,
        _h = _f.horizontal,
        isHorizontalBound = _h.isBound,
        horizontalBoundPos = _h.pos;

    if (isVerticalBound && verticalSnapPoses.indexOf(verticalBoundPos) < 0) {
      // verticalGuildelines.push({
      //     type: "vertical",
      //     pos: [verticalBoundPos, top],
      //     size: height,
      // });
      verticalSnapPoses.push(verticalBoundPos);
    }

    if (isHorizontalBound && horizontalSnapPoses.indexOf(horizontalBoundPos) < 0) {
      // horizontalGuidelines.push({
      //     type: "horizontal",
      //     pos: [left, horizontalBoundPos],
      //     size: width,
      // });
      horizontalSnapPoses.push(horizontalBoundPos);
    }

    return verticalSnapPoses.map(function (pos, i) {
      return React.createElement("div", {
        className: prefix("line", "vertical", "guideline", "target", "bold"),
        key: "verticalTargetGuidline" + i,
        style: {
          top: minTop + "px",
          left: -targetLeft + pos + "px",
          height: height + "px"
        }
      });
    }).concat(horizontalSnapPoses.map(function (pos, i) {
      return React.createElement("div", {
        className: prefix("line", "horizontal", "guideline", "target", "bold"),
        key: "horizontalTargetGuidline" + i,
        style: {
          top: -targetTop + pos + "px",
          left: minLeft + "px",
          width: width + "px"
        }
      });
    }), verticalGuildelines.map(function (guideline, i) {
      var pos = guideline.pos,
          size = guideline.size,
          element = guideline.element;
      return React.createElement("div", {
        className: prefix("line", "vertical", "guideline", element ? "bold" : ""),
        key: "verticalGuidline" + i,
        style: {
          top: minTop - clientTop + pos[1] + "px",
          left: -targetLeft + pos[0] + "px",
          height: size + "px"
        }
      });
    }), horizontalGuidelines.map(function (guideline, i) {
      var pos = guideline.pos,
          size = guideline.size,
          element = guideline.element;
      return React.createElement("div", {
        className: prefix("line", "horizontal", "guideline", element ? "bold" : ""),
        key: "horizontalGuidline" + i,
        style: {
          top: -targetTop + pos[1] + "px",
          left: minLeft - clientLeft + pos[0] + "px",
          width: size + "px"
        }
      });
    }));
  },
  dragStart: function (moveable, e) {
    moveable.state.snapDirection = true;
    snapStart(moveable);
  },
  pinchStart: function (moveable) {
    this.unset(moveable);
  },
  dragEnd: function (moveable) {
    this.unset(moveable);
  },
  dragControlCondition: directionCondition,
  dragControlStart: function (moveable, e) {
    moveable.state.snapDirection = null;
    snapStart(moveable);
  },
  dragControlEnd: function (moveable) {
    this.unset(moveable);
  },
  dragGroupStart: function (moveable, e) {
    moveable.state.snapDirection = true;
    snapStart(moveable);
  },
  dragGroupEnd: function (moveable) {
    this.unset(moveable);
  },
  dragGroupControlStart: function (moveable, e) {
    moveable.state.snapDirection = null;
    snapStart(moveable);
  },
  dragGroupControlEnd: function (moveable) {
    this.unset(moveable);
  },
  unset: function (moveable) {
    var state = moveable.state;
    state.enableSnap = false;
    state.guidelines = [];
    state.snapDirection = null;
  }
};

var Draggable = {
  name: "draggable",
  dragStart: function (moveable, e) {
    var datas = e.datas,
        parentEvent = e.parentEvent,
        parentDragger = e.parentDragger;
    var state = moveable.state;
    var targetTransform = state.targetTransform,
        target = state.target,
        dragger = state.dragger;

    if (dragger) {
      return false;
    }

    state.dragger = parentDragger || moveable.targetDragger;
    var style = window.getComputedStyle(target);
    datas.datas = {};
    datas.left = parseFloat(style.left || "") || 0;
    datas.top = parseFloat(style.top || "") || 0;
    datas.bottom = parseFloat(style.bottom || "") || 0;
    datas.right = parseFloat(style.right || "") || 0;
    datas.transform = targetTransform;
    datas.startTranslate = [0, 0];
    setDragStart(moveable, {
      datas: datas
    });
    datas.prevDist = [0, 0];
    datas.prevBeforeDist = [0, 0];
    datas.isDrag = false;
    startCheckSnapDrag(moveable, datas);
    var params = fillParams(moveable, e, {
      set: function (translate) {
        datas.startTranslate = translate;
      }
    });
    var result = parentEvent || triggerEvent(moveable, "onDragStart", params);

    if (result !== false) {
      datas.isDrag = true;
    } else {
      state.dragger = null;
      datas.isPinch = false;
    }

    return datas.isDrag ? params : false;
  },
  drag: function (moveable, e) {
    var datas = e.datas,
        parentEvent = e.parentEvent,
        parentFlag = e.parentFlag;
    var distX = e.distX,
        distY = e.distY;
    var isPinch = datas.isPinch,
        isDrag = datas.isDrag,
        prevDist = datas.prevDist,
        prevBeforeDist = datas.prevBeforeDist,
        transform = datas.transform,
        startTranslate = datas.startTranslate;

    if (!isDrag) {
      return;
    }

    var props = moveable.props;
    var parentMoveable = props.parentMoveable;
    var throttleDrag = parentEvent ? 0 : props.throttleDrag || 0;
    var isSnap = false;

    if (!isPinch && !parentEvent && !parentFlag) {
      var _a = checkSnapDrag(moveable, distX, distY, datas),
          verticalInfo = _a[0],
          horizontalInfo = _a[1];

      isSnap = verticalInfo.isSnap || horizontalInfo.isSnap;
      distX -= verticalInfo.offset;
      distY -= horizontalInfo.offset;
    }

    datas.passDistX = distX;
    datas.passDistY = distY;
    var beforeTranslate = matrix.plus(getDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    }, true), startTranslate);
    var translate = matrix.plus(getDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    }, false), startTranslate);

    if (!isSnap) {
      throttleArray(translate, throttleDrag);
      throttleArray(beforeTranslate, throttleDrag);
    }

    var beforeDist = matrix.minus(beforeTranslate, startTranslate);
    var dist = matrix.minus(translate, startTranslate);
    var delta = matrix.minus(dist, prevDist);
    var beforeDelta = matrix.minus(beforeDist, prevBeforeDist);
    datas.prevDist = dist;
    datas.prevBeforeDist = beforeDist;
    var left = datas.left + beforeDist[0];
    var top = datas.top + beforeDist[1];
    var right = datas.right - beforeDist[0];
    var bottom = datas.bottom - beforeDist[1];
    var nextTransform = transform + " translate(" + dist[0] + "px, " + dist[1] + "px)";

    if (!parentEvent && !parentMoveable && delta.every(function (num) {
      return !num;
    }) && beforeDelta.some(function (num) {
      return !num;
    })) {
      return;
    }

    var params = fillParams(moveable, e, {
      transform: nextTransform,
      dist: dist,
      delta: delta,
      translate: translate,
      beforeDist: beforeDist,
      beforeDelta: beforeDelta,
      beforeTranslate: beforeTranslate,
      left: left,
      top: top,
      right: right,
      bottom: bottom,
      isPinch: isPinch
    });
    !parentEvent && triggerEvent(moveable, "onDrag", params);
    return params;
  },
  dragEnd: function (moveable, e) {
    var parentEvent = e.parentEvent,
        datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isDrag) {
      return;
    }

    moveable.state.dragger = null;
    datas.isDrag = false;
    !parentEvent && triggerEvent(moveable, "onDragEnd", fillParams(moveable, e, {
      isDrag: isDrag
    }));
    return isDrag;
  },
  dragGroupStart: function (moveable, e) {
    var datas = e.datas;
    var params = this.dragStart(moveable, e);

    if (!params) {
      return false;
    }

    var events = triggerChildAble(moveable, this, "dragStart", datas, e);

    var nextParams = __assign({}, params, {
      targets: moveable.props.targets,
      events: events
    });

    var result = triggerEvent(moveable, "onDragGroupStart", nextParams);
    datas.isDrag = result !== false;
    return datas.isDrag ? params : false;
  },
  dragGroup: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isDrag) {
      return;
    }

    var params = this.drag(moveable, e);
    var _a = e.datas,
        passDistX = _a.passDistX,
        passDistY = _a.passDistY;
    var events = triggerChildAble(moveable, this, "drag", datas, __assign({}, e, {
      distX: passDistX,
      distY: passDistY
    }));

    if (!params) {
      return;
    }

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onDragGroup", nextParams);
    return nextParams;
  },
  dragGroupEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isDrag) {
      return;
    }

    this.dragEnd(moveable, e);
    triggerChildAble(moveable, this, "dragEnd", datas, e);
    triggerEvent(moveable, "onDragGroupEnd", fillParams(moveable, e, {
      targets: moveable.props.targets,
      isDrag: isDrag
    }));
    return isDrag;
  }
};

function setCustomDrag(state, delta, inputEvent) {
  return __assign({}, state.dragger.move(delta, inputEvent), {
    parentEvent: true
  });
}

var CustomDragger =
/*#__PURE__*/
function () {
  function CustomDragger() {
    this.prevX = 0;
    this.prevY = 0;
    this.startX = 0;
    this.startY = 0;
    this.isDrag = false;
    this.isFlag = false;
    this.datas = {};
  }

  var __proto = CustomDragger.prototype;

  __proto.dragStart = function (client, inputEvent) {
    this.isDrag = false;
    this.isFlag = false;
    this.datas = {};
    return this.move(client, inputEvent);
  };

  __proto.drag = function (client, inputEvent) {
    return this.move([client[0] - this.prevX, client[1] - this.prevY], inputEvent);
  };

  __proto.move = function (delta, inputEvent) {
    var clientX;
    var clientY;

    if (!this.isFlag) {
      this.prevX = delta[0];
      this.prevY = delta[1];
      this.startX = delta[0];
      this.startY = delta[1];
      clientX = delta[0];
      clientY = delta[1];
      this.isFlag = true;
    } else {
      clientX = this.prevX + delta[0];
      clientY = this.prevY + delta[1];
      this.isDrag = true;
    }

    this.prevX = clientX;
    this.prevY = clientY;
    return {
      clientX: clientX,
      clientY: clientY,
      inputEvent: inputEvent,
      isDrag: this.isDrag,
      distX: clientX - this.startX,
      distY: clientY - this.startY,
      deltaX: delta[0],
      deltaY: delta[1],
      datas: this.datas,
      parentEvent: true,
      parentDragger: this
    };
  };

  return CustomDragger;
}();

function setRotateStartInfo(datas, clientX, clientY, origin, rotationPos) {
  datas.startAbsoluteOrigin = [clientX - rotationPos[0] + origin[0], clientY - rotationPos[1] + origin[1]];
  datas.prevDeg = matrix.getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;
  datas.startDeg = datas.prevDeg;
  datas.loop = 0;
}

function getDeg(datas, deg, direction, startRotate, throttleRotate) {
  var prevDeg = datas.prevDeg,
      startDeg = datas.startDeg,
      prevLoop = datas.loop;

  if (prevDeg > deg && prevDeg > 270 && deg < 90) {
    // 360 => 0
    ++datas.loop;
  } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {
    // 0 => 360
    --datas.loop;
  }

  var loop = datas.loop;
  var absolutePrevDeg = prevLoop * 360 + prevDeg - startDeg + startRotate;
  var absoluteDeg = loop * 360 + deg - startDeg + startRotate;
  absoluteDeg = throttle(absoluteDeg, throttleRotate);
  var delta = direction * (absoluteDeg - absolutePrevDeg);
  var dist = direction * (absoluteDeg - startRotate);
  datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startRotate;
  return [delta, dist, absoluteDeg];
}

function getRotateInfo(datas, direction, clientX, clientY, startRotate, throttleRotate) {
  return getDeg(datas, matrix.getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180, direction, startRotate, throttleRotate);
}

function getPositions(rotationPosition, pos1, pos2, pos3, pos4) {
  if (rotationPosition === "left") {
    return [pos3, pos1];
  } else if (rotationPosition === "right") {
    return [pos2, pos4];
  } else if (rotationPosition === "bottom") {
    return [pos4, pos3];
  }

  return [pos1, pos2];
}
function getRotationPosition(_a, rad) {
  var pos1 = _a[0],
      pos2 = _a[1];
  var relativeRotationPos = matrix.rotate([0, -40, 1], rad);
  var rotationPos = [(pos1[0] + pos2[0]) / 2 + relativeRotationPos[0], (pos1[1] + pos2[1]) / 2 + relativeRotationPos[1]];
  return rotationPos;
}

function dragControlCondition(target) {
  return utils.hasClass(target, prefix("rotation"));
}

var Rotatable = {
  name: "rotatable",
  canPinch: true,
  render: function (moveable, React) {
    var _a = moveable.props,
        rotatable = _a.rotatable,
        rotationPosition = _a.rotationPosition;

    if (!rotatable) {
      return null;
    }

    var _b = moveable.state,
        pos1 = _b.pos1,
        pos2 = _b.pos2,
        pos3 = _b.pos3,
        pos4 = _b.pos4,
        direction = _b.direction;
    var poses = getPositions(rotationPosition, pos1, pos2, pos3, pos4);
    var rotationRad = getRotationRad(poses, direction);
    return React.createElement("div", {
      key: "rotation",
      className: prefix("line rotation-line"),
      style: {
        // tslint:disable-next-line: max-line-length
        transform: "translate(" + (poses[0][0] + poses[1][0]) / 2 + "px, " + (poses[0][1] + poses[1][1]) / 2 + "px) translateY(-40px) rotate(" + rotationRad + "rad)"
      }
    }, React.createElement("div", {
      className: prefix("control", "rotation")
    }));
  },
  dragControlCondition: dragControlCondition,
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        parentRotate = e.parentRotate,
        parentFlag = e.parentFlag,
        pinchFlag = e.pinchFlag;
    var _a = moveable.state,
        target = _a.target,
        left = _a.left,
        top = _a.top,
        origin = _a.origin,
        beforeOrigin = _a.beforeOrigin,
        direction = _a.direction,
        beforeDirection = _a.beforeDirection,
        targetTransform = _a.targetTransform,
        pos1 = _a.pos1,
        pos2 = _a.pos2,
        pos3 = _a.pos3,
        pos4 = _a.pos4;

    if (!target) {
      return false;
    }

    datas.transform = targetTransform;
    datas.left = left;
    datas.top = top;
    var poses = getPositions(moveable.props.rotationPosition, pos1, pos2, pos3, pos4);
    var rotationPos = getRotationPosition(poses, getRotationRad(poses, direction));

    if (pinchFlag || parentFlag) {
      datas.beforeInfo = {
        prevDeg: parentRotate,
        startDeg: parentRotate,
        loop: 0
      };
      datas.afterInfo = {
        prevDeg: parentRotate,
        startDeg: parentRotate,
        loop: 0
      };
    } else {
      datas.afterInfo = {};
      datas.beforeInfo = {};
      setRotateStartInfo(datas.afterInfo, clientX, clientY, origin, rotationPos);
      setRotateStartInfo(datas.beforeInfo, clientX, clientY, beforeOrigin, rotationPos);
    }

    datas.direction = direction;
    datas.beforeDirection = beforeDirection;
    datas.startRotate = 0;
    datas.datas = {};
    var params = fillParams(moveable, e, {
      set: function (rotatation) {
        datas.startRotate = rotatation;
      }
    });
    var result = triggerEvent(moveable, "onRotateStart", params);
    datas.isRotate = result !== false;
    return datas.isRotate ? params : false;
  },
  dragControl: function (moveable, e) {
    var _a, _b, _c, _d;

    var datas = e.datas,
        clientX = e.clientX,
        clientY = e.clientY,
        parentRotate = e.parentRotate,
        parentFlag = e.parentFlag,
        pinchFlag = e.pinchFlag;
    var direction = datas.direction,
        beforeDirection = datas.beforeDirection,
        beforeInfo = datas.beforeInfo,
        afterInfo = datas.afterInfo,
        isRotate = datas.isRotate,
        startRotate = datas.startRotate;

    if (!isRotate) {
      return;
    }

    var _e = moveable.props,
        _f = _e.throttleRotate,
        throttleRotate = _f === void 0 ? 0 : _f,
        parentMoveable = _e.parentMoveable;
    var delta;
    var dist;
    var rotate;
    var beforeDelta;
    var beforeDist;
    var beforeRotate;

    if (pinchFlag || parentFlag) {
      _a = getDeg(afterInfo, parentRotate, direction, startRotate, throttleRotate), delta = _a[0], dist = _a[1], rotate = _a[2];
      _b = getDeg(beforeInfo, parentRotate, direction, startRotate, throttleRotate), beforeDelta = _b[0], beforeDist = _b[1], beforeRotate = _b[2];
    } else {
      _c = getRotateInfo(afterInfo, direction, clientX, clientY, startRotate, throttleRotate), delta = _c[0], dist = _c[1], rotate = _c[2];
      _d = getRotateInfo(beforeInfo, beforeDirection, clientX, clientY, startRotate, throttleRotate), beforeDelta = _d[0], beforeDist = _d[1], beforeRotate = _d[2];
    }

    if (!delta && !beforeDelta && !parentMoveable) {
      return;
    }

    var params = fillParams(moveable, e, {
      delta: delta,
      dist: dist,
      rotate: rotate,
      beforeDist: beforeDist,
      beforeDelta: beforeDelta,
      beforeRotate: beforeRotate,
      transform: datas.transform + " rotate(" + dist + "deg)",
      isPinch: !!pinchFlag
    });
    triggerEvent(moveable, "onRotate", params);
    return params;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isRotate) {
      return false;
    }

    datas.isRotate = false;
    triggerEvent(moveable, "onRotateEnd", fillParams(moveable, e, {
      isDrag: isDrag
    }));
    return isDrag;
  },
  dragGroupControlCondition: dragControlCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas,
        inputEvent = e.inputEvent;
    var _a = moveable.state,
        parentLeft = _a.left,
        parentTop = _a.top,
        parentBeforeOrigin = _a.beforeOrigin;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    var events = triggerChildAble(moveable, this, "dragControlStart", datas, __assign({}, e, {
      parentRotate: 0
    }), function (child, childDatas, eventParams) {
      var _a = child.state,
          left = _a.left,
          top = _a.top,
          beforeOrigin = _a.beforeOrigin;
      var childClient = matrix.plus(matrix.minus([left, top], [parentLeft, parentTop]), matrix.minus(beforeOrigin, parentBeforeOrigin));
      childDatas.prevClient = childClient;
      eventParams.dragStart = Draggable.dragStart(child, new CustomDragger().dragStart(childClient, inputEvent));
    });

    var nextParams = __assign({}, params, {
      targets: moveable.props.targets,
      events: events
    });

    var result = triggerEvent(moveable, "onRotateGroupStart", nextParams);
    datas.isRotate = result !== false;
    return datas.isDrag ? params : false;
  },
  dragGroupControl: function (moveable, e) {
    var inputEvent = e.inputEvent,
        datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var parentRotate = params.beforeDist;
    var deg = params.beforeDelta;
    var rad = deg / 180 * Math.PI;
    var events = triggerChildAble(moveable, this, "dragControl", datas, __assign({}, e, {
      parentRotate: parentRotate
    }), function (child, childDatas, result, i) {
      var _a = childDatas.prevClient,
          prevX = _a[0],
          prevY = _a[1];

      var _b = matrix.rotate([prevX, prevY], rad),
          clientX = _b[0],
          clientY = _b[1];

      var delta = [clientX - prevX, clientY - prevY];
      childDatas.prevClient = [clientX, clientY];
      var dragResult = Draggable.drag(child, setCustomDrag(child.state, delta, inputEvent));
      result.drag = dragResult;
    });

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    moveable.rotation += params.beforeDelta;
    triggerEvent(moveable, "onRotateGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isRotate) {
      return;
    }

    this.dragControlEnd(moveable, e);
    triggerChildAble(moveable, this, "dragControlEnd", datas, e);
    var nextParams = fillParams(moveable, e, {
      targets: moveable.props.targets,
      isDrag: isDrag
    });
    triggerEvent(moveable, "onRotateGroupEnd", nextParams);
    return isDrag;
  }
};

function renderControls(moveable, defaultDirections, React) {
  var _a = moveable.state,
      pos1 = _a.pos1,
      pos2 = _a.pos2,
      pos3 = _a.pos3,
      pos4 = _a.pos4,
      rotation = _a.rotation;
  var _b = moveable.props.renderDirections,
      directions = _b === void 0 ? defaultDirections : _b;
  var poses = [pos1, pos2, pos3, pos4];
  var directionMap = {};
  directions.forEach(function (direction) {
    directionMap[direction] = true;
  });
  return directions.map(function (direction) {
    var indexes = DIRECTION_INDEXES[direction];

    if (!indexes || !directionMap[direction]) {
      return null;
    }

    return React.createElement("div", {
      className: prefix("control", "direction", direction),
      "data-direction": direction,
      key: direction,
      style: getControlTransform.apply(void 0, [rotation].concat(indexes.map(function (index) {
        return poses[index];
      })))
    });
  });
}
function renderAllDirections(moveable, React) {
  return renderControls(moveable, ["nw", "ne", "sw", "se", "n", "w", "s", "e"], React);
}
function renderDiagonalDirections(moveable, React) {
  return renderControls(moveable, ["nw", "ne", "sw", "se"], React);
}

var Resizable = {
  name: "resizable",
  ableGroup: "size",
  updateRect: true,
  canPinch: true,
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        edge = _a.edge;

    if (resizable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }

      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function (moveable, e) {
    var _a;

    var inputEvent = e.inputEvent,
        pinchFlag = e.pinchFlag,
        datas = e.datas;
    var inputTarget = inputEvent.target;
    var direction = pinchFlag ? [1, 1] : getDirection(inputTarget);
    var _b = moveable.state,
        target = _b.target,
        width = _b.width,
        height = _b.height;

    if (!direction || !target) {
      return false;
    }

    !pinchFlag && setDragStart(moveable, {
      datas: datas
    });
    datas.datas = {};
    datas.direction = direction;
    datas.startOffsetWidth = width;
    datas.startOffsetHeight = height;
    datas.prevWidth = 0;
    datas.prevHeight = 0;
    _a = getCSSSize(target), datas.startWidth = _a[0], datas.startHeight = _a[1];
    datas.transformOrigin = moveable.props.transformOrigin;
    datas.startDirection = getStartDirection(moveable, direction);
    datas.fixedPosition = getFixedPosition(moveable, datas.startDirection);
    datas.fixedOriginalPosition = getFixedPosition(moveable, direction);
    var params = fillParams(moveable, e, {
      direction: direction,
      set: function (_a) {
        var startWidth = _a[0],
            startHeight = _a[1];
        datas.startWidth = startWidth;
        datas.startHeight = startHeight;
      },
      setOrigin: function (origin) {
        datas.transformOrigin = origin;
      },
      dragStart: Draggable.dragStart(moveable, new CustomDragger().dragStart([0, 0], inputEvent))
    });
    var result = triggerEvent(moveable, "onResizeStart", params);

    if (result !== false) {
      datas.isResize = true;
      moveable.state.snapDirection = direction;
    }

    return datas.isResize ? params : false;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas,
        distX = e.distX,
        distY = e.distY,
        parentFlag = e.parentFlag,
        pinchFlag = e.pinchFlag,
        parentDistance = e.parentDistance,
        parentScale = e.parentScale,
        inputEvent = e.inputEvent,
        dragClient = e.dragClient;
    var direction = datas.direction,
        isResize = datas.isResize,
        transformOrigin = datas.transformOrigin;

    if (!isResize) {
      return;
    }

    var startWidth = datas.startWidth,
        startHeight = datas.startHeight,
        startOffsetWidth = datas.startOffsetWidth,
        startOffsetHeight = datas.startOffsetHeight,
        prevWidth = datas.prevWidth,
        prevHeight = datas.prevHeight;
    var _a = moveable.props,
        _b = _a.throttleResize,
        throttleResize = _b === void 0 ? 0 : _b,
        parentMoveable = _a.parentMoveable;
    var keepRatio = moveable.props.keepRatio || parentScale;
    var isWidth = direction[0] || !direction[1];
    var ratio = isWidth ? startOffsetHeight / startOffsetWidth : startOffsetWidth / startOffsetHeight;
    var distWidth = 0;
    var distHeight = 0;

    if (parentScale) {
      distWidth = (parentScale[0] - 1) * startOffsetWidth;
      distHeight = (parentScale[1] - 1) * startOffsetHeight;
    } else if (pinchFlag) {
      if (parentDistance) {
        distWidth = parentDistance;
        distHeight = parentDistance * startOffsetHeight / startOffsetWidth;
      }
    } else {
      var dist = getDragDist({
        datas: datas,
        distX: distX,
        distY: distY
      });
      distWidth = direction[0] * dist[0];
      distHeight = direction[1] * dist[1];

      if (keepRatio && startOffsetWidth && startOffsetHeight) {
        var rad = matrix.getRad([0, 0], dist);
        var standardRad = matrix.getRad([0, 0], direction);
        var ratioRad = matrix.getRad([0, 0], [startOffsetWidth, startOffsetHeight]);
        var size = Math.sqrt(distWidth * distWidth + distHeight * distHeight);
        var signSize = Math.cos(rad - standardRad) * size;

        if (!direction[0]) {
          // top, bottom
          distHeight = signSize;
          distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);
        } else if (!direction[1]) {
          // left, right
          distWidth = signSize;
          distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);
        } else {
          // two-way
          distWidth = Math.cos(ratioRad) * signSize;
          distHeight = Math.sin(ratioRad) * signSize;
        }
      }
    }

    var nextWidth = direction[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, 0) : startOffsetWidth;
    var nextHeight = direction[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, 0) : startOffsetHeight;
    var snapDist = [0, 0];

    if (!pinchFlag) {
      snapDist = checkSnapSize(moveable, nextWidth, nextHeight, direction, datas);
    }

    if (keepRatio) {
      if (direction[0] && direction[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }

      var isNoSnap = !snapDist[0] && !snapDist[1];

      if (isNoSnap) {
        if (isWidth) {
          nextWidth = throttle(nextWidth, throttleResize);
        } else {
          nextHeight = throttle(nextHeight, throttleResize);
        }
      }

      if (direction[0] && !direction[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        nextWidth += snapDist[0];
        nextHeight = getKeepRatioHeight(nextWidth, isWidth, ratio);
      } else if (!direction[0] && direction[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        nextHeight += snapDist[1];
        nextWidth = getKeepRatioWidth(nextHeight, isWidth, ratio);
      }
    } else {
      nextWidth += snapDist[0];
      nextHeight += snapDist[1];

      if (!snapDist[0]) {
        nextWidth = throttle(nextWidth, throttleResize);
      }

      if (!snapDist[1]) {
        nextHeight = throttle(nextHeight, throttleResize);
      }
    }

    nextWidth = Math.round(nextWidth);
    nextHeight = Math.round(nextHeight);
    distWidth = nextWidth - startOffsetWidth;
    distHeight = nextHeight - startOffsetHeight;
    var delta = [distWidth - prevWidth, distHeight - prevHeight];
    datas.prevWidth = distWidth;
    datas.prevHeight = distHeight;

    if (!parentMoveable && delta.every(function (num) {
      return !num;
    })) {
      return;
    }

    var startDirection = keepRatio || parentFlag ? direction : datas.startDirection;
    var fixedPosition = dragClient || (keepRatio ? datas.fixedOriginalPosition : datas.fixedPosition);
    var inverseDelta = !parentFlag && pinchFlag ? [0, 0] : getResizeDist(moveable, nextWidth, nextHeight, startDirection, fixedPosition, transformOrigin);
    var params = fillParams(moveable, e, {
      width: startWidth + distWidth,
      height: startHeight + distHeight,
      offsetWidth: nextWidth,
      offsetHeight: nextHeight,
      direction: direction,
      dist: [distWidth, distHeight],
      delta: delta,
      isPinch: !!pinchFlag,
      drag: Draggable.drag(moveable, setCustomDrag(moveable.state, inverseDelta, inputEvent))
    });
    triggerEvent(moveable, "onResize", params);
    return params;
  },
  dragControlAfter: function (moveable, e) {
    var datas = e.datas;
    var isResize = datas.isResize,
        startOffsetWidth = datas.startOffsetWidth,
        startOffsetHeight = datas.startOffsetHeight,
        prevWidth = datas.prevWidth,
        prevHeight = datas.prevHeight;

    if (!isResize) {
      return;
    }

    var _a = moveable.state,
        width = _a.width,
        height = _a.height;
    var errorWidth = width - (startOffsetWidth + prevWidth);
    var errorHeight = height - (startOffsetHeight + prevHeight);
    var isErrorWidth = Math.abs(errorWidth) > 3;
    var isErrorHeight = Math.abs(errorHeight) > 3;

    if (isErrorWidth) {
      datas.startWidth += errorWidth;
      datas.startOffsetWidth += errorWidth;
      datas.prevWidth += errorWidth;
    }

    if (isErrorHeight) {
      datas.startHeight += errorHeight;
      datas.startOffsetHeight += errorHeight;
      datas.prevHeight += errorHeight;
    }

    if (isErrorWidth || isErrorHeight) {
      this.dragControl(moveable, e);
      return true;
    }
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isResize) {
      return false;
    }

    datas.isResize = false;
    var params = fillParams(moveable, e, {
      isDrag: isDrag
    });
    triggerEvent(moveable, "onResizeEnd", params);
    return isDrag;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    var direction = params.direction;
    var startPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);
    var events = triggerChildAble(moveable, this, "dragControlStart", datas, function (child, childDatas) {
      var pos = getPosByReverseDirection(getAbsolutePosesByState(child.state), direction);

      var _a = matrix.caculate(matrix.createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - startPos[0], pos[1] - startPos[1], 1], 3),
          originalX = _a[0],
          originalY = _a[1];

      childDatas.originalX = originalX;
      childDatas.originalY = originalY;
      return e;
    });

    var nextParams = __assign({}, params, {
      targets: moveable.props.targets,
      events: events
    });

    var result = triggerEvent(moveable, "onResizeGroupStart", nextParams);
    datas.isResize = result !== false;
    return datas.isResize ? params : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var offsetWidth = params.offsetWidth,
        offsetHeight = params.offsetHeight,
        dist = params.dist;
    var parentScale = [offsetWidth / (offsetWidth - dist[0]), offsetHeight / (offsetHeight - dist[1])];
    var fixedPosition = datas.fixedOriginalPosition;
    var events = triggerChildAble(moveable, this, "dragControl", datas, function (_, childDatas) {
      var _a = matrix.caculate(matrix.createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [childDatas.originalX * parentScale[0], childDatas.originalY * parentScale[1], 1], 3),
          clientX = _a[0],
          clientY = _a[1];

      return __assign({}, e, {
        parentScale: parentScale,
        dragClient: matrix.plus(fixedPosition, [clientX, clientY])
      });
    });

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onResizeGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isResize) {
      return;
    }

    this.dragControlEnd(moveable, e);
    triggerChildAble(moveable, this, "dragControlEnd", datas, e);
    var nextParams = fillParams(moveable, e, {
      targets: moveable.props.targets,
      isDrag: isDrag
    });
    triggerEvent(moveable, "onResizeGroupEnd", nextParams);
    return isDrag;
  }
};

var Scalable = {
  name: "scalable",
  ableGroup: "size",
  canPinch: true,
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        scalable = _a.scalable,
        edge = _a.edge;

    if (!resizable && scalable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }

      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        pinchFlag = e.pinchFlag,
        inputEvent = e.inputEvent;
    var inputTarget = inputEvent.target;
    var direction = pinchFlag ? [1, 1] : getDirection(inputTarget);
    var _a = moveable.state,
        width = _a.width,
        height = _a.height,
        targetTransform = _a.targetTransform,
        target = _a.target;

    if (!direction || !target) {
      return false;
    }

    if (!pinchFlag) {
      setDragStart(moveable, {
        datas: datas
      });
    }

    datas.datas = {};
    datas.transform = targetTransform;
    datas.prevDist = [1, 1];
    datas.direction = direction;
    datas.width = width;
    datas.height = height;
    datas.startScale = [1, 1];
    var params = fillParams(moveable, e, {
      direction: direction,
      set: function (scale) {
        datas.startScale = scale;
      },
      dragStart: Draggable.dragStart(moveable, new CustomDragger().dragStart([0, 0], inputEvent))
    });
    var result = triggerEvent(moveable, "onScaleStart", params);

    if (result !== false) {
      datas.isScale = true;
      moveable.state.snapDirection = direction;
    }

    return datas.isScale ? params : false;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas,
        distX = e.distX,
        distY = e.distY,
        parentScale = e.parentScale,
        parentDistance = e.parentDistance,
        parentFlag = e.parentFlag,
        pinchFlag = e.pinchFlag,
        inputEvent = e.inputEvent,
        dragClient = e.dragClient;
    var prevDist = datas.prevDist,
        direction = datas.direction,
        width = datas.width,
        height = datas.height,
        transform = datas.transform,
        isScale = datas.isScale,
        startScale = datas.startScale;

    if (!isScale) {
      return false;
    }

    var _a = moveable.props,
        throttleScale = _a.throttleScale,
        parentMoveable = _a.parentMoveable;
    var keepRatio = moveable.props.keepRatio || parentScale;
    var state = moveable.state;
    var isWidth = direction[0] || !direction[1];
    var scaleX = 1;
    var scaleY = 1;
    var startWidth = width * startScale[0];
    var startHeight = height * startScale[1];
    var ratio = isWidth ? startHeight / startWidth : startWidth / startHeight;

    if (parentScale) {
      scaleX = parentScale[0];
      scaleY = parentScale[1];
    } else if (pinchFlag) {
      if (parentDistance) {
        scaleX = (width + parentDistance) / width;
        scaleY = (height + parentDistance * height / width) / height;
      }
    } else {
      var dist = getDragDist({
        datas: datas,
        distX: distX,
        distY: distY
      });
      var distWidth = direction[0] * dist[0];
      var distHeight = direction[1] * dist[1];

      if (keepRatio && width && height) {
        var rad = matrix.getRad([0, 0], dist);
        var standardRad = matrix.getRad([0, 0], direction);
        var ratioRad = matrix.getRad([0, 0], [startWidth, startHeight]);
        var size = Math.sqrt(distWidth * distWidth + distHeight * distHeight);
        var signSize = Math.cos(rad - standardRad) * size;

        if (!direction[0]) {
          // top, bottom
          distHeight = signSize;
          distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);
        } else if (!direction[1]) {
          // left, right
          distWidth = signSize;
          distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);
        } else {
          // two-way
          distWidth = Math.cos(ratioRad) * signSize;
          distHeight = Math.sin(ratioRad) * signSize;
        }
      }

      scaleX = (width + distWidth) / width;
      scaleY = (height + distHeight) / height;
    }

    scaleX = direction[0] ? scaleX * startScale[0] : startScale[0];
    scaleY = direction[1] ? scaleY * startScale[1] : startScale[1];

    if (scaleX === 0) {
      scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
    }

    if (scaleY === 0) {
      scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
    }

    var nowDist = [scaleX / startScale[0], scaleY / startScale[1]];
    var scale = [scaleX, scaleY];
    var snapDirection = direction;

    if (moveable.props.groupable) {
      snapDirection = [(nowDist[0] >= 0 ? 1 : -1) * direction[0], (nowDist[1] >= 0 ? 1 : -1) * direction[1]];
      var stateDirection = state.snapDirection;

      if (utils.isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {
        state.snapDirection = snapDirection;
      }
    }

    var snapDist = [0, 0];

    if (!pinchFlag) {
      snapDist = checkSnapScale(moveable, nowDist, direction, snapDirection, datas);
    }

    if (keepRatio) {
      if (direction[0] && direction[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }

      var isNoSnap = !snapDist[0] && !snapDist[1];

      if (isNoSnap) {
        if (isWidth) {
          nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale) / startScale[0];
        } else {
          nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale) / startScale[1];
        }
      }

      if (direction[0] && !direction[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        nowDist[0] += snapDist[0];
        var snapHeight = getKeepRatioHeight(width * nowDist[0] * startScale[0], isWidth, ratio);
        nowDist[1] = snapHeight / height / startScale[1];
      } else if (!direction[0] && direction[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        nowDist[1] += snapDist[1];
        var snapWidth = getKeepRatioWidth(height * nowDist[1] * startScale[1], isWidth, ratio);
        nowDist[0] = snapWidth / width / startScale[0];
      }
    } else {
      if (!snapDist[0]) {
        nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale) / startScale[0];
      }

      if (!snapDist[1]) {
        nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale) / startScale[1];
      }
    }

    if (nowDist[0] === 0) {
      nowDist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
    }

    if (nowDist[1] === 0) {
      nowDist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
    }

    var delta = [nowDist[0] / prevDist[0], nowDist[1] / prevDist[1]];
    scale = multiply2(nowDist, startScale);
    datas.prevDist = nowDist;

    if (scaleX === prevDist[0] && scaleY === prevDist[1] && !parentMoveable) {
      return false;
    }

    var inverseDelta = !parentFlag && pinchFlag ? [0, 0] : getScaleDist(moveable, delta, direction, dragClient);
    var params = fillParams(moveable, e, {
      scale: scale,
      direction: direction,
      dist: nowDist,
      delta: delta,
      transform: transform + " scale(" + scaleX + ", " + scaleY + ")",
      isPinch: !!pinchFlag,
      drag: Draggable.drag(moveable, setCustomDrag(moveable.state, inverseDelta, inputEvent))
    });
    triggerEvent(moveable, "onScale", params);
    return params;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isScale) {
      return false;
    }

    datas.isScale = false;
    triggerEvent(moveable, "onScaleEnd", fillParams(moveable, e, {
      isDrag: isDrag
    }));
    return isDrag;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function (moveable, e) {
    var datas = e.datas;
    var params = this.dragControlStart(moveable, e);

    if (!params) {
      return false;
    }

    var direction = params.direction;
    var startPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);
    var events = triggerChildAble(moveable, this, "dragControlStart", datas, function (child, childDatas) {
      var pos = getPosByReverseDirection(getAbsolutePosesByState(child.state), direction);

      var _a = matrix.caculate(matrix.createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - startPos[0], pos[1] - startPos[1], 1], 3),
          originalX = _a[0],
          originalY = _a[1];

      childDatas.originalX = originalX;
      childDatas.originalY = originalY;
      return e;
    });

    var nextParams = __assign({}, params, {
      targets: moveable.props.targets,
      events: events
    });

    var result = triggerEvent(moveable, "onScaleGroupStart", nextParams);
    datas.isScale = result !== false;
    return datas.isScale ? nextParams : false;
  },
  dragGroupControl: function (moveable, e) {
    var datas = e.datas;

    if (!datas.isScale) {
      return;
    }

    var params = this.dragControl(moveable, e);

    if (!params) {
      return;
    }

    var scale = params.scale,
        direction = params.direction,
        dist = params.dist;
    var prevPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), multiply2(direction, dist));
    var events = triggerChildAble(moveable, this, "dragControl", datas, function (_, childDatas) {
      var _a = matrix.caculate(matrix.createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [childDatas.originalX * scale[0], childDatas.originalY * scale[1], 1], 3),
          clientX = _a[0],
          clientY = _a[1];

      return __assign({}, e, {
        parentScale: scale,
        dragClient: matrix.plus(prevPos, [clientX, clientY])
      });
    });

    var nextParams = __assign({
      targets: moveable.props.targets,
      events: events
    }, params);

    triggerEvent(moveable, "onScaleGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function (moveable, e) {
    var isDrag = e.isDrag,
        datas = e.datas;

    if (!datas.isScale) {
      return;
    }

    this.dragControlEnd(moveable, e);
    triggerChildAble(moveable, this, "dragControlEnd", datas, e);
    var nextParams = fillParams(moveable, e, {
      targets: moveable.props.targets,
      isDrag: isDrag
    });
    triggerEvent(moveable, "onScaleGroupEnd", nextParams);
    return isDrag;
  }
};

function getMiddleLinePos(pos1, pos2) {
  return pos1.map(function (pos, i) {
    return utils.dot(pos, pos2[i], 1, 2);
  });
}

function getTriangleRad(pos1, pos2, pos3) {
  // pos1 Rad
  var rad1 = matrix.getRad(pos1, pos2);
  var rad2 = matrix.getRad(pos1, pos3);
  var rad = rad2 - rad1;
  return rad >= 0 ? rad : rad + 2 * Math.PI;
}

function isValidPos(poses1, poses2) {
  var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);
  var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);
  var pi = Math.PI;

  if (rad1 >= pi && rad2 <= pi || rad1 <= pi && rad2 >= pi) {
    return false;
  }

  return true;
}

var Warpable = {
  name: "warpable",
  ableGroup: "size",
  render: function (moveable, React) {
    var _a = moveable.props,
        resizable = _a.resizable,
        scalable = _a.scalable,
        warpable = _a.warpable;

    if (resizable || scalable || !warpable) {
      return;
    }

    var _b = moveable.state,
        pos1 = _b.pos1,
        pos2 = _b.pos2,
        pos3 = _b.pos3,
        pos4 = _b.pos4;
    var linePosFrom1 = getMiddleLinePos(pos1, pos2);
    var linePosFrom2 = getMiddleLinePos(pos2, pos1);
    var linePosFrom3 = getMiddleLinePos(pos1, pos3);
    var linePosFrom4 = getMiddleLinePos(pos3, pos1);
    var linePosTo1 = getMiddleLinePos(pos3, pos4);
    var linePosTo2 = getMiddleLinePos(pos4, pos3);
    var linePosTo3 = getMiddleLinePos(pos2, pos4);
    var linePosTo4 = getMiddleLinePos(pos4, pos2);
    return [React.createElement("div", {
      className: prefix("line"),
      key: "middeLine1",
      style: getLineStyle(linePosFrom1, linePosTo1)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine2",
      style: getLineStyle(linePosFrom2, linePosTo2)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine3",
      style: getLineStyle(linePosFrom3, linePosTo3)
    }), React.createElement("div", {
      className: prefix("line"),
      key: "middeLine4",
      style: getLineStyle(linePosFrom4, linePosTo4)
    })].concat(renderAllDirections(moveable, React));
  },
  dragControlCondition: function (target) {
    return utils.hasClass(target, prefix("direction"));
  },
  dragControlStart: function (moveable, e) {
    var datas = e.datas,
        inputEvent = e.inputEvent;
    var target = moveable.props.target;
    var inputTarget = inputEvent.target;
    var direction = getDirection(inputTarget);

    if (!direction || !target) {
      return false;
    }

    var state = moveable.state;
    var transformOrigin = state.transformOrigin,
        is3d = state.is3d,
        targetTransform = state.targetTransform,
        targetMatrix = state.targetMatrix,
        width = state.width,
        height = state.height,
        left = state.left,
        top = state.top;
    datas.datas = {};
    datas.targetTransform = targetTransform;
    datas.warpTargetMatrix = is3d ? targetMatrix : matrix.convertDimension(targetMatrix, 3, 4);
    datas.targetInverseMatrix = matrix.ignoreDimension(matrix.invert(datas.warpTargetMatrix, 4), 3, 4);
    datas.direction = direction;
    datas.left = left;
    datas.top = top;
    setDragStart(moveable, {
      datas: datas
    });
    datas.poses = [[0, 0], [width, 0], [0, height], [width, height]].map(function (p, i) {
      return matrix.minus(p, transformOrigin);
    });
    datas.nextPoses = datas.poses.map(function (_a) {
      var x = _a[0],
          y = _a[1];
      return matrix.caculate(datas.warpTargetMatrix, [x, y, 0, 1], 4);
    });
    datas.startMatrix = matrix.createIdentityMatrix(4);
    datas.prevMatrix = matrix.createIdentityMatrix(4);
    datas.absolutePoses = getAbsolutePosesByState(state);
    datas.posIndexes = getPosIndexesByDirection(direction);
    state.snapDirection = direction;
    var params = fillParams(moveable, e, {
      set: function (matrix) {
        datas.startMatrix = matrix;
      }
    });
    var result = triggerEvent(moveable, "onWarpStart", params);

    if (result !== false) {
      datas.isWarp = true;
    }

    return result;
  },
  dragControl: function (moveable, e) {
    var datas = e.datas;
    var distX = e.distX,
        distY = e.distY;
    var targetInverseMatrix = datas.targetInverseMatrix,
        prevMatrix = datas.prevMatrix,
        isWarp = datas.isWarp,
        startMatrix = datas.startMatrix,
        poses = datas.poses,
        posIndexes = datas.posIndexes,
        absolutePoses = datas.absolutePoses;

    if (!isWarp) {
      return false;
    }

    if (hasGuidelines(moveable, "warpable")) {
      var selectedPoses = posIndexes.map(function (index) {
        return absolutePoses[index];
      });

      if (selectedPoses.length > 1) {
        selectedPoses.push([(selectedPoses[0][0] + selectedPoses[1][0]) / 2, (selectedPoses[0][1] + selectedPoses[1][1]) / 2]);
      }

      var snapInfos = checkSnapPoses(moveable, selectedPoses.map(function (pos) {
        return pos[0] + distX;
      }), selectedPoses.map(function (pos) {
        return pos[1] + distY;
      }));
      var horizontalOffset = snapInfos.horizontal.offset,
          verticalOffset = snapInfos.vertical.offset;
      distY -= horizontalOffset;
      distX -= verticalOffset;
    }

    var dist = getDragDist({
      datas: datas,
      distX: distX,
      distY: distY
    }, true);
    var nextPoses = datas.nextPoses.slice();
    posIndexes.forEach(function (index) {
      nextPoses[index] = matrix.plus(nextPoses[index], dist);
    });

    if (!NEARBY_POS.every(function (nearByPoses) {
      return isValidPos(nearByPoses.map(function (i) {
        return poses[i];
      }), nearByPoses.map(function (i) {
        return nextPoses[i];
      }));
    })) {
      return false;
    }

    var h = matrix.createWarpMatrix(poses[0], poses[1], poses[2], poses[3], nextPoses[0], nextPoses[1], nextPoses[2], nextPoses[3]);

    if (!h.length) {
      return false;
    }

    var matrix$1 = matrix.convertMatrixtoCSS(matrix.multiply(targetInverseMatrix, h, 4));
    var transform = datas.targetTransform + " matrix3d(" + matrix$1.join(",") + ")";
    var delta = matrix.multiplyCSS(matrix.invert(prevMatrix, 4), matrix$1, 4);
    datas.prevMatrix = matrix$1;
    triggerEvent(moveable, "onWarp", fillParams(moveable, e, {
      delta: delta,
      matrix: matrix.multiplyCSS(startMatrix, matrix$1, 4),
      multiply: matrix.multiplyCSS,
      dist: matrix$1,
      transform: transform
    }));
    return true;
  },
  dragControlEnd: function (moveable, e) {
    var datas = e.datas,
        isDrag = e.isDrag;

    if (!datas.isWarp) {
      return false;
    }

    datas.isWarp = false;
    triggerEvent(moveable, "onWarpEnd", fillParams(moveable, e, {
      isDrag: isDrag
    }));
    return isDrag;
  }
};

var AREA = prefix("area");
var AREA_PIECES = prefix("area-pieces");
var AREA_PIECE = prefix("area-piece");
var AVOID = prefix("avoid");

function restoreStyle(moveable) {
  var el = moveable.areaElement;
  var _a = moveable.state,
      width = _a.width,
      height = _a.height;
  utils.removeClass(el, AVOID);
  el.style.cssText += "left: 0px; top: 0px; width: " + width + "px; height: " + height + "px";
}

function renderPieces(React) {
  return React.createElement("div", {
    key: "area_pieces",
    className: AREA_PIECES
  }, React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }));
}

var DragArea = {
  name: "dragArea",
  render: function (moveable, React) {
    var _a = moveable.props,
        target = _a.target,
        dragArea = _a.dragArea,
        groupable = _a.groupable;
    var _b = moveable.state,
        width = _b.width,
        height = _b.height,
        pos1 = _b.pos1,
        pos2 = _b.pos2,
        pos3 = _b.pos3,
        pos4 = _b.pos4;

    if (groupable) {
      return [React.createElement("div", {
        key: "area",
        ref: frameworkUtils.ref(moveable, "areaElement"),
        className: AREA
      }), renderPieces(React)];
    }

    if (!target || !dragArea) {
      return [];
    }

    var h = matrix.createWarpMatrix([0, 0], [width, 0], [0, height], [width, height], pos1, pos2, pos3, pos4);
    var transform = h.length ? "matrix3d(" + matrix.convertMatrixtoCSS(h).join(",") + ")" : "none";
    return [React.createElement("div", {
      key: "area",
      ref: frameworkUtils.ref(moveable, "areaElement"),
      className: AREA,
      style: {
        top: "0px",
        left: "0px",
        width: width + "px",
        height: height + "px",
        transformOrigin: "0 0",
        transform: transform
      }
    }), renderPieces(React)];
  },
  dragStart: function (moveable, _a) {
    var datas = _a.datas,
        clientX = _a.clientX,
        clientY = _a.clientY,
        inputEvent = _a.inputEvent;
    datas.isDragArea = false;
    datas.inputTarget = inputEvent.target;
    var areaElement = moveable.areaElement;
    var _b = moveable.state,
        clientRect = _b.clientRect,
        pos1 = _b.pos1,
        pos2 = _b.pos2,
        pos3 = _b.pos3,
        pos4 = _b.pos4;
    var left = clientRect.left,
        top = clientRect.top,
        width = clientRect.width,
        height = clientRect.height;

    var _c = getRect([pos1, pos2, pos3, pos4]),
        relativeLeft = _c.left,
        relativeTop = _c.top;

    var posX = clientX - left;
    var posY = clientY - top;
    var rects = [{
      left: relativeLeft,
      top: relativeTop,
      width: width,
      height: posY - 10
    }, {
      left: relativeLeft,
      top: relativeTop,
      width: posX - 10,
      height: height
    }, {
      left: relativeLeft,
      top: relativeTop + posY + 10,
      width: width,
      height: height - posY - 10
    }, {
      left: relativeLeft + posX + 10,
      top: relativeTop,
      width: width - posX - 10,
      height: height
    }];
    var children = [].slice.call(areaElement.nextElementSibling.children);
    rects.forEach(function (rect, i) {
      children[i].style.cssText = "left: " + rect.left + "px;top: " + rect.top + "px; width: " + rect.width + "px; height: " + rect.height + "px;";
    });
    utils.addClass(areaElement, AVOID);
  },
  drag: function (moveable, _a) {
    var datas = _a.datas;

    if (!datas.isDragArea) {
      datas.isDragArea = true;
      restoreStyle(moveable);
    }
  },
  dragEnd: function (moveable, e) {
    var inputEvent = e.inputEvent,
        isDragArea = e.isDragArea,
        datas = e.datas;

    if (!datas.isDragArea) {
      restoreStyle(moveable);
    }

    var target = moveable.state.target;
    var inputTarget = inputEvent.target;

    if (isDragArea || moveable.isMoveableElement(inputTarget)) {
      return;
    }

    var containsTarget = target.contains(inputTarget);
    triggerEvent(moveable, "onClick", fillParams(moveable, e, {
      inputTarget: inputTarget,
      isTarget: target === inputTarget,
      containsTarget: containsTarget
    }));
  },
  dragGroupStart: function (moveable, e) {
    this.dragStart(moveable, e);
  },
  dragGroup: function (moveable, e) {
    this.drag(moveable, e);
  },
  dragGroupEnd: function (moveable, e) {
    var inputEvent = e.inputEvent,
        isDragArea = e.isDragArea,
        datas = e.datas;

    if (!isDragArea) {
      restoreStyle(moveable);
    }

    var prevInputTarget = datas.inputTarget;
    var inputTarget = inputEvent.target;

    if (isDragArea || moveable.isMoveableElement(inputTarget) || prevInputTarget === inputTarget) {
      return;
    }

    var targets = moveable.props.targets;
    var targetIndex = targets.indexOf(inputTarget);
    var isTarget = targetIndex > -1;
    var containsTarget = false;

    if (targetIndex === -1) {
      targetIndex = utils.findIndex(targets, function (parentTarget) {
        return parentTarget.contains(inputTarget);
      });
      containsTarget = targetIndex > -1;
    }

    triggerEvent(moveable, "onClickGroup", fillParams(moveable, e, {
      targets: targets,
      inputTarget: inputTarget,
      targetIndex: targetIndex,
      isTarget: isTarget,
      containsTarget: containsTarget
    }));
  }
};

var Origin = {
  name: "origin",
  render: function (moveable, React) {
    if (!moveable.props.origin) {
      return null;
    }

    var _a = moveable.state,
        beforeOrigin = _a.beforeOrigin,
        rotation = _a.rotation;
    return [React.createElement("div", {
      className: prefix("control", "origin"),
      style: getControlTransform(rotation, beforeOrigin),
      key: "beforeOrigin"
    })];
  }
};

function getDefaultScrollPosition(e) {
  var scrollContainer = e.scrollContainer;
  return [scrollContainer.scrollLeft, scrollContainer.scrollTop];
}

var Scrollable = {
  name: "scrollable",
  canPinch: true,
  dragStart: function (moveable, e) {
    var props = moveable.props;
    var _a = props.scrollContainer,
        scrollContainer = _a === void 0 ? moveable.getContainer() : _a;
    var scrollClientRect = scrollContainer.getBoundingClientRect();
    var datas = e.datas;
    datas.scrollContainer = scrollContainer;
    datas.scrollRect = {
      left: scrollClientRect.left,
      top: scrollClientRect.top,
      width: scrollClientRect.width,
      height: scrollClientRect.height
    };
    datas.isScroll = true;
  },
  drag: function (moveable, e) {
    this.checkScroll(moveable, e);
  },
  dragEnd: function (moveable, e) {
    e.datas.isScroll = false;
  },
  dragGroupStart: function (moveable, e) {
    this.dragStart(moveable, e);
  },
  dragGroup: function (moveable, e) {
    this.drag(moveable, __assign({}, e, {
      targets: moveable.props.targets
    }));
  },
  dragGroupEnd: function (moveable, e) {
    this.dragEnd(moveable, e);
  },
  checkScroll: function (moveable, e) {
    var datas = e.datas,
        inputEvent = e.inputEvent,
        clientX = e.clientX,
        clientY = e.clientY,
        isScroll = e.isScroll,
        targets = e.targets;

    if (!datas.isScroll) {
      return;
    }

    if (!isScroll) {
      datas.prevClientX = clientX;
      datas.prevClientY = clientY;
    }

    var _a = moveable.props,
        _b = _a.scrollThreshold,
        scrollThreshold = _b === void 0 ? 0 : _b,
        _c = _a.getScrollPosition,
        getScrollPosition = _c === void 0 ? getDefaultScrollPosition : _c;
    var scrollContainer = datas.scrollContainer,
        scrollRect = datas.scrollRect;
    var direction = [0, 0];

    if (scrollRect.top > clientY - scrollThreshold) {
      direction[1] = -1;
    } else if (scrollRect.top + scrollRect.height < clientY + scrollThreshold) {
      direction[1] = 1;
    }

    if (scrollRect.left > clientX - scrollThreshold) {
      direction[0] = -1;
    } else if (scrollRect.left + scrollRect.width < clientX + scrollThreshold) {
      direction[0] = 1;
    }

    if (!direction[0] && !direction[1]) {
      return;
    }

    var pos = getScrollPosition({
      scrollContainer: scrollContainer,
      direction: direction
    });
    var params = fillParams(moveable, e, {
      scrollContainer: scrollContainer,
      direction: direction
    });
    var eventName = targets ? "onScrollGroup" : "onScroll";

    if (targets) {
      params.targets = targets;
    }

    triggerEvent(moveable, eventName, params);
    requestAnimationFrame(function () {
      if (datas.prevClientX !== clientX || datas.prevClientY !== clientY) {
        return;
      }

      var nextPos = getScrollPosition({
        scrollContainer: scrollContainer,
        direction: direction
      });
      var offsetX = nextPos[0] - pos[0];
      var offsetY = nextPos[1] - pos[1];

      if (!offsetX && !offsetY) {
        return;
      }

      moveable.targetDragger.scrollBy(direction[0] ? offsetX : 0, direction[1] ? offsetY : 0, inputEvent, false);
      setTimeout(function () {
        if (datas.prevClientX !== clientX || datas.prevClientY !== clientY) {
          return;
        }

        moveable.targetDragger.onDrag(inputEvent, true);
      }, 10);
    });
  }
};

var MOVEABLE_ABLES = [Snappable, Pinchable, Draggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, DragArea, Origin];

var Groupable = {
  name: "groupable",
  render: function (moveable, React) {
    var targets = moveable.props.targets || [];
    moveable.moveables = [];
    var _a = moveable.state,
        left = _a.left,
        top = _a.top;
    var position = {
      left: left,
      top: top
    };
    return targets.map(function (target, i) {
      return React.createElement(MoveableManager, {
        key: i,
        ref: frameworkUtils.refs(moveable, "moveables", i),
        target: target,
        origin: false,
        parentMoveable: moveable,
        parentPosition: position
      });
    }).slice();
  }
};

function getMaxPos(poses, index) {
  return Math.max.apply(Math, poses.map(function (_a) {
    var pos1 = _a[0],
        pos2 = _a[1],
        pos3 = _a[2],
        pos4 = _a[3];
    return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);
  }));
}

function getMinPos(poses, index) {
  return Math.min.apply(Math, poses.map(function (_a) {
    var pos1 = _a[0],
        pos2 = _a[1],
        pos3 = _a[2],
        pos4 = _a[3];
    return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);
  }));
}

function getGroupRect(moveables, rotation) {
  if (!moveables.length) {
    return [0, 0, 0, 0];
  }

  var moveablePoses = moveables.map(function (_a) {
    var state = _a.state;
    return getAbsolutePosesByState(state);
  });
  var minX = MAX_NUM;
  var minY = MAX_NUM;
  var groupWidth = 0;
  var groupHeight = 0;
  var fixedRotation = throttle(rotation, TINY_NUM);

  if (fixedRotation % 90) {
    var rad_1 = rotation / 180 * Math.PI;
    var a1_1 = Math.tan(rad_1);
    var a2_1 = -1 / a1_1;
    var b1s_1 = [MIN_NUM, MAX_NUM];
    var b2s_1 = [MIN_NUM, MAX_NUM];
    moveablePoses.forEach(function (poses) {
      poses.forEach(function (pos) {
        // ax + b = y
        //  = y - ax
        var b1 = pos[1] - a1_1 * pos[0];
        var b2 = pos[1] - a2_1 * pos[0];
        b1s_1[0] = Math.max(b1s_1[0], b1);
        b1s_1[1] = Math.min(b1s_1[1], b1);
        b2s_1[0] = Math.max(b2s_1[0], b2);
        b2s_1[1] = Math.min(b2s_1[1], b2);
      });
    });
    b1s_1.forEach(function (b1) {
      // a1x + b1 = a2x + b2
      b2s_1.forEach(function (b2) {
        // (a1 - a2)x = b2 - b1
        var x = (b2 - b1) / (a1_1 - a2_1);
        var y = a1_1 * x + b1;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
      });
    });
    var rotatePoses = moveablePoses.map(function (_a) {
      var pos1 = _a[0],
          pos2 = _a[1],
          pos3 = _a[2],
          pos4 = _a[3];
      return [matrix.rotate(pos1, -rad_1), matrix.rotate(pos2, -rad_1), matrix.rotate(pos3, -rad_1), matrix.rotate(pos4, -rad_1)];
    });
    groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);
    groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);
  } else {
    minX = getMinPos(moveablePoses, 0);
    minY = getMinPos(moveablePoses, 1);
    groupWidth = getMaxPos(moveablePoses, 0) - minX;
    groupHeight = getMaxPos(moveablePoses, 1) - minY;

    if (fixedRotation % 180) {
      var changedWidth = groupWidth;
      groupWidth = groupHeight;
      groupHeight = changedWidth;
    }
  }

  return [minX, minY, groupWidth, groupHeight];
}

var MoveableGroup =
/*#__PURE__*/
function (_super) {
  __extends(MoveableGroup, _super);

  function MoveableGroup() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.differ = new ChildrenDiffer();
    _this.moveables = [];
    _this.rotation = 0;
    return _this;
  }

  var __proto = MoveableGroup.prototype;

  __proto.updateEvent = function (prevProps) {
    var state = this.state;
    var props = this.props;

    if (!state.target) {
      state.target = this.areaElement;
      this.controlBox.getElement().style.display = "block";
      this.targetDragger = getAbleDragger(this, state.target, "targetAbles", "Group");
      this.controlDragger = getAbleDragger(this, this.controlBox.getElement(), "controlAbles", "GroupControl");
    }

    var isContainerChanged = !equals(prevProps.container, props.container);

    if (isContainerChanged) {
      state.container = props.container;
    }

    var _a = this.differ.update(props.targets),
        added = _a.added,
        changed = _a.changed,
        removed = _a.removed;

    if (isContainerChanged || added.length || changed.length || removed.length) {
      this.updateRect();
    }
  };

  __proto.checkUpdate = function () {
    this.updateAbles();
  };

  __proto.updateRect = function (type, isTarget, isSetState) {
    var _a;

    if (isSetState === void 0) {
      isSetState = true;
    }

    if (!this.controlBox) {
      return;
    }

    this.moveables.forEach(function (moveable) {
      moveable.updateRect(type, false, false);
    });
    var state = this.state;
    var props = this.props;
    var target = state.target || props.target;

    if (!isTarget || type !== "" && props.updateGroup) {
      // reset rotataion
      this.rotation = props.defaultGroupRotate;
    }

    var rotation = this.rotation;

    var _b = getGroupRect(this.moveables, rotation),
        left = _b[0],
        top = _b[1],
        width = _b[2],
        height = _b[3]; // tslint:disable-next-line: max-line-length


    target.style.cssText += "left:0px;top:0px;width:" + width + "px; height:" + height + "px;transform:rotate(" + rotation + "deg)";
    state.width = width;
    state.height = height;
    var info = getTargetInfo(target, this.controlBox.getElement(), this.getContainer(), state);
    var pos = [info.left, info.top];
    _a = getAbsolutePosesByState(info), info.pos1 = _a[0], info.pos2 = _a[1], info.pos3 = _a[2], info.pos4 = _a[3];
    info.origin = matrix.plus(pos, info.origin);
    info.beforeOrigin = matrix.plus(pos, info.beforeOrigin);
    var clientRect = info.clientRect;
    clientRect.top += top - info.top - state.top;
    clientRect.left += left - info.left - state.left;
    this.updateState(__assign({}, info, {
      left: left - info.left,
      top: top - info.top
    }), isSetState);
  };

  __proto.triggerEvent = function (name, e) {
    if (name.indexOf("Group") > -1) {
      return _super.prototype.triggerEvent.call(this, name, e);
    }
  };

  __proto.updateAbles = function () {
    _super.prototype.updateAbles.call(this, this.props.ables.concat([Groupable]), "Group");
  };

  MoveableGroup.defaultProps = __assign({}, MoveableManager.defaultProps, {
    transformOrigin: ["50%", "50%"],
    groupable: true,
    dragArea: true,
    keepRatio: true,
    targets: [],
    defaultGroupRotate: 0
  });
  return MoveableGroup;
}(MoveableManager);

var Moveable =
/*#__PURE__*/
function (_super) {
  __extends(Moveable, _super);

  function Moveable() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  var __proto = Moveable.prototype;

  __proto.render = function () {
    var props = this.props;
    var ables = props.ables || [];
    var target = this.props.target || this.props.targets;
    var isArr = utils.isArray(target);
    var isGroup = isArr && target.length > 1;

    if (isGroup) {
      var nextProps = __assign({}, this.props, {
        target: null,
        targets: target,
        ables: MOVEABLE_ABLES.concat([Groupable], ables)
      });

      return React.createElement(MoveableGroup, __assign({
        key: "group",
        ref: frameworkUtils.ref(this, "moveable")
      }, nextProps));
    } else {
      var moveableTarget = isArr ? target[0] : target;
      return React.createElement(MoveableManager, __assign({
        key: "single",
        ref: frameworkUtils.ref(this, "moveable")
      }, __assign({}, this.props, {
        target: moveableTarget,
        ables: MOVEABLE_ABLES.concat(ables)
      })));
    }
  };

  __proto.isMoveableElement = function (target) {
    return this.moveable.isMoveableElement(target);
  };

  __proto.dragStart = function (e) {
    this.moveable.dragStart(e);
  };

  __proto.isInside = function (clientX, clientY) {
    return this.moveable.isInside(clientX, clientY);
  };

  __proto.updateRect = function () {
    this.moveable.updateRect();
  };

  __proto.updateTarget = function () {
    this.moveable.updateTarget();
  };

  __proto.getRect = function () {
    return this.moveable.getRect();
  };

  __proto.destroy = function () {
    this.moveable.componentWillUnmount();
  };

  return Moveable;
}(React.PureComponent);

module.exports = Moveable;
//# sourceMappingURL=moveable.cjs.js.map
