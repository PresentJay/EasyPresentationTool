{"version":3,"file":"moveable.esm.js","sources":["../src/react-moveable/consts.ts","../src/react-moveable/utils.ts","../src/react-moveable/ables/triggerRender.ts","../src/react-moveable/getAbleDragger.ts","../src/react-moveable/MoveableManager.tsx","../src/react-moveable/ables/Pinchable.ts","../src/react-moveable/groupUtils.ts","../src/react-moveable/DraggerUtils.ts","../src/react-moveable/ables/Snappable.tsx","../src/react-moveable/ables/Draggable.ts","../src/react-moveable/CustomDragger.ts","../src/react-moveable/ables/Rotatable.tsx","../src/react-moveable/renderDirection.tsx","../src/react-moveable/ables/Resizable.ts","../src/react-moveable/ables/Scalable.ts","../src/react-moveable/ables/Warpable.tsx","../src/react-moveable/classNames.ts","../src/react-moveable/ables/DragArea.tsx","../src/react-moveable/ables/Origin.tsx","../src/react-moveable/ables/Scrollable.ts","../src/react-moveable/ables/consts.ts","../src/react-moveable/ables/Groupable.tsx","../src/react-moveable/MoveableGroup.tsx","../src/react-moveable/Moveable.tsx"],"sourcesContent":["import { prefixCSS } from \"framework-utils\";\nimport getAgent from \"@egjs/agent\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport const agent = getAgent();\nexport const isWebkit\n    = agent.os.name.indexOf(\"ios\") > -1 || agent.browser.name.indexOf(\"safari\") > -1;\nexport const PREFIX = \"moveable-\";\nexport const MOVEABLE_CSS = prefixCSS(PREFIX, `\n{\n\tposition: fixed;\n\twidth: 0;\n\theight: 0;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 3000;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n\tleft: 0;\n\ttop: 0;\n}\n.control {\n\tposition: absolute;\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n\tbackground: #4af;\n\tmargin-top: -7px;\n    margin-left: -7px;\n    z-index: 10;\n    will-change: transform;\n}\n.line {\n\tposition: absolute;\n\twidth: 1px;\n\theight: 1px;\n\tbackground: #4af;\n\ttransform-origin: 0px 0.5px;\n}\n.line.rotation-line {\n\theight: 40px;\n\twidth: 1px;\n\ttransform-origin: 0.5px 39.5px;\n}\n.line.rotation-line .control {\n\tborder-color: #4af;\n\tbackground:#fff;\n\tcursor: alias;\n}\n.line.vertical.bold {\n    width: 2px;\n    margin-left: -1px;\n}\n.line.horizontal.bold {\n    height: 2px;\n    margin-top: -1px;\n}\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n\tmargin-left: -6px;\n\tpointer-events: none;\n}\n.direction.e, .direction.w {\n\tcursor: ew-resize;\n}\n.direction.s, .direction.n {\n\tcursor: ns-resize;\n}\n.direction.nw, .direction.se, :host.reverse .direction.ne, :host.reverse .direction.sw {\n\tcursor: nwse-resize;\n}\n.direction.ne, .direction.sw, :host.reverse .direction.nw, :host.reverse .direction.se {\n\tcursor: nesw-resize;\n}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n${isWebkit ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\"}\n`);\nexport const DRAGGER_EVENTS = [\"dragstart\", \"drag\", \"dragend\", \"pinchstart\", \"pinch\", \"pinchend\"];\n\nexport const NEARBY_POS = [\n    [0, 1, 2],\n    [1, 0, 3],\n    [2, 0, 3],\n    [3, 1, 2],\n];\n\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n    n: [0, 1],\n    s: [2, 3],\n    w: [2, 0],\n    e: [1, 3],\n    nw: [0],\n    ne: [1],\n    sw: [2],\n    se: [3],\n};\n","import { PREFIX, isWebkit } from \"./consts\";\nimport { prefixNames } from \"framework-utils\";\nimport { splitBracket, isUndefined, isObject, splitUnit, IObject } from \"@daybrush/utils\";\nimport {\n    multiply, invert,\n    convertCSStoMatrix, convertMatrixtoCSS,\n    convertDimension, createIdentityMatrix,\n    createOriginMatrix, convertPositionMatrix, caculate,\n    multiplies,\n    minus,\n    getOrigin,\n    createScaleMatrix,\n    plus,\n    getRad,\n} from \"@moveable/matrix\";\n\nimport MoveableManager from \"./MoveableManager\";\nimport { MoveableManagerState, Able } from \"./types\";\n\nexport function multiply2(pos1: number[], pos2: number[]) {\n    return [\n        pos1[0] * pos2[0],\n        pos1[1] * pos2[1],\n    ];\n}\nexport function prefix(...classNames: string[]) {\n    return prefixNames(PREFIX, ...classNames);\n}\n\nexport function createIdentityMatrix3() {\n    return createIdentityMatrix(3);\n}\n\nexport function getTransform(target: SVGElement | HTMLElement, isInit: true): number[];\nexport function getTransform(target: SVGElement | HTMLElement, isInit?: false): \"none\" | number[];\nexport function getTransform(target: SVGElement | HTMLElement, isInit?: boolean) {\n    const transform = getComputedStyle(target).transform!;\n\n    if (!transform || (transform === \"none\" && !isInit)) {\n        return \"none\";\n    }\n    return getTransformMatrix(transform);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n    if (!transform || transform === \"none\") {\n        return [1, 0, 0, 1, 0, 0];\n\n    }\n    if (isObject(transform)) {\n        return transform;\n    }\n    const value = splitBracket(transform).value!;\n    return value.split(/s*,\\s*/g).map(v => parseFloat(v));\n}\nexport function getAbsoluteMatrix(matrix: number[], n: number, origin: number[]) {\n\n    return multiplies(\n        n,\n        createOriginMatrix(origin, n),\n        matrix,\n        createOriginMatrix(origin.map(a => -a), n),\n    );\n}\nexport function measureSVGSize(el: SVGElement, unit: string, isHorizontal: boolean) {\n    if (unit === \"%\") {\n        const viewBox = el.ownerSVGElement!.viewBox.baseVal;\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n    }\n    return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n    const relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n\n    return relativeOrigin.map((o, i) => {\n        const { value, unit } = splitUnit(o);\n\n        return value * measureSVGSize(el, unit, i === 0);\n    });\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n    const transformOrigin = style.transformOrigin;\n\n    return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nexport function getOffsetInfo(\n    el: SVGElement | HTMLElement | null | undefined,\n    lastParent: SVGElement | HTMLElement | null | undefined,\n    isParent?: boolean,\n) {\n    const body = document.body;\n    let target = !el || isParent ? el : el.parentElement;\n    let isEnd = false;\n    let position = \"relative\";\n\n    while (target && target !== body) {\n        if (lastParent === target) {\n            isEnd = true;\n        }\n        const style = getComputedStyle(target);\n        const transform = style.transform;\n        position = style.position!;\n\n        if (position !== \"static\" || (transform && transform !== \"none\")) {\n            break;\n        }\n        target = target.parentElement;\n        position = \"relative\";\n    }\n    return {\n        isStatic: position === \"static\",\n        isEnd: isEnd || !target || target === body,\n        offsetParent: target as HTMLElement || body,\n    };\n\n}\nexport function caculateMatrixStack(\n    target: SVGElement | HTMLElement,\n    container: SVGElement | HTMLElement | null,\n    prevMatrix?: number[],\n    prevN?: number,\n): [number[], number[], number[], number[], string, number[], boolean] {\n    let el: SVGElement | HTMLElement | null = target;\n    const matrixes: number[][] = [];\n    const isSVGGraphicElement = el.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in el;\n    const originalContainer = container || document.body;\n    let isEnd = false;\n    let is3d = false;\n    let n = 3;\n    let transformOrigin!: number[];\n    let targetMatrix!: number[];\n\n    const offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n\n    if (prevMatrix) {\n        container = target.parentElement;\n    }\n\n    while (el && !isEnd) {\n        const style: CSSStyleDeclaration = getComputedStyle(el);\n        const tagName = el.tagName.toLowerCase();\n        const position = style.position;\n        const isFixed = position === \"fixed\";\n        const styleTransform = style.transform!;\n        let matrix: number[] = convertCSStoMatrix(getTransformMatrix(styleTransform));\n\n        if (!is3d && matrix.length === 16) {\n            is3d = true;\n            n = 4;\n            const matrixesLength = matrixes.length;\n\n            for (let i = 0; i < matrixesLength; ++i) {\n                matrixes[i] = convertDimension(matrixes[i], 3, 4);\n            }\n        }\n        if (is3d && matrix.length === 9) {\n            matrix = convertDimension(matrix, 3, 4);\n        }\n\n        let offsetLeft = (el as HTMLElement).offsetLeft;\n        let offsetTop = (el as HTMLElement).offsetTop;\n\n        if (isFixed) {\n            const containerRect = (container || document.documentElement).getBoundingClientRect();\n\n            offsetLeft -= containerRect.left;\n            offsetTop  -= containerRect.top;\n        }\n        // svg\n        const isSVG = isUndefined(offsetLeft);\n        let hasNotOffset = isSVG;\n        let origin: number[];\n        // inner svg element\n        if (hasNotOffset && tagName !== \"svg\") {\n            origin = isWebkit\n                ? getBeforeTransformOrigin(el as SVGElement)\n                : getTransformOrigin(style).map(pos => parseFloat(pos));\n\n            hasNotOffset = false;\n\n            if (tagName === \"g\") {\n                offsetLeft = 0;\n                offsetTop = 0;\n            } else {\n                [\n                    offsetLeft, offsetTop, origin[0], origin[1],\n                ] = getSVGGraphicsOffset(el as SVGGraphicsElement, origin);\n            }\n        } else {\n            origin = getTransformOrigin(style).map(pos => parseFloat(pos));\n        }\n        if (tagName === \"svg\" && targetMatrix) {\n            matrixes.push(\n                getSVGMatrix(el as SVGSVGElement, n),\n                createIdentityMatrix(n),\n            );\n        }\n        const {\n            offsetParent,\n            isEnd: isOffsetEnd,\n            isStatic,\n        } = getOffsetInfo(el, container);\n\n        if (isWebkit && !hasNotOffset && !isSVG && isStatic && position === \"relative\") {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n\n            isEnd = isEnd || isOffsetEnd;\n        }\n        let parentClientLeft = 0;\n        let parentClientTop = 0;\n\n        if (!hasNotOffset && offsetContainer !== offsetParent) {\n            parentClientLeft = offsetParent.clientLeft;\n            parentClientTop = offsetParent.clientTop;\n        }\n        matrixes.push(\n            getAbsoluteMatrix(matrix, n, origin),\n            createOriginMatrix([\n                (hasNotOffset ? el : offsetLeft - el.scrollLeft + parentClientLeft) as any,\n                (hasNotOffset ? origin : offsetTop - el.scrollTop + parentClientTop) as any,\n            ], n),\n        );\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin;\n        }\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            isEnd = isOffsetEnd;\n        }\n\n    }\n    let mat = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let offsetMatrix = createIdentityMatrix(n);\n    const length = matrixes.length;\n    const endContainer = getOffsetInfo(originalContainer, originalContainer, true).offsetParent;\n\n    matrixes.reverse();\n    matrixes.forEach((matrix, i) => {\n        if (length - 2 === i) {\n            beforeMatrix = mat.slice();\n        }\n        if (length - 1 === i) {\n            offsetMatrix = mat.slice();\n        }\n\n        if (isObject(matrix[n - 1])) {\n            [matrix[n - 1], matrix[2 * n - 1]] =\n                getSVGOffset(\n                    matrix[n - 1] as any,\n                    endContainer,\n                    n,\n                    matrix[2 * n - 1] as any,\n                    mat,\n                    matrixes[i + 1],\n                );\n        }\n        mat = multiply(\n            mat,\n            matrix,\n            n,\n        );\n    });\n    const isMatrix3d = !isSVGGraphicElement && is3d;\n    const transform = `${isMatrix3d ? \"matrix3d\" : \"matrix\"}(${\n        convertMatrixtoCSS(isSVGGraphicElement && targetMatrix.length === 16\n            ? convertDimension(targetMatrix, 4, 3) : targetMatrix)\n        })`;\n\n    return [\n        beforeMatrix, offsetMatrix, mat, targetMatrix, transform, transformOrigin, is3d,\n    ];\n}\nexport function getSVGMatrix(\n    el: SVGSVGElement,\n    n: number,\n) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n    const viewBox = (el as SVGSVGElement).viewBox.baseVal;\n    const viewBoxWidth = viewBox.width || clientWidth;\n    const viewBoxHeight = viewBox.height || clientHeight;\n    const scaleX = clientWidth / viewBoxWidth;\n    const scaleY = clientHeight / viewBoxHeight;\n\n    const preserveAspectRatio = (el as SVGSVGElement).preserveAspectRatio.baseVal;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n    const align = preserveAspectRatio.align;\n    // 1 : meet 2: slice\n    const meetOrSlice = preserveAspectRatio.meetOrSlice;\n    const svgOrigin = [0, 0];\n    const scale = [scaleX, scaleY];\n    const translate = [0, 0];\n\n    if (align !== 1) {\n        const xAlign = (align - 2) % 3;\n        const yAlign = Math.floor((align - 2) / 3);\n\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\n\n        const scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n        scale[0] = scaleDimension;\n        scale[1] = scaleDimension;\n\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n    }\n\n    const scaleMatrix = createScaleMatrix(scale, n);\n    [\n        scaleMatrix[n - 1],\n        scaleMatrix[2 * n - 1],\n    ] = translate;\n\n    return getAbsoluteMatrix(\n        scaleMatrix,\n        n,\n        svgOrigin,\n    );\n}\nexport function getSVGGraphicsOffset(\n    el: SVGGraphicsElement,\n    origin: number[],\n) {\n    if (!el.getBBox) {\n        return [0, 0];\n    }\n    const bbox = el.getBBox();\n    const svgElement = el.ownerSVGElement!;\n    const viewBox = svgElement.viewBox.baseVal;\n    const left = bbox.x - viewBox.x;\n    const top = bbox.y - viewBox.y;\n\n    return [\n        left,\n        top,\n        origin[0] - left,\n        origin[1] - top,\n    ];\n}\nexport function caculatePosition(matrix: number[], pos: number[], n: number) {\n    return caculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function caculatePoses(matrix: number[], width: number, height: number, n: number) {\n    const pos1 = caculatePosition(matrix, [0, 0], n);\n    const pos2 = caculatePosition(matrix, [width, 0], n);\n    const pos3 = caculatePosition(matrix, [0, height], n);\n    const pos4 = caculatePosition(matrix, [width, height], n);\n\n    return [pos1, pos2, pos3, pos4];\n}\nexport function getRect(poses: number[][]) {\n    const posesX = poses.map(pos => pos[0]);\n    const posesY = poses.map(pos => pos[1]);\n    const left = Math.min(...posesX);\n    const top = Math.min(...posesY);\n    const right = Math.max(...posesX);\n    const bottom = Math.max(...posesY);\n    const rectWidth = right - left;\n    const rectHeight = bottom - top;\n\n    return {\n        left, top,\n        right, bottom,\n        width: rectWidth,\n        height: rectHeight,\n    };\n}\nexport function caculateRect(matrix: number[], width: number, height: number, n: number) {\n    const poses = caculatePoses(matrix, width, height, n);\n\n    return getRect(poses);\n}\nexport function getSVGOffset(\n    el: SVGElement,\n    container: HTMLElement | SVGElement,\n    n: number, origin: number[], beforeMatrix: number[], absoluteMatrix: number[]) {\n\n    const [width, height] = getSize(el);\n    const containerRect = container.getBoundingClientRect();\n    const rect = el.getBoundingClientRect();\n    const rectLeft = rect.left - containerRect.left + container.scrollLeft;\n    const rectTop = rect.top - containerRect.top + container.scrollTop;\n    const rectWidth = rect.width;\n    const rectHeight = rect.height;\n    const mat = multiplies(\n        n,\n        beforeMatrix,\n        absoluteMatrix,\n    );\n    const {\n        left: prevLeft,\n        top: prevTop,\n        width: prevWidth,\n        height: prevHeight,\n    } = caculateRect(mat, width, height, n);\n    const posOrigin = caculatePosition(mat, origin, n);\n    const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n    const rectOrigin = [\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\n        rectTop + prevOrigin[1] * rectHeight / prevHeight,\n    ];\n    const offset = [0, 0];\n    let count = 0;\n\n    while (++count < 10) {\n        const inverseBeforeMatrix = invert(beforeMatrix, n);\n        [offset[0], offset[1]] = minus(\n            caculatePosition(inverseBeforeMatrix, rectOrigin, n),\n            caculatePosition(inverseBeforeMatrix, posOrigin, n),\n        );\n        const mat2 = multiplies(\n            n,\n            beforeMatrix,\n            createOriginMatrix(offset, n),\n            absoluteMatrix,\n        );\n        const {\n            left: nextLeft,\n            top: nextTop,\n        } = caculateRect(mat2, width, height, n);\n        const distLeft = nextLeft - rectLeft;\n        const distTop = nextTop - rectTop;\n\n        if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n            break;\n        }\n        rectOrigin[0] -= distLeft;\n        rectOrigin[1] -= distTop;\n    }\n    return offset.map(p => Math.round(p));\n}\nexport function caculateMoveablePosition(matrix: number[], origin: number[], width: number, height: number): [\n    number[],\n    number[],\n    number[],\n    number[],\n    number[],\n    number[],\n    1 | -1,\n] {\n    const is3d = matrix.length === 16;\n    const n = is3d ? 4 : 3;\n    let [\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n    ] = caculatePoses(matrix, width, height, n);\n    let [originX, originY] = caculatePosition(matrix, origin, n);\n\n    const left = Math.min(x1, x2, x3, x4);\n    const top = Math.min(y1, y2, y3, y4);\n    const right = Math.max(x1, x2, x3, x4);\n    const bottom = Math.max(y1, y2, y3, y4);\n\n    x1 = (x1 - left) || 0;\n    x2 = (x2 - left) || 0;\n    x3 = (x3 - left) || 0;\n    x4 = (x4 - left) || 0;\n\n    y1 = (y1 - top) || 0;\n    y2 = (y2 - top) || 0;\n    y3 = (y3 - top) || 0;\n    y4 = (y4 - top) || 0;\n\n    originX = (originX - left) || 0;\n    originY = (originY - top) || 0;\n\n    const center = [\n        (x1 + x2 + x3 + x4) / 4,\n        (y1 + y2 + y3 + y4) / 4,\n    ];\n    const pos1Rad = getRad(center, [x1, y1]);\n    const pos2Rad = getRad(center, [x2, y2]);\n    const direction =\n        (pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI) || (pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI)\n            ? 1 : -1;\n\n    return [\n        [left, top, right, bottom],\n        [originX, originY],\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n        direction,\n    ];\n}\n\nexport function getLineStyle(pos1: number[], pos2: number[]) {\n    const distX = pos2[0] - pos1[0];\n    const distY = pos2[1] - pos1[1];\n    const width = Math.sqrt(distX * distX + distY * distY);\n    const rad = getRad(pos1, pos2);\n\n    return {\n        transform: `translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad)`,\n        width: `${width}px`,\n    };\n}\nexport function getControlTransform(rotation: number, ...poses: number[][]) {\n    const length = poses.length;\n\n    const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n    const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n    return {\n        transform: `translate(${x}px, ${y}px) rotate(${rotation}deg)`,\n    };\n}\nexport function getCSSSize(target: SVGElement | HTMLElement) {\n    const style = window.getComputedStyle(target);\n\n    return [\n        parseFloat(style.width!),\n        parseFloat(style.height!),\n    ];\n}\nexport function getSize(\n    target: SVGElement | HTMLElement,\n    style: CSSStyleDeclaration = window.getComputedStyle(target),\n    isOffset?: boolean,\n    isBoxSizing: boolean = isOffset || style.boxSizing === \"border-box\",\n) {\n    let width = (target as HTMLElement).offsetWidth;\n    let height = (target as HTMLElement).offsetHeight;\n    const hasOffset = !isUndefined(width);\n\n    if ((isOffset || isBoxSizing) && hasOffset) {\n        return [width, height];\n    }\n    width = target.clientWidth;\n    height = target.clientHeight;\n\n    if (!hasOffset && !width && !height) {\n        const bbox = (target as SVGGraphicsElement).getBBox();\n\n        return [bbox.width, bbox.height];\n    }\n    if (isOffset || isBoxSizing) {\n        const borderLeft = parseFloat(style.borderLeftWidth!) || 0;\n        const borderRight = parseFloat(style.borderRightWidth!) || 0;\n        const borderTop = parseFloat(style.borderTopWidth!) || 0;\n        const borderBottom = parseFloat(style.borderBottomWidth!) || 0;\n\n        return [\n            width + borderLeft + borderRight,\n            height + borderTop + borderBottom,\n        ];\n    } else {\n        const paddingLeft = parseFloat(style.paddingLeft!) || 0;\n        const paddingRight = parseFloat(style.paddingRight!) || 0;\n        const paddingTop = parseFloat(style.paddingTop!) || 0;\n        const paddingBottom = parseFloat(style.paddingBottom!) || 0;\n\n        return [\n            width - paddingLeft - paddingRight,\n            height - paddingTop - paddingBottom,\n        ];\n    }\n}\nexport function getRotationRad(\n    poses: number[][],\n    direction: number,\n) {\n    return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\nexport function getTargetInfo(\n    target?: HTMLElement | SVGElement,\n    container?: HTMLElement | SVGElement | null,\n    parentContainer?: HTMLElement | SVGElement | null,\n    state?: Partial<MoveableManagerState> | false | undefined,\n): Partial<MoveableManagerState> {\n    let left = 0;\n    let top = 0;\n    let right = 0;\n    let bottom = 0;\n    let origin = [0, 0];\n    let pos1 = [0, 0];\n    let pos2 = [0, 0];\n    let pos3 = [0, 0];\n    let pos4 = [0, 0];\n    let offsetMatrix = createIdentityMatrix3();\n    let beforeMatrix = createIdentityMatrix3();\n    let matrix = createIdentityMatrix3();\n    let targetMatrix = createIdentityMatrix3();\n    let width = 0;\n    let height = 0;\n    let transformOrigin = [0, 0];\n    let direction: 1 | -1 = 1;\n    let beforeDirection: 1 | -1 = 1;\n    let is3d = false;\n    let targetTransform = \"\";\n    let beforeOrigin = [0, 0];\n    let clientRect = { left: 0, right: 0, top: 0, bottom: 0, width: 0, height: 0 };\n    let containerRect = { left: 0, right: 0, top: 0, bottom: 0, width: 0, height: 0 };\n    let rotation = 0;\n\n    const prevMatrix = state ? state.beforeMatrix : undefined;\n    const prevN = state ? (state.is3d ? 4 : 3) : undefined;\n\n    if (target) {\n        if (state) {\n            width = state.width!;\n            height = state.height!;\n        } else {\n            const style = getComputedStyle(target);\n\n            width = (target as HTMLElement).offsetWidth;\n            height = (target as HTMLElement).offsetHeight;\n\n            if (isUndefined(width)) {\n                [width, height] = getSize(target, style, true);\n            }\n        }\n        [\n            beforeMatrix, offsetMatrix, matrix,\n            targetMatrix,\n            targetTransform, transformOrigin, is3d,\n        ] = caculateMatrixStack(target, container!, prevMatrix, prevN);\n\n        [\n            [left, top, right, bottom],\n            origin,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            direction,\n        ] = caculateMoveablePosition(matrix, transformOrigin, width, height);\n\n        const n = is3d ? 4 : 3;\n        let beforePos = [0, 0];\n\n        [\n            beforePos, beforeOrigin, , , , , beforeDirection,\n        ] = caculateMoveablePosition(offsetMatrix, plus(transformOrigin, getOrigin(targetMatrix, n)), width, height);\n\n        beforeOrigin = [\n            beforeOrigin[0] + beforePos[0] - left,\n            beforeOrigin[1] + beforePos[1] - top,\n        ];\n\n        clientRect = getClientRect(target);\n        containerRect = getClientRect(\n            getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body,\n        );\n        rotation = getRotationRad([pos1, pos2], direction);\n    }\n\n    return {\n        rotation,\n        containerRect,\n        beforeDirection,\n        direction,\n        target,\n        left,\n        top,\n        right,\n        bottom,\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n        width,\n        height,\n        beforeMatrix,\n        matrix,\n        targetTransform,\n        offsetMatrix,\n        targetMatrix,\n        is3d,\n        beforeOrigin,\n        origin,\n        transformOrigin,\n        clientRect,\n    };\n}\nexport function getClientRect(el: HTMLElement | SVGElement) {\n    const { left, width, top, bottom, right, height } = el.getBoundingClientRect();\n\n    return {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height,\n    };\n}\nexport function getDirection(target: SVGElement | HTMLElement) {\n    if (!target) {\n        return;\n    }\n    const direciton = target.getAttribute(\"data-direction\")!;\n\n    if (!direciton) {\n        return;\n    }\n    const dir = [0, 0];\n\n    (direciton.indexOf(\"w\") > -1) && (dir[0] = -1);\n    (direciton.indexOf(\"e\") > -1) && (dir[0] = 1);\n    (direciton.indexOf(\"n\") > -1) && (dir[1] = -1);\n    (direciton.indexOf(\"s\") > -1) && (dir[1] = 1);\n\n    return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n    return [\n        plus(dist, poses[0]),\n        plus(dist, poses[1]),\n        plus(dist, poses[2]),\n        plus(dist, poses[3]),\n    ];\n}\nexport function getAbsolutePosesByState({\n    left,\n    top,\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n}: {\n    left: number,\n    top: number,\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n}) {\n    return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\nexport function throttle(num: number, unit: number) {\n    if (!unit) {\n        return num;\n    }\n    return Math.round(num / unit) * unit;\n}\nexport function throttleArray(nums: number[], unit: number) {\n    nums.forEach((_, i) => {\n        nums[i] = throttle(nums[i], unit);\n    });\n    return nums;\n}\n\nexport function unset(self: any, name: string) {\n    if (self[name]) {\n        self[name].unset();\n        self[name] = null;\n    }\n}\n\nexport function getOrientationDirection(pos: number[], pos1: number[], pos2: number[]) {\n    return (pos[0] - pos1[0]) * (pos2[1] - pos1[1]) - (pos[1] - pos1[1]) * (pos2[0] - pos1[0]);\n}\nexport function isInside(pos: number[], pos1: number[], pos2: number[], pos3: number[], pos4: number[]) {\n    const k1 = getOrientationDirection(pos, pos1, pos2);\n    const k2 = getOrientationDirection(pos, pos2, pos4);\n    const k3 = getOrientationDirection(pos, pos4, pos1);\n\n    const k4 = getOrientationDirection(pos, pos2, pos4);\n    const k5 = getOrientationDirection(pos, pos4, pos3);\n    const k6 = getOrientationDirection(pos, pos3, pos2);\n    const signs1 = [k1, k2, k3];\n    const signs2 = [k4, k5, k6];\n\n    if (\n        signs1.every(sign => sign >= 0)\n        || signs1.every(sign => sign <= 0)\n        || signs2.every(sign => sign >= 0)\n        || signs2.every(sign => sign <= 0)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nexport function fillParams<T extends IObject<any>>(\n    moveable: MoveableManager,\n    e: any,\n    params: Pick<T, Exclude<keyof T, \"target\" | \"clientX\" | \"clientY\" | \"inputEvent\" | \"datas\" | \"currentTarget\">>,\n): T {\n    const datas = e.datas;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    return {\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        datas: datas.datas,\n    } as any;\n}\n\nexport function triggerEvent<T extends IObject<any>, U extends keyof T>(\n    moveable: MoveableManager<T>,\n    name: U & string,\n    params: T[U] extends ((e: infer P) => any) | undefined ? P : {},\n): any {\n    return moveable.triggerEvent(name, params);\n}\n\nexport function getComputedStyle(el: HTMLElement | SVGElement, pseudoElt?: string | null) {\n    return window.getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(ables: Able[], methods: Array<keyof Able>) {\n    const enabledAbles: IObject<boolean> = {};\n    const ableGroups: IObject<boolean> = {};\n\n    return ables.filter(able => {\n        const name = able.name;\n\n        if (enabledAbles[name] || !methods.some(method => able[method])) {\n            return false;\n        }\n        if (able.ableGroup) {\n            if (ableGroups[name]) {\n                return false;\n            }\n            ableGroups[name] = true;\n        }\n        enabledAbles[name] = true;\n        return true;\n    });\n}\n\nexport function getKeepRatioHeight(width: number, isWidth: boolean, ratio: number) {\n    return width * (isWidth ? ratio : 1 / ratio);\n}\nexport function getKeepRatioWidth(height: number, isWidth: boolean, ratio: number) {\n    return height * (isWidth ? 1 / ratio : ratio);\n}\n\nexport function equals(a1: any, a2: any) {\n    if (a1 === a2) {\n        return true;\n    } else if (a1 == null && a2 == null) {\n        return true;\n    } else {\n        return false;\n    }\n}\n","import MoveableManager from \"../MoveableManager\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport function triggerRenderStart(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent(moveable, `onRender${eventAffix}Start`, params);\n}\nexport function triggerRender(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent(moveable, `onRender${eventAffix}`, params);\n}\nexport function triggerRenderEnd(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.sPinch,\n        isDrag: e.isDrag,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent(moveable, `onRender${eventAffix}End`, params);\n}\n","import MoveableManager from \"./MoveableManager\";\nimport Dragger, { OnDragStart, OnDrag, OnDragEnd, OnPinchEnd } from \"@daybrush/drag\";\nimport { Able } from \"./types\";\nimport { IObject } from \"@daybrush/utils\";\nimport { triggerRenderStart, triggerRenderEnd, triggerRender } from \"./ables/triggerRender\";\n\nfunction triggerAble<T extends IObject<any>>(\n    moveable: MoveableManager<any>,\n    ableType: string,\n    eventOperation: string,\n    eventAffix: string,\n    eventType: any,\n    e: OnDragStart | OnDrag | OnDragEnd | OnPinchEnd,\n) {\n    const isStart = eventType === \"Start\";\n\n    if (isStart && eventAffix.indexOf(\"Control\") > -1 && moveable.areaElement === e.inputEvent.target) {\n        return false;\n    }\n    const eventName = `${eventOperation}${eventAffix}${eventType}`;\n    const conditionName = `${eventOperation}${eventAffix}Condition`;\n    const isEnd = eventType === \"End\";\n    const isAfter = eventType.indexOf(\"After\") > -1;\n\n    if (isStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n    const isGroup = eventAffix.indexOf(\"Group\") > -1;\n    const ables: Array<Able<T>> = (moveable as any)[ableType];\n    const results = ables.filter((able: any) => {\n        const condition = isStart && able[conditionName];\n\n        if (able[eventName] && (!condition || condition(e.inputEvent.target, moveable))) {\n            return able[eventName](moveable, e);\n        }\n        return false;\n    });\n    const isUpdate = results.length;\n\n    if (isStart) {\n        triggerRenderStart(moveable, isGroup, e);\n    } else if (isEnd) {\n        triggerRenderEnd(moveable, isGroup, e);\n    } else if (isUpdate) {\n        triggerRender(moveable, isGroup, e);\n    }\n    if (isEnd) {\n        moveable.state.dragger = null;\n    }\n    if (!isStart && isUpdate) {\n        if (results.some(able => able.updateRect) && !isGroup) {\n            moveable.updateRect(eventType, false, false);\n        } else {\n            moveable.updateRect(eventType, true, false);\n        }\n    }\n    if ((!isStart && isUpdate) || (isEnd && !isUpdate)) {\n        moveable.forceUpdate();\n    }\n    if (!isStart && !isEnd && !isAfter && isUpdate) {\n        triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n    }\n}\nexport function getAbleDragger<T>(\n    moveable: MoveableManager<T>,\n    target: HTMLElement | SVGElement,\n    ableType: string,\n    eventAffix: string,\n) {\n    const options: IObject<any> = {\n        container: window,\n        pinchThreshold: moveable.props.pinchThreshold,\n    };\n    [\"drag\", \"pinch\"].forEach(eventOperation => {\n        [\"Start\", \"\", \"End\"].forEach(eventType => {\n            options[`${eventOperation}${eventType.toLowerCase()}`]\n                = (e: any) => triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n        });\n    });\n\n    return new Dragger(target!, options);\n}\n","import * as React from \"react\";\nimport { MOVEABLE_CSS, PREFIX } from \"./consts\";\nimport {\n    prefix, getLineStyle,\n    getTargetInfo,\n    unset,\n    createIdentityMatrix3,\n    isInside,\n    getAbsolutePosesByState,\n    getRect,\n    filterAbles,\n    equals,\n} from \"./utils\";\nimport styler from \"react-css-styler\";\nimport Dragger from \"@daybrush/drag\";\nimport { ref } from \"framework-utils\";\nimport { MoveableManagerProps, MoveableManagerState, Able, RectInfo } from \"./types\";\nimport { getAbleDragger } from \"./getAbleDragger\";\nimport CustomDragger from \"./CustomDragger\";\n\nconst ControlBoxElement = styler(\"div\", MOVEABLE_CSS);\n\nfunction renderLine(direction: string, pos1: number[], pos2: number[], index: number) {\n    return <div key={`line${index}`} className={prefix(\"line\", \"direction\", direction)}\n        data-direction={direction} style={getLineStyle(pos1, pos2)}></div>;\n}\nexport default class MoveableManager<T = {}, U = {}>\n    extends React.PureComponent<MoveableManagerProps<T>, MoveableManagerState<U>> {\n    public static defaultProps: Required<MoveableManagerProps> = {\n        target: null,\n        container: null,\n        origin: true,\n        keepRatio: false,\n        edge: false,\n        parentMoveable: null,\n        parentPosition: null,\n        ables: [],\n        pinchThreshold: 20,\n        dragArea: false,\n        transformOrigin: \"\",\n        className: \"\",\n    };\n    public state: MoveableManagerState<U> = {\n        conatainer: null,\n        target: null,\n        beforeMatrix: createIdentityMatrix3(),\n        matrix: createIdentityMatrix3(),\n        targetMatrix: createIdentityMatrix3(),\n        targetTransform: \"\",\n        is3d: false,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n        transformOrigin: [0, 0],\n        direction: 1,\n        beforeDirection: 1,\n        beforeOrigin: [0, 0],\n        origin: [0, 0],\n        pos1: [0, 0],\n        pos2: [0, 0],\n        pos3: [0, 0],\n        pos4: [0, 0],\n        clientRect: { left: 0, top: 0, bottom: 0, right: 0, width: 0, height: 0 },\n        containerRect: { left: 0, top: 0, bottom: 0, right: 0, width: 0, height: 0 },\n        rotation: 0,\n    } as any;\n    public targetAbles: Array<Able<T>> = [];\n    public controlAbles: Array<Able<T>> = [];\n    public controlBox!: typeof ControlBoxElement extends new (...args: any[]) => infer K ? K : never;\n    public areaElement!: HTMLElement;\n    public targetDragger!: Dragger;\n    public controlDragger!: Dragger;\n    public customDragger!: CustomDragger;\n\n    public render() {\n        const { edge, parentPosition, className } = this.props;\n\n        this.checkUpdate();\n\n        const { left: parentLeft, top: parentTop } = parentPosition! || { left: 0, top: 0 };\n        const { left, top, pos1, pos2, pos3, pos4, target, direction } = this.state;\n\n        return (\n            <ControlBoxElement\n                ref={ref(this, \"controlBox\")}\n                className={`${prefix(\"control-box\", direction === -1 ? \"reverse\" : \"\")} ${className}`} style={{\n                    position: \"absolute\",\n                    display: target ? \"block\" : \"none\",\n                    transform: `translate(${left - parentLeft}px, ${top - parentTop}px) translateZ(50px)`,\n                }}>\n                {this.renderAbles()}\n                {renderLine(edge ? \"n\" : \"\", pos1, pos2, 0)}\n                {renderLine(edge ? \"e\" : \"\", pos2, pos4, 1)}\n                {renderLine(edge ? \"w\" : \"\", pos1, pos3, 2)}\n                {renderLine(edge ? \"s\" : \"\", pos3, pos4, 3)}\n            </ControlBoxElement>\n        );\n    }\n    public componentDidMount() {\n        this.controlBox.getElement();\n        const props = this.props;\n        const { parentMoveable, container } = props;\n\n        this.updateEvent(props);\n        if (!container && !parentMoveable) {\n            this.updateRect(\"End\", false, true);\n        }\n    }\n    public componentDidUpdate(prevProps: MoveableManagerProps<T>) {\n        this.updateEvent(prevProps);\n    }\n    public componentWillUnmount() {\n        unset(this, \"targetDragger\");\n        unset(this, \"controlDragger\");\n    }\n    public getContainer(): HTMLElement | SVGElement {\n        const { parentMoveable, container } = this.props;\n\n        return container!\n            || (parentMoveable && parentMoveable.getContainer())\n            || this.controlBox.getElement().parentElement!;\n    }\n    public isMoveableElement(target: HTMLElement | SVGElement) {\n        return target && ((target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1);\n    }\n    public dragStart(e: MouseEvent | TouchEvent) {\n        if (this.targetDragger) {\n            this.targetDragger.onDragStart(e);\n        }\n    }\n    public isInside(clientX: number, clientY: number) {\n        const { pos1, pos2, pos3, pos4, target } = this.state;\n\n        if (!target) {\n            return false;\n        }\n        const { left, top } = target.getBoundingClientRect();\n        const pos = [clientX - left, clientY - top];\n\n        return isInside(pos, pos1, pos2, pos4, pos3);\n    }\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        const parentMoveable = this.props.parentMoveable;\n        const state = this.state;\n        const target = (state.target || this.props.target) as HTMLElement | SVGElement;\n        const container = this.getContainer();\n        this.updateState(\n            getTargetInfo(target, container, container, isTarget ? state : undefined),\n            parentMoveable ? false : isSetState,\n        );\n    }\n    public updateEvent(prevProps: MoveableManagerProps<T>) {\n        const controlBoxElement = this.controlBox.getElement();\n        const hasTargetAble = this.targetAbles.length;\n        const hasControlAble = this.controlAbles.length;\n        const target = this.props.target;\n        const prevTarget = prevProps.target;\n        const dragArea = this.props.dragArea;\n        const prevDragArea = prevProps.dragArea;\n        const isTargetChanged = !dragArea && prevTarget !== target;\n        const isUnset = (!hasTargetAble && this.targetDragger)\n            || isTargetChanged\n            || prevDragArea !== dragArea;\n\n        if (isUnset) {\n            unset(this, \"targetDragger\");\n            this.updateState({ dragger: null });\n        }\n        if (!hasControlAble) {\n            unset(this, \"controlDragger\");\n        }\n\n        if (target && hasTargetAble && !this.targetDragger) {\n            if (dragArea) {\n                this.targetDragger = getAbleDragger(this, this.areaElement!, \"targetAbles\", \"\");\n            } else {\n                this.targetDragger = getAbleDragger(this, target!, \"targetAbles\", \"\");\n            }\n        }\n        if (!this.controlDragger && hasControlAble) {\n            this.controlDragger = getAbleDragger(this, controlBoxElement, \"controlAbles\", \"Control\");\n        }\n        if (isUnset) {\n            this.unsetAbles();\n        }\n    }\n    public updateTarget(type?: \"Start\" | \"\" | \"End\") {\n        this.updateRect(type, true);\n    }\n    public getRect(): RectInfo {\n        const state = this.state;\n        const poses = getAbsolutePosesByState(this.state);\n        const [pos1, pos2, pos3, pos4] = poses;\n        const rect = getRect(poses);\n        const {\n            width: offsetWidth,\n            height: offsetHeight,\n        } = state;\n        const {\n            width,\n            height,\n            left,\n            top,\n        } = rect;\n        return {\n            width,\n            height,\n            left,\n            top,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            offsetWidth,\n            offsetHeight,\n        };\n    }\n    public checkUpdate() {\n        const { target, container, parentMoveable } = this.props;\n        const {\n            target: stateTarget,\n            container: stateContainer,\n        } = this.state;\n\n        if (!stateTarget && !target) {\n            return;\n        }\n        this.updateAbles();\n\n        const isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n\n        if (!isChanged) {\n            return;\n        }\n\n        this.updateState({ target, container });\n\n        if (!parentMoveable && (container || this.controlBox)) {\n            this.updateRect(\"End\", false, false);\n        }\n    }\n    public triggerEvent(name: string, e: any): any {\n        const callback = (this.props as any)[name];\n\n        return callback && callback(e);\n    }\n    protected unsetAbles() {\n        if (this.targetAbles.filter(able => {\n            if (able.unset) {\n                able.unset(this);\n                return true;\n            }\n            return false;\n        }).length) {\n            this.forceUpdate();\n        }\n    }\n    protected updateAbles(\n        ables: Able[] = this.props.ables!,\n        eventAffix: string = \"\",\n    ) {\n        const props = this.props as any;\n\n        const enabledAbles = ables!.filter(able => able && props[able.name]);\n\n        const dragStart = `drag${eventAffix}Start` as \"dragStart\";\n        const pinchStart = `pinch${eventAffix}Start` as \"pinchStart\";\n        const dragControlStart = `drag${eventAffix}ControlStart` as \"dragControlStart\";\n\n        const targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart]);\n        const controlAbles = filterAbles(enabledAbles, [dragControlStart]);\n\n        this.targetAbles = targetAbles;\n        this.controlAbles = controlAbles;\n    }\n    protected updateState(nextState: any, isSetState?: boolean) {\n        if (isSetState) {\n            this.setState(nextState);\n        } else {\n            const state = this.state as any;\n\n            for (const name in nextState) {\n                state[name] = nextState[name];\n            }\n        }\n    }\n    protected renderAbles() {\n        const props = this.props as any;\n        const ables: Able[] = props.ables!;\n        const enabledAbles = ables.filter(able => able && props[able.name]);\n        return filterAbles(enabledAbles, [\"render\"]).map(({ render }) => render!(this, React));\n    }\n}\n","import { Client } from \"@daybrush/drag\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { PinchableProps, Able, SnappableState, OnPinchStart, OnPinch, OnPinchEnd } from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { getRad } from \"@moveable/matrix\";\n\nfunction getRotatiion(touches: Client[]) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\n\nexport default {\n    name: \"pinchable\",\n    updateRect: true,\n    pinchStart(\n        moveable: MoveableManager<PinchableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, touches, inputEvent, targets } = e;\n        const { pinchable, ables } = moveable.props;\n\n        if (!pinchable) {\n            return false;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlStart` as \"dragControlStart\";\n\n        const pinchAbles = (pinchable === true ? moveable.controlAbles : ables!.filter(able => {\n            return pinchable.indexOf(able.name as any) > -1;\n        })).filter(able => able.canPinch && able[controlEventName]);\n\n        const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const result = triggerEvent(moveable, eventName, params);\n\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n\n        const isPinch = datas.isPinch;\n\n        if (!isPinch) {\n            return false;\n        }\n        const parentRotate = getRotatiion(touches);\n\n        pinchAbles.forEach(able => {\n            datas[able.name + \"Datas\"] = {};\n            const ableEvent: any = {\n                datas: datas[able.name + \"Datas\"],\n                clientX,\n                clientY,\n                inputEvent,\n                parentRotate,\n                pinchFlag: true,\n            };\n            able[controlEventName]!(moveable, ableEvent);\n        });\n\n        moveable.state.snapDirection = [0, 0];\n        return isPinch;\n    },\n    pinch(\n        moveable: MoveableManager<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, scale: pinchScale, distance, touches, inputEvent, targets } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const parentRotate = getRotatiion(touches);\n        const parentDistance = distance * (1 - 1 / pinchScale);\n        const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n        triggerEvent(moveable, eventName, params);\n\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}Control` as \"dragControl\";\n\n        ables.forEach(able => {\n            able[controlEventName]!(moveable, {\n                clientX,\n                clientY,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                parentDistance,\n                parentRotate,\n                pinchFlag: true,\n            } as any);\n        });\n        return params;\n    },\n    pinchEnd(\n        moveable: MoveableManager<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, isPinch, inputEvent, targets } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n        const params = fillParams<OnPinchEnd>(moveable, e, { isDrag: isPinch }) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlEnd` as \"dragControlEnd\";\n\n        ables.forEach(able => {\n            able[controlEventName]!(moveable, {\n                clientX,\n                clientY,\n                isDrag: isPinch,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                pinchFlag: true,\n            } as any);\n        });\n        return isPinch;\n    },\n    pinchGroupStart(moveable: MoveableGroup, e: any) {\n        return this.pinchStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroup(moveable: MoveableGroup, e: any) {\n        return this.pinch(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroupEnd(moveable: MoveableGroup, e: any) {\n        return this.pinchEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n","import MoveableGroup from \"./MoveableGroup\";\nimport { Able } from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport { hasClass, IObject, isFunction } from \"@daybrush/utils\";\nimport { prefix } from \"./utils\";\n\nexport function triggerChildAble<T extends Able>(\n    moveable: MoveableGroup,\n    able: T,\n    type: keyof T & string,\n    datas: IObject<any>,\n    eachEvent: ((movebale: MoveableManager, datas: IObject<any>) => any) | IObject<any>,\n    callback?: (moveable: MoveableManager<any>, datas: IObject<any>, result: any, index: number) => any,\n) {\n    const name = able.name!;\n    const ableDatas = datas[name] || (datas[name] = []);\n    const isEnd = !!type.match(/End$/g);\n    const childs = moveable.moveables.map((child, i) => {\n        const childDatas = ableDatas[i] || (ableDatas[i] = {});\n\n        const childEvent = isFunction(eachEvent) ? eachEvent(child, childDatas) : eachEvent;\n        const result = (able as any)[type]!(child,  { ...childEvent, datas: childDatas, parentFlag: true });\n\n        result && callback && callback(child, childDatas, result, i);\n\n        if (isEnd) {\n            child.state.dragger = null;\n        }\n        return result;\n    });\n\n    return childs;\n}\nexport function directionCondition(target: HTMLElement | SVGElement) {\n    return hasClass(target, prefix(\"direction\"));\n}\n","import {\n    invert, caculate, minus, plus,\n    convertPositionMatrix, average,\n    createScaleMatrix, multiply,\n} from \"@moveable/matrix\";\nimport MoveableManager from \"./MoveableManager\";\nimport { caculatePoses, getAbsoluteMatrix, getAbsolutePosesByState } from \"./utils\";\nimport { splitUnit } from \"@daybrush/utils\";\nimport { MoveableManagerState, GroupableProps, ResizableProps } from \"./types\";\n\nexport function setDragStart(moveable: MoveableManager<any>, { datas }: any) {\n    const {\n        matrix,\n        beforeMatrix,\n        is3d,\n        left,\n        top,\n        origin,\n        offsetMatrix,\n        targetMatrix,\n        transformOrigin,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n\n    datas.is3d = is3d;\n    datas.matrix = matrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = invert(matrix, n);\n    datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n    datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n    datas.startDragBeforeDist = caculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = caculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        inverseBeforeMatrix,\n        inverseMatrix, is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        caculate(\n            isBefore ? inverseBeforeMatrix : inverseMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        isBefore ? startDragBeforeDist : startDragDist,\n    );\n}\nexport function caculateTransformOrigin(\n    transformOrigin: string[],\n    width: number,\n    height: number,\n    prevWidth: number = width,\n    prevHeight: number = height,\n    prevOrigin: number[] = [0, 0],\n) {\n\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map((pos, i) => {\n        const { value, unit } = splitUnit(pos);\n\n        const prevSize = (i ? prevHeight : prevWidth);\n        const size = (i ? height : width);\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n\n            const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\nexport function getPosIndexesByDirection(direction: number[]) {\n    const indexes: number[] = [];\n\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nexport function getPosesByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n   return getPosIndexesByDirection(direction).map(index => poses[index]);\n}\nexport function getPosByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n   const nextPoses = getPosesByDirection(poses, direction);\n\n   return [\n       average(...nextPoses.map(pos => pos[0])),\n       average(...nextPoses.map(pos => pos[1])),\n   ];\n}\nexport function getPosByReverseDirection(\n    [pos1, pos2, pos3, pos4]: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)\n    [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)\n    [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)\n    */\n\n    return getPosByDirection([pos4, pos3, pos2, pos1], direction);\n}\nfunction getStartPos(poses: number[][], direction: number[]) {\n    const [\n        startPos1,\n        startPos2,\n        startPos3,\n        startPos4,\n    ] = poses;\n    return getPosByReverseDirection([startPos1, startPos2, startPos3, startPos4], direction);\n}\nfunction getDist(\n    startPos: number[],\n    matrix: number[],\n    width: number,\n    height: number,\n    n: number,\n    direction: number[],\n) {\n    const poses = caculatePoses(matrix, width, height, n);\n    const pos = getPosByReverseDirection(poses, direction);\n    const distX = startPos[0] - pos[0];\n    const distY = startPos[1] - pos[1];\n\n    return [distX, distY];\n}\nexport function getNextMatrix(\n    offsetMatrix: number[],\n    targetMatrix: number[],\n    origin: number[],\n    n: number,\n) {\n    return multiply(\n        offsetMatrix,\n        getAbsoluteMatrix(targetMatrix, n, origin),\n        n,\n    );\n}\nexport function scaleMatrix(\n    state: MoveableManagerState<any>,\n    scale: number[],\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n        targetMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    return getNextMatrix(\n        offsetMatrix,\n        multiply(targetMatrix, createScaleMatrix(scale, n), n),\n        transformOrigin,\n        n,\n    );\n}\nexport function getScaleDist(\n    moveable: MoveableManager<any>,\n    scale: number[],\n    direction: number[],\n    dragClient?: number[],\n) {\n    const state = moveable.state;\n    const {\n        is3d,\n        left,\n        top,\n        width,\n        height,\n    } = state;\n\n    const n = is3d ? 4 : 3;\n    const groupable = moveable.props.groupable;\n    const nextMatrix = scaleMatrix(moveable.state, scale);\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n\n    const startPos = dragClient ? dragClient : getStartPos(getAbsolutePosesByState(moveable.state), direction);\n\n    const dist = getDist(\n        startPos, nextMatrix, width, height, n,\n        direction,\n    );\n\n    return minus(dist, [groupLeft, groupTop]);\n}\n\nexport function getResizeDist(\n    moveable: MoveableManager<GroupableProps>,\n    width: number,\n    height: number,\n    // prevWidth: number,\n    // prevHeight: number,\n    direction: number[],\n    fixedPosition: number[],\n    transformOrigin: string[],\n) {\n    const {\n        groupable,\n    } = moveable.props;\n    const {\n        transformOrigin: prevOrigin,\n        targetMatrix,\n        offsetMatrix,\n        is3d,\n        width: prevWidth,\n        height: prevHeight,\n        left,\n        top,\n    } = moveable.state;\n\n    const n = is3d ? 4 : 3;\n    const nextOrigin = caculateTransformOrigin(\n        transformOrigin!,\n        width,\n        height,\n        prevWidth,\n        prevHeight,\n        prevOrigin,\n    );\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getStartDirection(\n    moveable: MoveableManager<ResizableProps>,\n    direction: number[],\n) {\n    const {\n        baseDirection = [-1, -1],\n    } = moveable.props;\n    return [\n        direction[0] ? direction[0] : baseDirection[0] * -1,\n        direction[1] ? direction[1] : baseDirection[1] * -1,\n    ];\n}\nexport function getFixedPosition(\n    moveable: MoveableManager<ResizableProps>,\n    direction: number[],\n) {\n    return getStartPos(getAbsolutePosesByState(moveable.state), direction);\n}\n","import MoveableManager from \"../MoveableManager\";\nimport { Renderer, SnappableProps, SnappableState, Guideline, SnapInfo, BoundInfo, ScalableProps } from \"../types\";\nimport { prefix, caculatePoses, getRect, getAbsolutePosesByState, getAbsolutePoses } from \"../utils\";\nimport { directionCondition } from \"../groupUtils\";\nimport { isUndefined, IObject } from \"@daybrush/utils\";\nimport {\n    getPosByReverseDirection, getPosesByDirection,\n    getDragDist, scaleMatrix, getPosByDirection,\n} from \"../DraggerUtils\";\nimport { minus } from \"@moveable/matrix\";\n\nfunction snapStart(moveable: MoveableManager<SnappableProps, SnappableState>) {\n    const state = moveable.state;\n    if (state.guidelines && state.guidelines.length) {\n        return;\n    }\n\n    const {\n        horizontalGuidelines = [],\n        verticalGuidelines = [],\n        elementGuidelines = [],\n        bounds,\n        snapCenter,\n    } = moveable.props;\n\n    if (!bounds && !horizontalGuidelines.length && !verticalGuidelines.length && !elementGuidelines.length) {\n        return;\n    }\n\n    const {\n        containerRect: {\n            width: containerWidth,\n            height: containerHeight,\n            top: containerTop,\n            left: containerLeft,\n        },\n        clientRect: {\n            top: clientTop,\n            left: clientLeft,\n        },\n        left: targetLeft,\n        top: targetTop,\n    } = state;\n\n    const distLeft = targetLeft - (clientLeft - containerLeft);\n    const distTop = targetTop - (clientTop - containerTop);\n    const guidelines: Guideline[] = [];\n\n    horizontalGuidelines!.forEach(pos => {\n        guidelines.push({ type: \"horizontal\", pos: [0, pos], size: containerWidth });\n    });\n    verticalGuidelines!.forEach(pos => {\n        guidelines.push({ type: \"vertical\", pos: [pos, 0], size: containerHeight });\n    });\n    elementGuidelines!.forEach(el => {\n        const rect = el.getBoundingClientRect();\n        const { top, left, width, height } = rect;\n        const elementTop = top - containerTop;\n        const elementBottom = elementTop + height;\n        const elementLeft = left - containerLeft;\n        const elementRight = elementLeft + width;\n\n        guidelines.push({ type: \"vertical\", element: el, pos: [elementLeft + distLeft, elementTop], size: height });\n        guidelines.push({ type: \"vertical\", element: el, pos: [elementRight + distLeft, elementTop], size: height });\n        guidelines.push({ type: \"horizontal\", element: el, pos: [elementLeft, elementTop + distTop], size: width });\n        guidelines.push({ type: \"horizontal\", element: el, pos: [elementLeft, elementBottom + distTop], size: width });\n\n        if (snapCenter) {\n            guidelines.push({\n                type: \"vertical\",\n                element: el,\n                pos: [(elementLeft + elementRight) / 2 + distLeft, elementTop],\n                size: height,\n                center: true,\n            });\n            guidelines.push({\n                type: \"horizontal\",\n                element: el,\n                pos: [elementLeft, (elementTop + elementBottom) / 2 + distTop],\n                size: width,\n                center: true,\n            });\n        }\n    });\n\n    state.guidelines = guidelines;\n    state.enableSnap = true;\n}\nfunction checkBounds(\n    moveable: MoveableManager<SnappableProps>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n    snapThreshold?: number,\n) {\n    return {\n        vertical: checkBound(moveable, verticalPoses, true, snapThreshold),\n        horizontal: checkBound(moveable, horizontalPoses, false, snapThreshold),\n    };\n}\nfunction checkBound(\n    moveable: MoveableManager<SnappableProps>,\n    poses: number[],\n    isVertical: boolean,\n    snapThreshold: number = 0,\n): BoundInfo {\n    const bounds = moveable.props.bounds;\n\n    if (bounds) {\n        const startPos = bounds[isVertical ? \"left\" : \"top\"];\n        const endPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n        const minPos = Math.min(...poses);\n        const maxPos = Math.max(...poses);\n\n        if (!isUndefined(startPos) && startPos + snapThreshold > minPos) {\n            return {\n                isBound: true,\n                offset: minPos - startPos,\n                pos: startPos,\n            };\n        }\n        if (!isUndefined(endPos) && endPos - snapThreshold < maxPos) {\n            return {\n                isBound: true,\n                offset: maxPos - endPos,\n                pos: endPos,\n            };\n        }\n    }\n\n    return {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n}\nfunction checkSnap(\n    guidelines: Guideline[],\n    targetType: \"horizontal\" | \"vertical\",\n    targetPoses: number[],\n    isSnapCenter: boolean | undefined,\n    snapThreshold: number,\n): SnapInfo {\n    if (!guidelines) {\n        return {\n            isSnap: false,\n            dist: -1,\n            offset: 0,\n            guidelines: [],\n            snapPoses: [],\n        };\n    }\n    let snapGuidelines: Guideline[] = [];\n    let snapDist = Infinity;\n    let snapOffset = 0;\n    const isVertical = targetType === \"vertical\";\n    const posType = isVertical ? 0 : 1;\n\n    const snapPoses = targetPoses.filter(targetPos => {\n        return guidelines.filter(guideline => {\n            const { type, pos, center } = guideline;\n\n            if ((!isSnapCenter && center) || type !== targetType) {\n                return false;\n            }\n            const offset = targetPos - pos[posType];\n            const dist = Math.abs(offset);\n\n            if (dist > snapThreshold) {\n                return false;\n            }\n            if (snapDist > dist) {\n                snapDist = dist;\n                snapGuidelines = [];\n            }\n            if (snapDist === dist) {\n                snapOffset = offset;\n                snapGuidelines.push(guideline);\n            }\n            return true;\n        }).length;\n    });\n\n    return {\n        isSnap: !!snapGuidelines.length,\n        dist: isFinite(snapDist) ? snapDist : -1,\n        offset: snapOffset,\n        guidelines: snapGuidelines,\n        snapPoses,\n    };\n}\nexport function hasGuidelines(\n    moveable: MoveableManager<any, any>,\n    ableName: string,\n): moveable is MoveableManager<SnappableProps, SnappableState> {\n    const {\n        props: {\n            snappable,\n            bounds,\n        },\n        state: {\n            guidelines,\n            enableSnap,\n        },\n    } = moveable;\n\n    if (\n        !snappable\n        || !enableSnap\n        || (ableName && snappable !== true && snappable.indexOf(ableName))\n        || (!bounds && (!guidelines || !guidelines.length))\n    ) {\n        return false;\n    }\n    return true;\n}\nexport function checkSnapPoses(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    posesX: number[],\n    posesY: number[],\n    isSnapCenter?: boolean,\n    customSnapThreshold?: number,\n) {\n    const guidelines = moveable.state.guidelines;\n    const snapThreshold = !isUndefined(customSnapThreshold)\n        ? customSnapThreshold\n        : !isUndefined(moveable.props.snapThreshold)\n            ? moveable.props.snapThreshold\n            : 5;\n\n    return {\n        vertical: checkSnap(guidelines, \"vertical\", posesX, isSnapCenter, snapThreshold),\n        horizontal: checkSnap(guidelines, \"horizontal\", posesY, isSnapCenter, snapThreshold),\n    };\n}\nexport function checkSnaps(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    rect: {\n        left?: number,\n        top?: number,\n        bottom?: number,\n        right?: number,\n        center?: number,\n        middle?: number,\n    },\n    isCenter: boolean,\n    customSnapThreshold?: number,\n) {\n    const snapCenter = moveable.props.snapCenter;\n    const isSnapCenter = snapCenter! && isCenter;\n\n    let verticalNames: Array<\"left\" | \"center\" | \"right\"> = [\"left\", \"right\"];\n    let horizontalNames: Array<\"top\" | \"middle\" | \"bottom\"> = [\"top\", \"bottom\"];\n\n    if (isSnapCenter) {\n        verticalNames.push(\"center\");\n        horizontalNames.push(\"middle\");\n    }\n    verticalNames = verticalNames.filter(name => name in rect);\n    horizontalNames = horizontalNames.filter(name => name in rect);\n\n    return checkSnapPoses(\n        moveable,\n        verticalNames.map(name => rect[name]!),\n        horizontalNames.map(name => rect[name]!),\n        isSnapCenter,\n        customSnapThreshold,\n    );\n}\nexport function getSize(x: number, y: number) {\n    return Math.sqrt(x * x + y * y);\n}\nfunction checkBoundOneWayDist(\n    moveable: MoveableManager<any, any>,\n    pos: number[],\n) {\n    const {\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalBoundOffset,\n        },\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalBoundOffset,\n        },\n    } = checkBounds(\n        moveable,\n        [pos[0]],\n        [pos[1]],\n    );\n    if (isHorizontalBound || isVerticalBound) {\n        let isVertical!: boolean;\n\n        if (isHorizontalBound && isVerticalBound) {\n            isVertical = Math.abs(horizontalBoundOffset) < Math.abs(verticalBoundOffset);\n        } else {\n            isVertical = isVerticalBound;\n        }\n        const offset = isVertical ? verticalBoundOffset : horizontalBoundOffset;\n        return {\n            isVertical,\n            offset,\n            dist: Math.abs(offset),\n        };\n    }\n    return;\n}\nfunction solveNextDist(\n    pos1: number[],\n    pos2: number[],\n    offset: number,\n    isVertical: boolean,\n    isDirectionVertical: boolean,\n    datas: IObject<any>,\n) {\n    const sizeOffset = solveEquation(\n        pos1,\n        pos2,\n        -offset,\n        isVertical,\n    );\n\n    if (!sizeOffset) {\n        return NaN;\n    }\n    const [widthDist, heightDist] = getDragDist({\n        datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1],\n    });\n\n    return isDirectionVertical ? heightDist : widthDist;\n}\nfunction getFixedPoses(\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedPos: number[],\n    direction: number[],\n    is3d: boolean,\n) {\n    const nextPoses = caculatePoses(matrix, width, height, is3d ? 4 : 3);\n    const nextPos = getPosByReverseDirection(nextPoses, direction);\n\n    return  getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));\n}\n\nfunction checkBoundOneWayPos(\n    moveable: MoveableManager<any, any>,\n    pos: number[],\n    reversePos: number[],\n    isDirectionVertical: boolean,\n    datas: any,\n) {\n    const {\n        horizontal: {\n            isSnap: isHorizontalSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isSnap: isVerticalSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    } = checkSnapPoses(\n        moveable,\n        [pos[0]],\n        [pos[1]],\n    );\n    const fixedHorizontal = reversePos[1] === pos[1];\n    const fixedVertical = reversePos[0] === pos[0];\n\n    let isVertical!: boolean;\n\n    if (!isHorizontalSnap && !isVerticalSnap) {\n        // no snap\n        return NaN;\n    } else if (isHorizontalSnap && isVerticalSnap) {\n        if (horizontalDist === 0 && fixedHorizontal) {\n            isVertical = true;\n        } else if (verticalOffset === 0 && fixedVertical) {\n            isVertical = false;\n        } else {\n            isVertical = horizontalDist > verticalDist;\n        }\n    } else {\n        isVertical = isVerticalSnap;\n    }\n    return solveNextDist(\n        reversePos, pos,\n        (isVertical ? verticalOffset : horizontalOffset),\n        isVertical,\n        isDirectionVertical,\n        datas,\n    );\n}\nexport function checkOneWayPos(\n    moveable: MoveableManager<any, any>,\n    poses: number[][],\n    reversePoses: number[][],\n    isDirectionVertical: boolean,\n    datas: any,\n) {\n    let posOffset = 0;\n    let boundInfo!: {\n        isVertical: boolean,\n        offset: number,\n        dist: number,\n    } | undefined;\n    let boundIndex = -1;\n    const boundInfos = poses.map(pos => checkBoundOneWayDist(moveable, pos));\n\n    boundInfos.forEach((info, i) => {\n        if (!info) {\n            return;\n        }\n        if (!boundInfo || boundInfo.dist < info.dist) {\n            boundInfo = info;\n            boundIndex = i;\n        }\n    });\n    if (boundInfo) {\n        const nextDist = solveNextDist(\n            reversePoses[boundIndex],\n            poses[boundIndex],\n            boundInfo.offset,\n            boundInfo.isVertical,\n            isDirectionVertical,\n            datas,\n        );\n\n        if (!isNaN(nextDist)) {\n            posOffset = nextDist;\n        }\n    } else  {\n        poses.some((pos, i) => {\n            const nextDist = checkBoundOneWayPos(moveable, pos, reversePoses[i], isDirectionVertical, datas);\n\n            if (isNaN(nextDist)) {\n                return false;\n            }\n            posOffset = nextDist;\n            return true;\n        });\n    }\n    return posOffset;\n}\nexport function checkOneWayDist(\n    moveable: MoveableManager<any, any>,\n    poses: number[][],\n    direction: number[],\n    datas: any,\n) {\n\n    const directionIndex = direction[0] !== 0 ? 0 : 1;\n    const isDirectionVertical = directionIndex > 0;\n    const reversePoses = poses.slice().reverse();\n    let directionPoses!: number[][];\n    let reverseDirectionPoses!: number[][];\n\n    if (moveable.props.keepRatio) {\n        directionPoses = [getPosByDirection(poses, direction)];\n        reverseDirectionPoses = [getPosByDirection(reversePoses, direction)];\n    } else {\n        directionPoses = getPosesByDirection(poses, direction);\n        reverseDirectionPoses = getPosesByDirection(reversePoses, direction);\n\n        directionPoses.push([\n            (directionPoses[0][0] + directionPoses[1][0]) / 2,\n            (directionPoses[0][1] + directionPoses[1][1]) / 2,\n        ]);\n        reverseDirectionPoses.reverse();\n        reverseDirectionPoses.push([\n            (reverseDirectionPoses[0][0] + reverseDirectionPoses[1][0]) / 2,\n            (reverseDirectionPoses[0][1] + reverseDirectionPoses[1][1]) / 2,\n        ]);\n    }\n\n    const posOffset = checkOneWayPos(moveable, directionPoses, reverseDirectionPoses, isDirectionVertical, datas);\n\n    const offset = [0, 0];\n\n    offset[directionIndex] = direction[directionIndex] * posOffset;\n    return offset;\n}\nexport function checkTwoWayDist(\n    moveable: MoveableManager<any, any>,\n    poses: number[][],\n    direction: number[],\n    datas: any,\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedPos: number[],\n    is3d: boolean,\n) {\n    const directionPoses = getPosesByDirection(poses, direction);\n    const verticalDirection = [direction[0], direction[1] * -1];\n    const horizontalDirection = [direction[0] * -1, direction[1]];\n    const verticalPos = getPosByDirection(poses, verticalDirection);\n    const horizontalPos = getPosByDirection(poses, horizontalDirection);\n    const {\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalBoundOffset,\n        },\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalBoundOffset,\n        },\n    } = checkBounds(\n        moveable,\n        [directionPoses[0][0]],\n        [directionPoses[0][1]],\n    );\n\n    // share drag event\n    let widthDist = 0;\n    let heightDist = 0;\n\n    const verticalBoundInfo = checkBoundOneWayDist(moveable, verticalPos);\n    const horizontalBoundInfo = checkBoundOneWayDist(moveable, horizontalPos);\n    const isVeritcalDirectionBound = verticalBoundInfo && verticalBoundInfo.dist > Math.abs(verticalBoundOffset);\n    const isHorizontalDirectionBound\n        = horizontalBoundInfo && horizontalBoundInfo.dist > Math.abs(horizontalBoundOffset);\n\n    if (!isVeritcalDirectionBound && !isHorizontalDirectionBound) {\n        const {\n            horizontal: {\n                offset: horizontalOffset,\n            },\n            vertical: {\n                offset: verticalOffset,\n            },\n        } = checkSnapPoses(\n            moveable,\n            [directionPoses[0][0]],\n            [directionPoses[0][1]],\n        );\n        [widthDist, heightDist] = getDragDist({\n            datas,\n            distX: -(isVerticalBound ? verticalBoundOffset : verticalOffset),\n            distY: -(isHorizontalBound ? horizontalBoundOffset : horizontalOffset),\n        });\n    } else if (isVeritcalDirectionBound) {\n        // left to right, right to left\n        const reversePos = getPosByDirection(poses, [\n            verticalDirection[0] * -1,\n            verticalDirection[1],\n        ]);\n        const nextDist = solveNextDist(\n            reversePos, verticalPos,\n            verticalBoundInfo!.offset, verticalBoundInfo!.isVertical,\n            false, datas,\n        );\n        if (!isNaN(nextDist)) {\n            widthDist = nextDist;\n        }\n        const nextPoses = getFixedPoses(\n            matrix,\n            width + direction[0] * widthDist,\n            height + direction[1] * heightDist,\n            fixedPos,\n            direction,\n            is3d,\n        );\n        heightDist = checkOneWayPos(\n            moveable,\n            [getPosByDirection(nextPoses, direction)],\n            [getPosByDirection(nextPoses, verticalDirection)] ,\n            true,\n            datas,\n        );\n    } else {\n        // top to bottom, bottom to top\n        const reversePos = getPosByDirection(poses, [\n            horizontalDirection[0] * -1,\n            horizontalDirection[1],\n        ]);\n        const nextDist = solveNextDist(\n            reversePos, verticalPos,\n            horizontalBoundInfo!.offset, horizontalBoundInfo!.isVertical,\n            true, datas,\n        );\n        if (!isNaN(nextDist)) {\n            heightDist = nextDist;\n        }\n        const nextPoses = getFixedPoses(\n            matrix,\n            width + direction[0] * widthDist,\n            height + direction[1] * heightDist,\n            fixedPos,\n            direction,\n            is3d,\n        );\n        widthDist = checkOneWayPos(\n            moveable,\n            [getPosByDirection(nextPoses, direction)],\n            [getPosByDirection(nextPoses, horizontalDirection)] ,\n            false,\n            datas,\n        );\n    }\n\n    return [\n        direction[0] * widthDist,\n        direction[1] * heightDist,\n    ];\n}\nexport function checkSizeDist(\n    moveable: MoveableManager<any, any>,\n    matrix: number[],\n    width: number,\n    height: number,\n    direction: number[],\n    snapDirection: number[],\n    datas: any,\n    is3d: boolean,\n) {\n    const poses = getAbsolutePosesByState(moveable.state);\n    const fixedPos = getPosByReverseDirection(poses, snapDirection);\n    const nextPoses = getFixedPoses(matrix, width, height, fixedPos, direction, is3d);\n\n    if (direction[0] && direction[1]) {\n        return checkTwoWayDist(\n            moveable, nextPoses, direction, datas,\n            matrix, width, height, fixedPos, is3d,\n        );\n    } else {\n        return checkOneWayDist(moveable, nextPoses, direction, datas);\n    }\n\n}\nexport function checkSnapSize(\n    moveable: MoveableManager<any, any>,\n    width: number,\n    height: number,\n    direction: number[],\n    datas: any,\n) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [0, 0];\n    }\n    const {\n        matrix,\n        is3d,\n    } = moveable.state;\n    return checkSizeDist(moveable, matrix, width, height, direction, direction, datas, is3d);\n}\nexport function checkSnapScale(\n    moveable: MoveableManager<ScalableProps, any>,\n    scale: number[],\n    direction: number[],\n    snapDirection: number[],\n    datas: any,\n) {\n    const {\n        width,\n        height,\n    } = datas;\n\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [0, 0];\n    }\n    const sizeDist = checkSizeDist(\n        moveable, scaleMatrix(datas, scale),\n        width, height,\n        direction,\n        snapDirection,\n        datas, datas.is3d,\n    );\n\n    return [\n        sizeDist[0] / width,\n        sizeDist[1] / height,\n    ];\n}\nexport function solveEquation(\n    pos1: number[],\n    pos2: number[],\n    snapOffset: number,\n    isVertical: boolean,\n) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [0, snapOffset];\n        }\n        return;\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [snapOffset, 0];\n        }\n        return;\n    }\n    // y = ax + b\n    const a = dy / dx;\n    const b = pos1[1] - a * pos1[0];\n\n    if (isVertical) {\n        // y = a * x + b\n        const y = a * (pos2[0] + snapOffset) + b;\n\n        return [snapOffset, y - pos2[1]];\n    } else {\n        // x = (y - b) / a\n        const x = (pos2[1] + snapOffset - b) / a;\n\n        return [x - pos2[0], snapOffset];\n    }\n}\n\nexport function getSnapInfosByDirection(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    poses: number[][],\n    snapDirection: number[] | true,\n) {\n    if (snapDirection === true) {\n        const rect = getRect(poses);\n\n        (rect as any).middle = (rect.top + rect.bottom) / 2;\n        (rect as any).center = (rect.left + rect.right) / 2;\n\n        return checkSnaps(moveable, rect, true, 1);\n    } else if (!snapDirection[0] && !snapDirection[1]) {\n        const alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n        const nextPoses = [];\n\n        for (let i = 0; i < 4; ++i) {\n            nextPoses.push(alignPoses[i]);\n            poses.push([\n                (alignPoses[i][0] + alignPoses[i + 1][0]) / 2,\n                (alignPoses[i][1] + alignPoses[i + 1][1]) / 2,\n            ]);\n        }\n        return checkSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), true, 1);\n    } else {\n        let nextPoses!: number[][];\n\n        if (moveable.props.keepRatio) {\n            nextPoses = [getPosByDirection(poses, snapDirection)];\n        } else {\n            nextPoses = getPosesByDirection(poses, snapDirection);\n\n            if (nextPoses.length > 1) {\n                nextPoses.push([\n                    (nextPoses[0][0] + nextPoses[1][0]) / 2,\n                    (nextPoses[0][1] + nextPoses[1][1]) / 2,\n                ]);\n            }\n        }\n        return checkSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), true, 1);\n    }\n}\nexport function startCheckSnapDrag(\n    moveable: MoveableManager<any, any>,\n    datas: any,\n) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\nexport function checkSnapDrag(\n    moveable: MoveableManager<any, any>,\n    distX: number,\n    distY: number,\n    datas: any,\n) {\n    const snapVerticalInfo = {\n        isSnap: false,\n        offset: 0,\n    };\n    const snapHorizontalInfo = {\n        isSnap: false,\n        offset: 0,\n    };\n\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [snapVerticalInfo, snapHorizontalInfo];\n    }\n    const poses = getAbsolutePoses(\n        datas.absolutePoses,\n        [distX, distY],\n    );\n    const { left, right, top, bottom } = getRect(poses);\n\n    const snapInfos = checkSnaps(moveable, {\n        left,\n        right,\n        top,\n        bottom,\n        center: (left + right) / 2,\n        middle: (top + bottom) / 2,\n    }, true);\n    const boundInfos = checkBounds(moveable, [left, right], [top, bottom]);\n\n    if (boundInfos.vertical.isBound) {\n        snapVerticalInfo.offset = boundInfos.vertical.offset;\n        snapVerticalInfo.isSnap = true;\n    } else if (snapInfos.vertical.isSnap) {\n        // has vertical guidelines\n        snapVerticalInfo.offset = snapInfos.vertical.offset;\n        snapVerticalInfo.isSnap = true;\n    }\n    if (boundInfos.horizontal.isBound) {\n        snapHorizontalInfo.offset = boundInfos.horizontal.offset;\n        snapHorizontalInfo.isSnap = true;\n    } else if (snapInfos.horizontal.isSnap) {\n        // has horizontal guidelines\n        snapHorizontalInfo.offset = snapInfos.horizontal.offset;\n        snapHorizontalInfo.isSnap = true;\n    }\n\n    return [\n        snapVerticalInfo,\n        snapHorizontalInfo,\n    ];\n}\n\nexport default {\n    name: \"snappable\",\n    render(moveable: MoveableManager<SnappableProps, SnappableState>, React: Renderer): any[] {\n        const {\n            top: targetTop,\n            left: targetLeft,\n            pos1, pos2, pos3, pos4,\n            snapDirection,\n            clientRect,\n            containerRect,\n        } = moveable.state;\n\n        const clientLeft = clientRect.left - containerRect.left;\n        const clientTop = clientRect.top - containerRect.top;\n        const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n\n        if (!snapDirection || !hasGuidelines(moveable, \"\")) {\n            return [];\n        }\n        const poses = getAbsolutePosesByState(moveable.state);\n        const { width, height, top, left, bottom, right } = getRect(poses);\n\n        const {\n            vertical: {\n                guidelines: verticalGuildelines,\n                snapPoses: verticalSnapPoses,\n            },\n            horizontal: {\n                guidelines: horizontalGuidelines,\n                snapPoses: horizontalSnapPoses,\n            },\n        } = getSnapInfosByDirection(moveable, poses, snapDirection);\n\n        const {\n            vertical: {\n                isBound: isVerticalBound,\n                pos: verticalBoundPos,\n            },\n            horizontal: {\n                isBound: isHorizontalBound,\n                pos: horizontalBoundPos,\n            },\n        } = checkBounds(moveable, [left, right], [top, bottom], 1);\n\n        if (isVerticalBound && verticalSnapPoses.indexOf(verticalBoundPos) < 0) {\n            // verticalGuildelines.push({\n            //     type: \"vertical\",\n            //     pos: [verticalBoundPos, top],\n            //     size: height,\n            // });\n            verticalSnapPoses.push(verticalBoundPos);\n        }\n        if (isHorizontalBound && horizontalSnapPoses.indexOf(horizontalBoundPos) < 0) {\n            // horizontalGuidelines.push({\n            //     type: \"horizontal\",\n            //     pos: [left, horizontalBoundPos],\n            //     size: width,\n            // });\n            horizontalSnapPoses.push(horizontalBoundPos);\n        }\n        return [\n            ...verticalSnapPoses.map((pos, i) => {\n                return <div className={prefix(\n                    \"line\",\n                    \"vertical\",\n                    \"guideline\",\n                    \"target\",\n                    \"bold\",\n                )} key={`verticalTargetGuidline${i}`} style={{\n                    top: `${minTop}px`,\n                    left: `${-targetLeft + pos}px`,\n                    height: `${height}px`,\n                }} />;\n            }),\n            ...horizontalSnapPoses.map((pos, i) => {\n                return <div className={prefix(\n                    \"line\",\n                    \"horizontal\",\n                    \"guideline\",\n                    \"target\",\n                    \"bold\",\n                )} key={`horizontalTargetGuidline${i}`} style={{\n                    top: `${-targetTop + pos}px`,\n                    left: `${minLeft}px`,\n                    width: `${width}px`,\n                }} />;\n            }),\n            ...verticalGuildelines.map((guideline, i) => {\n                const { pos, size, element } = guideline;\n\n                return <div className={prefix(\n                    \"line\",\n                    \"vertical\",\n                    \"guideline\",\n                    element ? \"bold\" : \"\",\n                )} key={`verticalGuidline${i}`} style={{\n                    top: `${minTop - clientTop + pos[1]}px`,\n                    left: `${-targetLeft + pos[0]}px`,\n                    height: `${size}px`,\n                }} />;\n            }),\n            ...horizontalGuidelines.map((guideline, i) => {\n                const { pos, size, element } = guideline;\n\n                return <div className={prefix(\n                    \"line\",\n                    \"horizontal\",\n                    \"guideline\",\n                    element ? \"bold\" : \"\",\n                )} key={`horizontalGuidline${i}`} style={{\n                    top: `${-targetTop + pos[1]}px`,\n                    left: `${minLeft - clientLeft + pos[0]}px`,\n                    width: `${size}px`,\n                }} />;\n            }),\n        ];\n    },\n    dragStart(moveable: MoveableManager<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapDirection = true;\n        snapStart(moveable);\n    },\n    pinchStart(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragEnd(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(moveable: MoveableManager<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapDirection = null;\n        snapStart(moveable);\n    },\n    dragControlEnd(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragGroupStart(moveable: any, e: any) {\n        moveable.state.snapDirection = true;\n        snapStart(moveable);\n    },\n    dragGroupEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart(moveable: any, e: any) {\n        moveable.state.snapDirection = null;\n        snapStart(moveable);\n    },\n    dragGroupControlEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    unset(moveable: any) {\n        const state = moveable.state;\n\n        state.enableSnap = false;\n        state.guidelines = [];\n        state.snapDirection = null;\n    },\n};\n","import { getDragDist, setDragStart } from \"../DraggerUtils\";\nimport { throttleArray, triggerEvent, fillParams } from \"../utils\";\nimport { minus, plus } from \"@moveable/matrix\";\nimport MoveableManager from \"../MoveableManager\";\nimport { DraggableProps, OnDrag, OnDragGroup, OnDragGroupStart, OnDragStart, OnDragEnd } from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { triggerChildAble } from \"../groupUtils\";\nimport { checkSnapDrag, startCheckSnapDrag } from \"./Snappable\";\n\nexport default {\n    name: \"draggable\",\n    dragStart(\n        moveable: MoveableManager<DraggableProps>,\n        e: any,\n    ) {\n        const { datas, parentEvent, parentDragger } = e;\n        const state = moveable.state;\n        const {\n            targetTransform,\n            target,\n            dragger,\n        } = state;\n\n        if (dragger) {\n            return false;\n        }\n        state.dragger = parentDragger || moveable.targetDragger;\n        const style = window.getComputedStyle(target!);\n\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.transform = targetTransform;\n        datas.startTranslate = [0, 0];\n\n        setDragStart(moveable, { datas });\n\n        datas.prevDist = [0, 0];\n        datas.prevBeforeDist = [0, 0];\n        datas.isDrag = false;\n\n        startCheckSnapDrag(moveable, datas);\n        const params = fillParams<OnDragStart>(moveable, e, {\n            set: (translate: number[]) => {\n                datas.startTranslate = translate;\n            },\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n        if (result !== false) {\n            datas.isDrag = true;\n        } else {\n            state.dragger = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag(\n        moveable: MoveableManager<DraggableProps>,\n        e: any,\n    ): OnDrag | undefined {\n        const { datas, parentEvent, parentFlag } = e;\n        let { distX, distY } = e;\n        const { isPinch, isDrag, prevDist, prevBeforeDist, transform, startTranslate } = datas;\n\n        if (!isDrag) {\n            return;\n        }\n        const props = moveable.props;\n        const parentMoveable = props.parentMoveable;\n        const throttleDrag = parentEvent ? 0 : (props.throttleDrag || 0);\n\n        let isSnap = false;\n\n        if (!isPinch && !parentEvent && !parentFlag) {\n            const [verticalInfo, horizontalInfo] = checkSnapDrag(moveable, distX, distY, datas);\n\n            isSnap = verticalInfo.isSnap || horizontalInfo.isSnap;\n            distX -= verticalInfo.offset;\n            distY -= horizontalInfo.offset;\n        }\n        datas.passDistX = distX;\n        datas.passDistY = distY;\n        const beforeTranslate = plus(getDragDist({ datas, distX, distY }, true), startTranslate);\n        const translate = plus(getDragDist({ datas, distX, distY }, false), startTranslate);\n\n        if (!isSnap) {\n            throttleArray(translate, throttleDrag);\n            throttleArray(beforeTranslate, throttleDrag);\n        }\n\n        const beforeDist = minus(beforeTranslate, startTranslate);\n        const dist = minus(translate, startTranslate);\n        const delta = minus(dist, prevDist);\n        const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n\n        const left = datas.left + beforeDist[0];\n        const top = datas.top + beforeDist[1];\n        const right = datas.right - beforeDist[0];\n        const bottom = datas.bottom - beforeDist[1];\n        const nextTransform = `${transform} translate(${dist[0]}px, ${dist[1]}px)`;\n\n        if (!parentEvent && !parentMoveable && delta.every(num => !num) && beforeDelta.some(num => !num)) {\n            return;\n        }\n        const params = fillParams<OnDrag>(moveable, e, {\n            transform: nextTransform,\n            dist,\n            delta,\n            translate,\n            beforeDist,\n            beforeDelta,\n            beforeTranslate,\n            left,\n            top,\n            right,\n            bottom,\n            isPinch,\n        });\n\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragEnd(\n        moveable: MoveableManager<DraggableProps>,\n        e: any,\n    ) {\n        const { parentEvent, datas, isDrag } = e;\n        if (!datas.isDrag) {\n            return;\n        }\n\n        moveable.state.dragger = null;\n        datas.isDrag = false;\n        !parentEvent && triggerEvent(moveable, \"onDragEnd\", fillParams<OnDragEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        const datas = e.datas;\n\n        const params = this.dragStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildAble(moveable, this, \"dragStart\", datas, e);\n        const nextParams: OnDragGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n        datas.isDrag = result !== false;\n        return datas.isDrag ? params : false;\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        const datas = e.datas;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        const params = this.drag(moveable, e);\n        const { passDistX, passDistY } = e.datas;\n        const events = triggerChildAble(moveable, this, \"drag\", datas, { ...e, distX: passDistX, distY: passDistY });\n\n        if (!params) {\n            return;\n        }\n        const nextParams: OnDragGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragEnd\", datas, e);\n        triggerEvent(moveable, \"onDragGroupEnd\", fillParams(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        }));\n\n        return isDrag;\n    },\n};\n","import { MoveableManagerState, OnCustomDrag } from \"./types\";\n\nexport function setCustomDrag(state: Partial<MoveableManagerState<any>>, delta: number[], inputEvent: any) {\n    return {\n        ...state.dragger!.move(delta, inputEvent),\n        parentEvent: true,\n    };\n}\n\nexport default class CustomDragger {\n    private prevX = 0;\n    private prevY = 0;\n    private startX = 0;\n    private startY = 0;\n    private isDrag = false;\n    private isFlag = false;\n    private datas = {};\n\n    public dragStart(client: number[], inputEvent: any)  {\n        this.isDrag = false;\n        this.isFlag = false;\n        this.datas = {};\n\n        return this.move(client, inputEvent);\n    }\n    public drag(client: number[], inputEvent: any) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY,\n        ], inputEvent);\n    }\n    public move(delta: number[], inputEvent: any): OnCustomDrag {\n        let clientX!: number;\n        let clientY!: number;\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n\n            clientX = delta[0];\n            clientY = delta[1];\n\n            this.isFlag = true;\n        } else {\n\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n            this.isDrag = true;\n        }\n\n        this.prevX = clientX;\n        this.prevY = clientY;\n\n        return {\n            clientX,\n            clientY,\n            inputEvent,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas,\n            parentEvent: true,\n            parentDragger: this,\n        };\n    }\n}\n","import { throttle, prefix, triggerEvent, fillParams, getRotationRad } from \"../utils\";\nimport { IObject, hasClass } from \"@daybrush/utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    RotatableProps, OnRotateGroup, OnRotateGroupEnd,\n    Renderer, OnRotateGroupStart, OnRotateStart, OnRotate, OnRotateEnd,\n} from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { triggerChildAble } from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { minus, plus, getRad, rotate as rotateMatrix } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\n\nfunction setRotateStartInfo(\n    datas: IObject<any>, clientX: number, clientY: number, origin: number[], rotationPos: number[]) {\n    datas.startAbsoluteOrigin = [\n        clientX - rotationPos[0] + origin[0],\n        clientY - rotationPos[1] + origin[1],\n    ];\n    datas.prevDeg = getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n    datas.startDeg = datas.prevDeg;\n    datas.loop = 0;\n}\nfunction getDeg(\n    datas: IObject<any>,\n    deg: number,\n    direction: number,\n    startRotate: number,\n    throttleRotate: number,\n) {\n    const {\n        prevDeg,\n        startDeg,\n        loop: prevLoop,\n    } = datas;\n\n    if (prevDeg > deg && prevDeg > 270 && deg < 90) {\n        // 360 => 0\n        ++datas.loop;\n    } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {\n        // 0 => 360\n        --datas.loop;\n    }\n    const loop = datas.loop;\n    const absolutePrevDeg = prevLoop * 360 + prevDeg - startDeg + startRotate;\n    let absoluteDeg = loop * 360 + deg - startDeg + startRotate;\n\n    absoluteDeg = throttle(absoluteDeg, throttleRotate);\n    const delta = direction * (absoluteDeg - absolutePrevDeg);\n    const dist = direction * (absoluteDeg - startRotate);\n\n    datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n\n    return [delta, dist, absoluteDeg];\n}\nfunction getRotateInfo(\n    datas: IObject<any>,\n    direction: number,\n    clientX: number, clientY: number,\n    startRotate: number,\n    throttleRotate: number,\n) {\n    return getDeg(\n        datas,\n        getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180,\n        direction,\n        startRotate,\n        throttleRotate,\n    );\n}\n\nexport function getPositions(\n    rotationPosition: \"top\" | \"bottom\" | \"left\" | \"right\",\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n) {\n    if (rotationPosition === \"left\") {\n        return [pos3, pos1];\n    } else if (rotationPosition === \"right\") {\n        return [pos2, pos4];\n    } else if (rotationPosition === \"bottom\") {\n        return [pos4, pos3];\n    }\n    return [pos1, pos2];\n}\nexport function getRotationPosition(\n    [pos1, pos2]: number[][],\n    rad: number,\n): number[] {\n    const relativeRotationPos = rotateMatrix([0, -40, 1], rad);\n\n    const rotationPos = [\n        (pos1[0] + pos2[0]) / 2 + relativeRotationPos[0],\n        (pos1[1] + pos2[1]) / 2 + relativeRotationPos[1],\n    ];\n\n    return rotationPos;\n}\n\nfunction dragControlCondition(target: HTMLElement | SVGElement) {\n    return hasClass(target, prefix(\"rotation\"));\n}\n\nexport default {\n    name: \"rotatable\",\n    canPinch: true,\n\n    render(moveable: MoveableManager<RotatableProps>, React: Renderer): any {\n        const {\n            rotatable,\n            rotationPosition,\n        } = moveable.props;\n        if (!rotatable) {\n            return null;\n        }\n        const { pos1, pos2, pos3, pos4, direction } = moveable.state;\n        const poses = getPositions(rotationPosition!, pos1, pos2, pos3, pos4);\n        const rotationRad = getRotationRad(poses, direction);\n\n        return (\n            <div key=\"rotation\" className={prefix(\"line rotation-line\")} style={{\n                // tslint:disable-next-line: max-line-length\n                transform: `translate(${(poses[0][0] + poses[1][0]) / 2}px, ${(poses[0][1] + poses[1][1]) / 2}px) translateY(-40px) rotate(${rotationRad}rad)`,\n            }}>\n                <div className={prefix(\"control\", \"rotation\")}></div>\n            </div>\n        );\n    },\n    dragControlCondition,\n    dragControlStart(\n        moveable: MoveableManager<RotatableProps>,\n        e: any) {\n        const { datas, clientX, clientY, parentRotate, parentFlag, pinchFlag } = e;\n        const {\n            target, left, top, origin, beforeOrigin,\n            direction, beforeDirection, targetTransform,\n            pos1, pos2, pos3, pos4,\n        } = moveable.state;\n\n        if (!target) {\n            return false;\n        }\n\n        datas.transform = targetTransform;\n        datas.left = left;\n        datas.top = top;\n\n        const poses = getPositions(moveable.props.rotationPosition!, pos1, pos2, pos3, pos4);\n        const rotationPos = getRotationPosition(\n            poses,\n            getRotationRad(poses, direction),\n        );\n\n        if (pinchFlag || parentFlag) {\n            datas.beforeInfo = { prevDeg: parentRotate, startDeg: parentRotate, loop: 0 };\n            datas.afterInfo = { prevDeg: parentRotate, startDeg: parentRotate, loop: 0 };\n        } else {\n            datas.afterInfo = {};\n            datas.beforeInfo = {};\n            setRotateStartInfo(datas.afterInfo, clientX, clientY, origin, rotationPos);\n            setRotateStartInfo(datas.beforeInfo, clientX, clientY, beforeOrigin, rotationPos);\n        }\n\n        datas.direction = direction;\n        datas.beforeDirection = beforeDirection;\n        datas.startRotate = 0;\n        datas.datas = {};\n\n        const params = fillParams<OnRotateStart>(moveable, e, {\n            set: (rotatation: number) => {\n                datas.startRotate = rotatation;\n            },\n        });\n        const result = triggerEvent(moveable, \"onRotateStart\", params);\n        datas.isRotate = result !== false;\n\n        return datas.isRotate ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<RotatableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, parentRotate, parentFlag, pinchFlag } = e;\n        const {\n            direction,\n            beforeDirection,\n            beforeInfo,\n            afterInfo,\n            isRotate,\n            startRotate,\n        } = datas;\n\n        if (!isRotate) {\n            return;\n        }\n        const {\n            throttleRotate = 0,\n            parentMoveable,\n        } = moveable.props;\n\n        let delta: number;\n        let dist: number;\n        let rotate: number;\n        let beforeDelta: number;\n        let beforeDist: number;\n        let beforeRotate: number;\n\n        if (pinchFlag || parentFlag) {\n            [delta, dist, rotate] = getDeg(afterInfo, parentRotate, direction, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getDeg(beforeInfo, parentRotate, direction, startRotate, throttleRotate);\n        } else {\n            [delta, dist, rotate] = getRotateInfo(afterInfo, direction, clientX, clientY, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate] = getRotateInfo(\n                beforeInfo, beforeDirection, clientX, clientY, startRotate, throttleRotate,\n            );\n        }\n\n        if (!delta && !beforeDelta && !parentMoveable) {\n            return;\n        }\n        const params = fillParams<OnRotate>(moveable, e, {\n            delta,\n            dist,\n            rotate,\n            beforeDist,\n            beforeDelta,\n            beforeRotate,\n            transform: `${datas.transform} rotate(${dist}deg)`,\n            isPinch: !!pinchFlag,\n        });\n        triggerEvent(moveable, \"onRotate\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManager<RotatableProps>, e: any) {\n        const { datas, isDrag } = e;\n\n        if (!datas.isRotate) {\n            return false;\n        }\n        datas.isRotate = false;\n\n        triggerEvent(moveable, \"onRotateEnd\", fillParams<OnRotateEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupControlCondition: dragControlCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas, inputEvent } = e;\n        const {\n            left: parentLeft,\n            top: parentTop,\n            beforeOrigin: parentBeforeOrigin,\n        } = moveable.state;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            { ...e, parentRotate: 0 },\n            (child, childDatas, eventParams) => {\n                const { left, top, beforeOrigin } = child.state;\n                const childClient = plus(\n                    minus([left, top], [parentLeft, parentTop]),\n                    minus(beforeOrigin, parentBeforeOrigin),\n                );\n\n                childDatas.prevClient = childClient;\n                eventParams.dragStart = Draggable.dragStart(\n                    child,\n                    new CustomDragger().dragStart(childClient, inputEvent),\n                );\n            },\n        );\n\n        const nextParams: OnRotateGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n\n        datas.isRotate = result !== false;\n        return datas.isDrag ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { inputEvent, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const parentRotate = params.beforeDist;\n        const deg = params.beforeDelta;\n        const rad = deg / 180 * Math.PI;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            { ...e, parentRotate },\n            (child, childDatas, result, i) => {\n                const [prevX, prevY] = childDatas.prevClient;\n                const [clientX, clientY] = rotateMatrix([prevX, prevY], rad);\n                const delta = [clientX - prevX, clientY - prevY];\n\n                childDatas.prevClient = [clientX, clientY];\n\n                const dragResult = Draggable.drag(\n                    child,\n                    setCustomDrag(child.state, delta, inputEvent),\n                );\n\n                result.drag = dragResult;\n            },\n        );\n        const nextParams: OnRotateGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        moveable.rotation += params.beforeDelta;\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams: OnRotateGroupEnd = fillParams(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n        return isDrag;\n    },\n};\n","import MoveableManager from \"./MoveableManager\";\nimport { prefix, getControlTransform } from \"./utils\";\nimport { ResizableProps, ScalableProps, WarpableProps, Renderer } from \"./types\";\nimport { DIRECTION_INDEXES } from \"./consts\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport function renderControls(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    defaultDirections: string[],\n    React: Renderer,\n): any[] {\n    const {\n        pos1, pos2, pos3, pos4,\n        rotation,\n    } = moveable.state;\n    const {\n        renderDirections: directions = defaultDirections,\n    } = moveable.props;\n    const poses = [pos1, pos2, pos3, pos4];\n\n    const directionMap: IObject<boolean> = {};\n    directions.forEach(direction => {\n        directionMap[direction] = true;\n    });\n    return directions.map(direction => {\n        const indexes = DIRECTION_INDEXES[direction];\n\n        if (!indexes || !directionMap[direction]) {\n            return null;\n        }\n        return (\n            <div className={prefix(\"control\", \"direction\", direction)} data-direction={direction} key={direction}\n                style={getControlTransform(rotation, ...indexes.map(index => poses[index]))}></div>\n        );\n    });\n}\nexport function renderAllDirections(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n) {\n    return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\", \"n\", \"w\", \"s\", \"e\"], React);\n}\nexport function renderDiagonalDirections(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n): any[] {\n    return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], React);\n}\n","import {\n    throttle, getDirection, triggerEvent,\n    getAbsolutePosesByState, fillParams, getKeepRatioHeight, getKeepRatioWidth, getCSSSize,\n} from \"../utils\";\nimport {\n    setDragStart,\n    getDragDist,\n    getResizeDist,\n    getPosByReverseDirection,\n    getFixedPosition,\n    getStartDirection,\n} from \"../DraggerUtils\";\nimport {\n    ResizableProps, OnResizeGroup, OnResizeGroupEnd,\n    Renderer, OnResizeGroupStart, DraggableProps, OnDrag, OnResizeStart, SnappableState,\n    OnResize, OnResizeEnd,\n} from \"../types\";\nimport MoveableManager from \"../MoveableManager\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport {\n    triggerChildAble, directionCondition,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapSize } from \"./Snappable\";\n\nexport default {\n    name: \"resizable\",\n    ableGroup: \"size\",\n    updateRect: true,\n    canPinch: true,\n\n    render(moveable: MoveableManager<Partial<ResizableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, edge } = moveable.props;\n        if (resizable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManager<ResizableProps & DraggableProps, SnappableState>,\n        e: any,\n    ) {\n        const {\n            inputEvent,\n            pinchFlag,\n            datas,\n        } = e;\n        const {\n            target: inputTarget,\n        } = inputEvent;\n\n        const direction = pinchFlag ? [1, 1] : getDirection(inputTarget);\n        const { target, width, height } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        !pinchFlag && setDragStart(moveable, { datas });\n\n        datas.datas = {};\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.prevWidth = 0;\n        datas.prevHeight = 0;\n        [\n            datas.startWidth,\n            datas.startHeight,\n        ] = getCSSSize(target);\n        datas.transformOrigin = moveable.props.transformOrigin;\n        datas.startDirection = getStartDirection(moveable, direction);\n        datas.fixedPosition = getFixedPosition(moveable, datas.startDirection);\n        datas.fixedOriginalPosition = getFixedPosition(moveable, direction);\n\n        const params = fillParams<OnResizeStart>(moveable, e, {\n            direction,\n            set: ([startWidth, startHeight]: number[]) => {\n                datas.startWidth = startWidth;\n                datas.startHeight = startHeight;\n            },\n            setOrigin: (origin: Array<string | number>) => {\n                datas.transformOrigin = origin;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ),\n        });\n        const result = triggerEvent(moveable, \"onResizeStart\", params);\n        if (result !== false) {\n            datas.isResize = true;\n            moveable.state.snapDirection = direction;\n        }\n        return datas.isResize ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const {\n            datas,\n            distX, distY,\n            parentFlag, pinchFlag,\n            parentDistance, parentScale, inputEvent,\n            dragClient,\n        } = e;\n        const {\n            direction,\n            isResize,\n            transformOrigin,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            startWidth,\n            startHeight,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n        const {\n            throttleResize = 0,\n            parentMoveable,\n        } = moveable.props;\n        const keepRatio = moveable.props.keepRatio || parentScale;\n        const isWidth = direction[0] || !direction[1];\n        const ratio = isWidth ? startOffsetHeight / startOffsetWidth : startOffsetWidth / startOffsetHeight;\n        let distWidth: number = 0;\n        let distHeight: number = 0;\n\n        if (parentScale) {\n            distWidth = (parentScale[0] - 1) * startOffsetWidth;\n            distHeight = (parentScale[1] - 1) * startOffsetHeight;\n\n        } else if (pinchFlag) {\n            if (parentDistance) {\n                distWidth = parentDistance;\n                distHeight = parentDistance * startOffsetHeight / startOffsetWidth;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n\n            distWidth = direction[0] * dist[0];\n            distHeight = direction[1] * dist[1];\n\n            if (keepRatio && startOffsetWidth && startOffsetHeight) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], direction);\n                const ratioRad = getRad([0, 0], [startOffsetWidth, startOffsetHeight]);\n                const size = Math.sqrt(distWidth * distWidth + distHeight * distHeight);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!direction[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!direction[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n        }\n        let nextWidth = direction[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, 0) : startOffsetWidth;\n        let nextHeight = direction[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, 0) : startOffsetHeight;\n\n        let snapDist = [0, 0];\n\n        if (!pinchFlag) {\n            snapDist = checkSnapSize(moveable, nextWidth, nextHeight, direction, datas);\n        }\n        if (keepRatio) {\n            if (direction[0] && direction[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nextWidth = throttle(nextWidth, throttleResize!);\n                } else {\n                    nextHeight = throttle(nextHeight, throttleResize!);\n                }\n            }\n            if (\n                (direction[0] && !direction[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nextWidth += snapDist[0];\n                nextHeight = getKeepRatioHeight(nextWidth, isWidth, ratio);\n            } else if (\n                (!direction[0] && direction[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nextHeight += snapDist[1];\n                nextWidth = getKeepRatioWidth(nextHeight, isWidth, ratio);\n            }\n        } else {\n            nextWidth += snapDist[0];\n            nextHeight += snapDist[1];\n            if (!snapDist[0]) {\n                nextWidth = throttle(nextWidth, throttleResize!);\n            }\n            if (!snapDist[1]) {\n                nextHeight = throttle(nextHeight, throttleResize!);\n            }\n        }\n        nextWidth = Math.round(nextWidth);\n        nextHeight = Math.round(nextHeight);\n\n        distWidth = nextWidth - startOffsetWidth;\n        distHeight = nextHeight - startOffsetHeight;\n\n        const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n        datas.prevWidth = distWidth;\n        datas.prevHeight = distHeight;\n\n        if (!parentMoveable && delta.every(num => !num)) {\n            return;\n        }\n\n        const startDirection = keepRatio || parentFlag ? direction : datas.startDirection;\n        const fixedPosition = dragClient || (keepRatio ? datas.fixedOriginalPosition : datas.fixedPosition);\n\n        const inverseDelta = !parentFlag && pinchFlag\n            ? [0, 0]\n            : getResizeDist(\n                moveable,\n                nextWidth, nextHeight,\n                startDirection, fixedPosition, transformOrigin);\n\n        const params = fillParams<OnResize>(moveable, e, {\n            width: startWidth + distWidth,\n            height: startHeight + distHeight,\n            offsetWidth: nextWidth,\n            offsetHeight: nextHeight,\n            direction,\n            dist: [distWidth, distHeight],\n            delta,\n            isPinch: !!pinchFlag,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent),\n            ) as OnDrag,\n        });\n        triggerEvent(moveable, \"onResize\", params);\n        return params;\n    },\n    dragControlAfter(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            isResize,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const errorWidth = width - (startOffsetWidth + prevWidth);\n        const errorHeight = height - (startOffsetHeight + prevHeight);\n        const isErrorWidth = Math.abs(errorWidth) > 3;\n        const isErrorHeight = Math.abs(errorHeight) > 3;\n\n        if (isErrorWidth) {\n            datas.startWidth += errorWidth;\n            datas.startOffsetWidth += errorWidth;\n            datas.prevWidth += errorWidth;\n        }\n        if (isErrorHeight) {\n            datas.startHeight += errorHeight;\n            datas.startOffsetHeight += errorHeight;\n            datas.prevHeight += errorHeight;\n        }\n        if (isErrorWidth || isErrorHeight) {\n            this.dragControl(moveable, e);\n            return true;\n        }\n    },\n    dragControlEnd(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isResize) {\n            return false;\n        }\n        datas.isResize = false;\n\n        const params = fillParams<OnResizeEnd>(moveable, e, {\n            isDrag,\n        });\n        triggerEvent(moveable, \"onResizeEnd\", params);\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const startPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getPosByReverseDirection(getAbsolutePosesByState(child.state), direction);\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - startPos[0], pos[1] - startPos[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnResizeGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n\n        datas.isResize = result !== false;\n        return datas.isResize ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const {\n            offsetWidth, offsetHeight, dist,\n        } = params;\n\n        const parentScale = [\n            offsetWidth / (offsetWidth - dist[0]),\n            offsetHeight / (offsetHeight - dist[1]),\n        ];\n        const fixedPosition = datas.fixedOriginalPosition;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * parentScale[0],\n                        childDatas.originalY * parentScale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return { ...e, parentScale, dragClient: plus(fixedPosition, [clientX, clientY]) };\n            },\n        );\n        const nextParams: OnResizeGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onResizeGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isResize) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams: OnResizeGroupEnd = fillParams<OnResizeGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n        return isDrag;\n    },\n};\n","import {\n    throttle, getDirection, triggerEvent, multiply2, getAbsolutePosesByState,\n    fillParams, getKeepRatioHeight, getKeepRatioWidth,\n} from \"../utils\";\nimport { MIN_SCALE } from \"../consts\";\nimport { setDragStart, getDragDist, getScaleDist, getPosByReverseDirection } from \"../DraggerUtils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport {\n    ScalableProps, ResizableProps, OnScaleGroup, OnScaleGroupEnd,\n    Renderer, OnScaleGroupStart, DraggableProps, OnDragStart,\n    OnDrag, SnappableState, GroupableProps, OnScaleStart, OnScale, OnScaleEnd,\n} from \"../types\";\nimport {\n    directionCondition, triggerChildAble,\n} from \"../groupUtils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapScale } from \"./Snappable\";\nimport { isArray } from \"@daybrush/utils\";\n\nexport default {\n    name: \"scalable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    render(moveable: MoveableManager<Partial<ResizableProps & ScalableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, scalable, edge } = moveable.props;\n        if (!resizable && scalable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManager<ScalableProps & DraggableProps, SnappableState>,\n        e: any) {\n\n        const { datas, pinchFlag, inputEvent } = e;\n        const { target: inputTarget } = inputEvent;\n        const direction = pinchFlag ? [1, 1] : getDirection(inputTarget);\n        const {\n            width,\n            height,\n            targetTransform,\n            target,\n        } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (!pinchFlag) {\n            setDragStart(moveable, { datas });\n        }\n\n        datas.datas = {};\n        datas.transform = targetTransform;\n        datas.prevDist = [1, 1];\n        datas.direction = direction;\n        datas.width = width;\n        datas.height = height;\n        datas.startScale = [1, 1];\n\n        const params = fillParams<OnScaleStart>(moveable, e, {\n            direction,\n            set: (scale: number[]) => {\n                datas.startScale = scale;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ) as OnDragStart,\n        });\n        const result = triggerEvent(moveable, \"onScaleStart\", params);\n\n        if (result !== false) {\n            datas.isScale = true;\n            moveable.state.snapDirection = direction;\n\n        }\n        return datas.isScale ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<ScalableProps & DraggableProps & GroupableProps, SnappableState>,\n        e: any) {\n        const {\n            datas, distX, distY, parentScale, parentDistance,\n            parentFlag, pinchFlag, inputEvent,\n            dragClient,\n        } = e;\n        const {\n            prevDist,\n            direction,\n            width,\n            height,\n            transform,\n            isScale,\n            startScale,\n        } = datas;\n\n        if (!isScale) {\n            return false;\n        }\n\n        const {\n            throttleScale,\n            parentMoveable,\n        } = moveable.props;\n        const keepRatio = moveable.props.keepRatio || parentScale;\n        const state = moveable.state;\n        const isWidth = direction[0] || !direction[1];\n        let scaleX: number = 1;\n        let scaleY: number = 1;\n        const startWidth = width * startScale[0];\n        const startHeight = height * startScale[1];\n        const ratio = isWidth ? startHeight / startWidth : startWidth / startHeight;\n\n        if (parentScale) {\n            scaleX = parentScale[0];\n            scaleY = parentScale[1];\n        } else if (pinchFlag) {\n            if (parentDistance) {\n                scaleX = (width + parentDistance) / width;\n                scaleY = (height + parentDistance * height / width) / height;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n            let distWidth = direction[0] * dist[0];\n            let distHeight = direction[1] * dist[1];\n\n            if (keepRatio && width && height) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], direction);\n                const ratioRad = getRad([0, 0], [startWidth, startHeight]);\n                const size = Math.sqrt(distWidth * distWidth + distHeight * distHeight);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!direction[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!direction[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n            scaleX = (width + distWidth) / width;\n            scaleY = (height + distHeight) / height;\n        }\n        scaleX = direction[0] ? scaleX * startScale[0] : startScale[0];\n        scaleY = direction[1] ? scaleY * startScale[1] : startScale[1];\n\n        if (scaleX === 0) {\n            scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (scaleY === 0) {\n            scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n\n        const nowDist = [scaleX / startScale[0], scaleY / startScale[1]];\n        let scale = [scaleX, scaleY];\n        let snapDirection = direction;\n\n        if (moveable.props.groupable) {\n            snapDirection = [\n                (nowDist[0] >= 0 ? 1 : -1) * direction[0],\n                (nowDist[1] >= 0 ? 1 : -1) * direction[1],\n            ];\n            const stateDirection = state.snapDirection;\n\n            if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n                state.snapDirection = snapDirection;\n            }\n        }\n        let snapDist = [0, 0];\n\n        if (!pinchFlag) {\n            snapDist = checkSnapScale(moveable, nowDist, direction, snapDirection, datas);\n        }\n\n        if (keepRatio) {\n            if (direction[0] && direction[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n                } else {\n                    nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n                }\n            }\n            if (\n                (direction[0] && !direction[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nowDist[0] += snapDist[0];\n                const snapHeight = getKeepRatioHeight(width * nowDist[0] * startScale[0], isWidth, ratio);\n\n                nowDist[1] = snapHeight / height / startScale[1];\n            } else if (\n                (!direction[0] && direction[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nowDist[1] += snapDist[1];\n                const snapWidth = getKeepRatioWidth(height * nowDist[1] * startScale[1], isWidth, ratio);\n\n                nowDist[0] = snapWidth / width / startScale[0];\n            }\n        } else {\n            if (!snapDist[0]) {\n                nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n            }\n            if (!snapDist[1]) {\n                nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n            }\n        }\n        if (nowDist[0] === 0) {\n            nowDist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (nowDist[1] === 0) {\n            nowDist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        const delta = [nowDist[0] / prevDist[0], nowDist[1] / prevDist[1]];\n        scale = multiply2(nowDist, startScale);\n\n        datas.prevDist = nowDist;\n\n        if (scaleX === prevDist[0] && scaleY === prevDist[1] && !parentMoveable) {\n            return false;\n        }\n        const inverseDelta = !parentFlag && pinchFlag\n            ? [0, 0]\n            : getScaleDist(moveable, delta, direction, dragClient);\n\n        const params = fillParams<OnScale>(moveable, e, {\n            scale,\n            direction,\n            dist: nowDist,\n            delta,\n            transform: `${transform} scale(${scaleX}, ${scaleY})`,\n            isPinch: !!pinchFlag,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent),\n            ) as OnDrag,\n        });\n        triggerEvent(moveable, \"onScale\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManager<ScalableProps>, e: any) {\n        const { datas, isDrag } = e;\n        if (!datas.isScale) {\n            return false;\n        }\n\n        datas.isScale = false;\n\n        triggerEvent(moveable, \"onScaleEnd\", fillParams<OnScaleEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const startPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getPosByReverseDirection(getAbsolutePosesByState(child.state), direction);\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - startPos[0], pos[1] - startPos[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnScaleGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n\n        datas.isScale = result !== false;\n        return datas.isScale ? nextParams : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        if (!datas.isScale) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n        const { scale, direction, dist } = params;\n        const prevPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), multiply2(direction, dist));\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * scale[0],\n                        childDatas.originalY * scale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return { ...e, parentScale: scale, dragClient: plus(prevPos, [clientX, clientY]) };\n            },\n        );\n        const nextParams: OnScaleGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isScale) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams = fillParams<OnScaleGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n        return isDrag;\n    },\n};\n","import { prefix, getLineStyle, getDirection, getAbsolutePosesByState, triggerEvent, fillParams } from \"../utils\";\nimport {\n    convertDimension, invert, multiply,\n    convertMatrixtoCSS, caculate,\n    createIdentityMatrix,\n    ignoreDimension,\n    multiplyCSS,\n    minus,\n    createWarpMatrix,\n    getRad,\n    plus,\n} from \"@moveable/matrix\";\nimport { NEARBY_POS } from \"../consts\";\nimport { setDragStart, getDragDist, getPosIndexesByDirection } from \"../DraggerUtils\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    WarpableProps, ScalableProps, ResizableProps,\n    Renderer, SnappableProps, SnappableState,\n    OnWarpStart, OnWarp, OnWarpEnd,\n} from \"../types\";\nimport { hasClass, dot } from \"@daybrush/utils\";\nimport { renderAllDirections } from \"../renderDirection\";\nimport { checkSnapPoses, hasGuidelines } from \"./Snappable\";\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n    return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n    // pos1 Rad\n    const rad1 = getRad(pos1, pos2);\n    const rad2 = getRad(pos1, pos3);\n\n    const rad = rad2 - rad1;\n\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n    const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n    const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n    const pi = Math.PI;\n\n    if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n        return false;\n    }\n    return true;\n}\n\nexport default {\n    name: \"warpable\",\n    ableGroup: \"size\",\n    render(moveable: MoveableManager<ResizableProps & ScalableProps & WarpableProps>, React: Renderer) {\n        const { resizable, scalable, warpable } = moveable.props;\n\n        if (resizable || scalable || !warpable) {\n            return;\n        }\n        const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n        const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n        const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n        const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n        const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n        const linePosTo1 = getMiddleLinePos(pos3, pos4);\n        const linePosTo2 = getMiddleLinePos(pos4, pos3);\n        const linePosTo3 = getMiddleLinePos(pos2, pos4);\n        const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n        return [\n            <div className={prefix(\"line\")} key=\"middeLine1\" style={getLineStyle(linePosFrom1, linePosTo1)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine2\" style={getLineStyle(linePosFrom2, linePosTo2)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine3\" style={getLineStyle(linePosFrom3, linePosTo3)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine4\" style={getLineStyle(linePosFrom4, linePosTo4)}></div>,\n            ...renderAllDirections(moveable, React),\n        ];\n    },\n    dragControlCondition(target: HTMLElement | SVGElement) {\n        return hasClass(target, prefix(\"direction\"));\n    },\n    dragControlStart(\n        moveable: MoveableManager<WarpableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, inputEvent } = e;\n        const { target } = moveable.props;\n        const { target: inputTarget } = inputEvent;\n        const direction = getDirection(inputTarget);\n\n        if (!direction || !target) {\n            return false;\n        }\n        const state = moveable.state;\n        const {\n            transformOrigin, is3d,\n            targetTransform, targetMatrix,\n            width, height,\n            left, top,\n        } = state;\n\n        datas.datas = {};\n        datas.targetTransform = targetTransform;\n        datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n        datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n        datas.direction = direction;\n        datas.left = left;\n        datas.top = top;\n\n        setDragStart(moveable, { datas });\n        datas.poses = [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n        ].map((p, i) => minus(p, transformOrigin));\n\n        datas.nextPoses = datas.poses.map(([x, y]: number[]) => caculate(datas.warpTargetMatrix, [x, y, 0, 1], 4));\n        datas.startMatrix = createIdentityMatrix(4);\n        datas.prevMatrix = createIdentityMatrix(4);\n        datas.absolutePoses = getAbsolutePosesByState(state);\n        datas.posIndexes = getPosIndexesByDirection(direction);\n        state.snapDirection = direction;\n\n        const params = fillParams<OnWarpStart>(moveable, e, {\n            set: (matrix: number[]) => {\n                datas.startMatrix = matrix;\n            },\n        });\n        const result = triggerEvent(moveable, \"onWarpStart\", params);\n        if (result !== false) {\n            datas.isWarp = true;\n        }\n        return result;\n    },\n    dragControl(\n        moveable: MoveableManager<WarpableProps & SnappableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas } = e;\n        let { distX, distY } = e;\n        const {\n            targetInverseMatrix, prevMatrix, isWarp, startMatrix,\n            poses,\n            posIndexes,\n            absolutePoses,\n        } = datas;\n\n        if (!isWarp) {\n            return false;\n        }\n\n        if (hasGuidelines(moveable, \"warpable\")) {\n            const selectedPoses: number[][] = posIndexes.map((index: number) => absolutePoses[index]);\n\n            if (selectedPoses.length > 1) {\n                selectedPoses.push([\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n                ]);\n            }\n            const snapInfos = checkSnapPoses(\n                moveable,\n                selectedPoses.map(pos => pos[0] + distX),\n                selectedPoses.map(pos => pos[1] + distY),\n            );\n            const {\n                horizontal: {\n                    offset: horizontalOffset,\n                },\n                vertical: {\n                    offset: verticalOffset,\n                },\n            } = snapInfos;\n\n            distY -= horizontalOffset;\n            distX -= verticalOffset;\n        }\n\n        const dist = getDragDist({ datas, distX, distY }, true);\n        const nextPoses = datas.nextPoses.slice();\n\n        posIndexes.forEach((index: number) => {\n            nextPoses[index] = plus(nextPoses[index], dist);\n        });\n\n        if (!NEARBY_POS.every(\n            nearByPoses => isValidPos(nearByPoses.map(i => poses[i]), nearByPoses.map(i => nextPoses[i])),\n        )) {\n            return false;\n        }\n        const h = createWarpMatrix(\n            poses[0],\n            poses[1],\n            poses[2],\n            poses[3],\n            nextPoses[0],\n            nextPoses[1],\n            nextPoses[2],\n            nextPoses[3],\n        );\n\n        if (!h.length) {\n            return false;\n        }\n\n        const matrix = convertMatrixtoCSS(multiply(targetInverseMatrix, h, 4));\n        const transform = `${datas.targetTransform} matrix3d(${matrix.join(\",\")})`;\n\n        const delta = multiplyCSS(invert(prevMatrix, 4), matrix, 4);\n\n        datas.prevMatrix = matrix;\n\n        triggerEvent(moveable, \"onWarp\", fillParams<OnWarp>(moveable, e, {\n            delta,\n            matrix: multiplyCSS(startMatrix, matrix, 4),\n            multiply: multiplyCSS,\n            dist: matrix,\n            transform,\n        }));\n        return true;\n    },\n    dragControlEnd(\n        moveable: MoveableManager<WarpableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isWarp) {\n            return false;\n        }\n        datas.isWarp = false;\n\n        triggerEvent(moveable, \"onWarpEnd\", fillParams<OnWarpEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n};\n","import { prefix } from \"./utils\";\n\nexport const AREA = prefix(\"area\");\nexport const AREA_PIECES = prefix(\"area-pieces\");\nexport const AREA_PIECE = prefix(\"area-piece\");\nexport const AVOID = prefix(\"avoid\");\n","import MoveableManager from \"../MoveableManager\";\nimport { createWarpMatrix, convertMatrixtoCSS } from \"@moveable/matrix\";\nimport { ref } from \"framework-utils\";\nimport { triggerEvent, fillParams, getRect } from \"../utils\";\nimport { Renderer, GroupableProps, DragAreaProps, OnClick } from \"../types\";\nimport { AREA_PIECE, AREA, AVOID, AREA_PIECES } from \"../classNames\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { addClass, findIndex, removeClass } from \"@daybrush/utils\";\n\nfunction restoreStyle(moveable: MoveableManager) {\n    const el = moveable.areaElement;\n    const { width, height } = moveable.state;\n\n    removeClass(el, AVOID);\n\n    el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n    return (<div key=\"area_pieces\" className={AREA_PIECES}>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n    </div>);\n}\nexport default {\n    name: \"dragArea\",\n    render(moveable: MoveableManager<GroupableProps>, React: Renderer): any[] {\n        const { target, dragArea, groupable } = moveable.props;\n\n        const { width, height, pos1, pos2, pos3, pos4 } = moveable.state;\n\n        if (groupable) {\n            return [\n                <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA}></div>,\n                renderPieces(React),\n            ];\n        }\n        if (!target || !dragArea) {\n            return [];\n        }\n        const h = createWarpMatrix(\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        );\n        const transform = h.length ? `matrix3d(${convertMatrixtoCSS(h).join(\",\")})` : \"none\";\n\n        return [\n            <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA} style={{\n                top: \"0px\",\n                left: \"0px\",\n                width: `${width}px`,\n                height: `${height}px`,\n                transformOrigin: \"0 0\",\n                transform,\n            }}></div>,\n            renderPieces(React),\n        ];\n    },\n    dragStart(moveable: MoveableManager, { datas, clientX, clientY, inputEvent }: any) {\n        datas.isDragArea = false;\n        datas.inputTarget = inputEvent.target;\n        const areaElement = moveable.areaElement;\n        const {\n            clientRect,\n            pos1, pos2, pos3, pos4,\n        } = moveable.state;\n        const { left, top, width, height } = clientRect;\n        const {\n            left: relativeLeft,\n            top: relativeTop,\n        } = getRect([pos1, pos2, pos3, pos4]);\n        const posX = clientX - left;\n        const posY = clientY - top;\n\n        const rects = [\n            { left: relativeLeft, top: relativeTop, width, height: posY - 10 },\n            { left: relativeLeft, top: relativeTop, width: posX - 10, height },\n            { left: relativeLeft, top: relativeTop + posY + 10, width, height: height - posY - 10 },\n            { left: relativeLeft + posX + 10, top: relativeTop, width: width - posX - 10, height },\n        ];\n\n        const children = [].slice.call(areaElement.nextElementSibling!.children) as HTMLElement[];\n        rects.forEach((rect, i) => {\n            children[i].style.cssText\n                = `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n        });\n        addClass(areaElement, AVOID);\n    },\n    drag(moveable: MoveableManager, { datas }: any) {\n        if (!datas.isDragArea) {\n            datas.isDragArea = true;\n            restoreStyle(moveable);\n        }\n    },\n    dragEnd(moveable: MoveableManager<DragAreaProps>, e: any) {\n        const { inputEvent, isDragArea, datas } = e;\n        if (!datas.isDragArea) {\n            restoreStyle(moveable);\n        }\n\n        const target = moveable.state.target!;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget)) {\n            return;\n        }\n        const containsTarget = target.contains(inputTarget);\n\n        triggerEvent(moveable, \"onClick\", fillParams<OnClick>(moveable, e, {\n            inputTarget,\n            isTarget: target === inputTarget,\n            containsTarget,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        this.drag(moveable, e);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroup,\n        e: any,\n    ) {\n        const { inputEvent, isDragArea, datas } = e;\n\n        if (!isDragArea) {\n            restoreStyle(moveable);\n        }\n        const prevInputTarget = datas.inputTarget;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget) || prevInputTarget === inputTarget) {\n            return;\n        }\n        const targets = moveable.props.targets!;\n        let targetIndex = targets.indexOf(inputTarget);\n        const isTarget = targetIndex > -1;\n        let containsTarget = false;\n\n        if (targetIndex === -1) {\n            targetIndex = findIndex(targets, parentTarget => parentTarget.contains(inputTarget));\n            containsTarget = targetIndex > -1;\n        }\n\n        triggerEvent(moveable, \"onClickGroup\", fillParams(moveable, e, {\n            targets,\n            inputTarget,\n            targetIndex,\n            isTarget,\n            containsTarget,\n        }));\n    },\n};\n","import MoveableManager from \"../MoveableManager\";\nimport { prefix, getControlTransform } from \"../utils\";\nimport { Renderer } from \"../types\";\n\nexport default {\n    name: \"origin\",\n    render(moveable: MoveableManager, React: Renderer): any {\n        if (!moveable.props.origin) {\n            return null;\n        }\n        const { beforeOrigin, rotation } = moveable.state;\n\n        return [\n            <div className={prefix(\"control\", \"origin\")}\n                style={getControlTransform(rotation, beforeOrigin)} key=\"beforeOrigin\"></div>,\n        ];\n    },\n};\n","import MoveableManager from \"../MoveableManager\";\nimport { ScrollableProps, OnScroll } from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport MoveableGroup from \"../MoveableGroup\";\n\nfunction getDefaultScrollPosition(e: { scrollContainer: HTMLElement, direction: number[] }) {\n    const scrollContainer = e.scrollContainer;\n\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop,\n    ];\n}\n\nexport default {\n    name: \"scrollable\",\n    canPinch: true,\n    dragStart(moveable: MoveableManager<ScrollableProps>, e: any) {\n        const props = moveable.props;\n        const {\n            scrollContainer = moveable.getContainer(),\n        } = props;\n\n        const scrollClientRect = scrollContainer.getBoundingClientRect();\n        const datas = e.datas;\n        datas.scrollContainer = scrollContainer;\n        datas.scrollRect = {\n            left: scrollClientRect.left,\n            top: scrollClientRect.top,\n            width: scrollClientRect.width,\n            height: scrollClientRect.height,\n        };\n\n        datas.isScroll = true;\n    },\n    drag(moveable: MoveableManager<ScrollableProps>, e: any) {\n        this.checkScroll(moveable, e);\n    },\n    dragEnd(moveable: MoveableManager<ScrollableProps>, e: any) {\n        e.datas.isScroll = false;\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        this.drag(moveable, {...e, targets: moveable.props.targets });\n    },\n    dragGroupEnd(moveable: MoveableGroup, e: any) {\n        this.dragEnd(moveable, e);\n    },\n    checkScroll(moveable: MoveableManager<ScrollableProps>, e: any) {\n        const {\n            datas,\n            inputEvent,\n            clientX,\n            clientY,\n            isScroll,\n            targets,\n        } = e;\n\n        if (!datas.isScroll) {\n            return;\n        }\n        if (!isScroll) {\n            datas.prevClientX = clientX;\n            datas.prevClientY = clientY;\n        }\n\n        const {\n            scrollThreshold = 0,\n            getScrollPosition = getDefaultScrollPosition,\n        } = moveable.props;\n        const {\n            scrollContainer,\n            scrollRect,\n        } = datas;\n\n        const direction = [0, 0];\n\n        if (scrollRect.top > clientY - scrollThreshold) {\n            direction[1] = -1;\n        } else if (scrollRect.top + scrollRect.height < clientY + scrollThreshold) {\n            direction[1] = 1;\n        }\n        if (scrollRect.left > clientX - scrollThreshold) {\n            direction[0] = -1;\n        } else if (scrollRect.left + scrollRect.width < clientX + scrollThreshold) {\n            direction[0] = 1;\n        }\n        if (!direction[0] && !direction[1]) {\n            return;\n        }\n\n        const pos = getScrollPosition({ scrollContainer, direction });\n        const params = fillParams<OnScroll>(moveable, e, {\n            scrollContainer,\n            direction,\n        }) as any;\n\n        const eventName = targets ? \"onScrollGroup\" : \"onScroll\" as any;\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n\n        requestAnimationFrame(() => {\n            if (datas.prevClientX !== clientX || datas.prevClientY !== clientY) {\n                return;\n            }\n\n            const nextPos = getScrollPosition({ scrollContainer, direction });\n            const offsetX = nextPos[0] - pos[0];\n            const offsetY = nextPos[1] - pos[1];\n\n            if (!offsetX && !offsetY) {\n                return;\n            }\n            moveable.targetDragger.scrollBy(direction[0] ? offsetX : 0, direction[1] ? offsetY : 0, inputEvent, false);\n\n            setTimeout(() => {\n                if (datas.prevClientX !== clientX || datas.prevClientY !== clientY) {\n                    return;\n                }\n\n                moveable.targetDragger.onDrag(inputEvent, true);\n            }, 10);\n        });\n    },\n};\n","import Pinchable from \"./Pinchable\";\nimport Rotatable from \"./Rotatable\";\nimport Draggable from \"./Draggable\";\nimport Resizable from \"./Resizable\";\nimport Scalable from \"./Scalable\";\nimport Warpable from \"./Warpable\";\nimport Snappable from \"./Snappable\";\nimport { Able } from \"../types\";\nimport DragArea from \"./DragArea\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./Scrollable\";\n\nexport const MOVEABLE_ABLES: Able[] = [\n    Snappable, Pinchable, Draggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, DragArea,  Origin,\n];\n","import { refs } from \"framework-utils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport MoveableManager from \"../MoveableManager\";\nimport { Renderer } from \"../types\";\n\nexport default {\n    name: \"groupable\",\n    render(moveable: MoveableGroup, React: Renderer): any[] {\n        const targets = moveable.props.targets || [];\n\n        moveable.moveables = [];\n        const { left, top } = moveable.state;\n        const position = { left, top };\n\n        return [...targets.map((target, i) => {\n            return <MoveableManager\n                key={i}\n                ref={refs(moveable, \"moveables\", i)}\n                target={target}\n                origin={false}\n                parentMoveable={moveable}\n                parentPosition={position}\n            />;\n        }),\n        ];\n    },\n};\n","import MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, MoveableManagerProps } from \"./types\";\nimport ChildrenDiffer from \"@egjs/children-differ\";\nimport { getAbleDragger } from \"./getAbleDragger\";\nimport Groupable from \"./ables/Groupable\";\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from \"./consts\";\nimport { getTargetInfo, throttle, getAbsolutePosesByState, equals } from \"./utils\";\nimport { plus, rotate } from \"@moveable/matrix\";\n\nfunction getMaxPos(poses: number[][][], index: number) {\n    return Math.max(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getMinPos(poses: number[][][], index: number) {\n    return Math.min(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getGroupRect(moveables: MoveableManager[], rotation: number) {\n    if (!moveables.length) {\n        return [0, 0, 0, 0];\n    }\n\n    const moveablePoses = moveables.map(({ state }) => getAbsolutePosesByState(state));\n    let minX = MAX_NUM;\n    let minY = MAX_NUM;\n    let groupWidth = 0;\n    let groupHeight = 0;\n    const fixedRotation = throttle(rotation, TINY_NUM);\n\n    if (fixedRotation % 90) {\n        const rad = rotation / 180 * Math.PI;\n        const a1 = Math.tan(rad);\n        const a2 = -1 / a1;\n        const b1s = [MIN_NUM, MAX_NUM];\n        const b2s = [MIN_NUM, MAX_NUM];\n\n        moveablePoses.forEach(poses => {\n            poses.forEach(pos => {\n                // ax + b = y\n                //  = y - ax\n                const b1 = pos[1] - a1 * pos[0];\n                const b2 = pos[1] - a2 * pos[0];\n\n                b1s[0] = Math.max(b1s[0], b1);\n                b1s[1] = Math.min(b1s[1], b1);\n                b2s[0] = Math.max(b2s[0], b2);\n                b2s[1] = Math.min(b2s[1], b2);\n            });\n        });\n\n        b1s.forEach(b1 => {\n            // a1x + b1 = a2x + b2\n            b2s.forEach(b2 => {\n                // (a1 - a2)x = b2 - b1\n                const x = (b2 - b1) / (a1 - a2);\n                const y = a1 * x + b1;\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n            });\n        });\n        const rotatePoses = moveablePoses.map(([pos1, pos2, pos3, pos4]) => {\n\n            return [\n                rotate(pos1, -rad),\n                rotate(pos2, -rad),\n                rotate(pos3, -rad),\n                rotate(pos4, -rad),\n            ];\n        });\n        groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n        groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n\n    } else {\n        minX = getMinPos(moveablePoses, 0);\n        minY = getMinPos(moveablePoses, 1);\n        groupWidth = getMaxPos(moveablePoses, 0) - minX;\n        groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n        if (fixedRotation % 180) {\n            const changedWidth = groupWidth;\n\n            groupWidth = groupHeight;\n            groupHeight = changedWidth;\n        }\n    }\n    return [minX, minY, groupWidth, groupHeight];\n}\n\nclass MoveableGroup extends MoveableManager<GroupableProps, any> {\n    public static defaultProps = {\n        ...MoveableManager.defaultProps,\n        transformOrigin: [\"50%\", \"50%\"],\n        groupable: true,\n        dragArea: true,\n        keepRatio: true,\n        targets: [],\n        defaultGroupRotate: 0,\n    };\n    public differ: ChildrenDiffer<HTMLElement | SVGElement> = new ChildrenDiffer();\n    public moveables: MoveableManager[] = [];\n    public rotation: number = 0;\n\n    public updateEvent(prevProps: MoveableManagerProps<GroupableProps>) {\n        const state = this.state;\n        const props = this.props;\n\n        if (!state.target) {\n            state.target = this.areaElement;\n\n            this.controlBox.getElement().style.display = \"block\";\n            this.targetDragger = getAbleDragger(this, state.target!, \"targetAbles\", \"Group\");\n            this.controlDragger = getAbleDragger(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n        }\n        const isContainerChanged = !equals(prevProps.container, props.container);\n\n        if (isContainerChanged) {\n            state.container = props.container;\n        }\n        const { added, changed, removed } = this.differ.update(props.targets!);\n\n        if (isContainerChanged || added.length || changed.length || removed.length) {\n            this.updateRect();\n        }\n    }\n    public checkUpdate() {\n        this.updateAbles();\n    }\n\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        if (!this.controlBox) {\n            return;\n        }\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, false, false);\n        });\n\n        const state = this.state;\n        const props = this.props;\n        const target = state.target! || props.target!;\n\n        if (!isTarget || (type !== \"\" && props.updateGroup)) {\n            // reset rotataion\n            this.rotation = props.defaultGroupRotate!;\n        }\n        const rotation = this.rotation;\n        const [left, top, width, height] = getGroupRect(this.moveables, rotation);\n\n        // tslint:disable-next-line: max-line-length\n        target.style.cssText += `left:0px;top:0px;width:${width}px; height:${height}px;transform:rotate(${rotation}deg)`;\n        state.width = width;\n        state.height = height;\n\n        const info = getTargetInfo(target, this.controlBox.getElement(), this.getContainer(), state);\n        const pos = [info.left!, info.top!];\n        [\n            info.pos1,\n            info.pos2,\n            info.pos3,\n            info.pos4,\n        ] = getAbsolutePosesByState(info as Required<typeof info>);\n        info.origin = plus(pos, info.origin!);\n        info.beforeOrigin = plus(pos, info.beforeOrigin!);\n\n        const clientRect = info.clientRect!;\n\n        clientRect.top += (top - info.top!) - state.top;\n        clientRect.left += (left - info.left!) - state.left;\n\n        this.updateState(\n            {\n                ...info,\n                left: left - info.left!,\n                top: top - info.top!,\n            },\n            isSetState,\n        );\n    }\n    public triggerEvent(name: string, e: any): any {\n        if (name.indexOf(\"Group\") > -1) {\n            return super.triggerEvent(name as any, e);\n        }\n    }\n    protected updateAbles() {\n        super.updateAbles([...this.props.ables!, Groupable], \"Group\");\n    }\n}\n\nexport default MoveableGroup;\n","import * as React from \"react\";\nimport { MoveableProps, Able, MoveableInterface, RectInfo } from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { ref } from \"framework-utils\";\nimport { isArray } from \"@daybrush/utils\";\nimport Groupable from \"./ables/Groupable\";\n\nexport default class Moveable<T = {}> extends React.PureComponent<MoveableProps & T> implements MoveableInterface {\n    public moveable!: MoveableManager<MoveableProps> | MoveableGroup;\n    public render() {\n        const props = this.props;\n        const ables: Able[] = props.ables as Able[] || [];\n        const target = this.props.target || this.props.targets;\n        const isArr = isArray(target);\n        const isGroup = isArr && (target as any[]).length > 1;\n\n        if (isGroup) {\n            const nextProps = {\n                ...this.props,\n                target: null,\n                targets: target as any[],\n                ables: [...MOVEABLE_ABLES, Groupable, ...ables],\n            };\n            return <MoveableGroup key=\"group\" ref={ref(this, \"moveable\")}\n                {...nextProps} />;\n        } else {\n            const moveableTarget = isArr ? (target as any[])[0] : target;\n\n            return <MoveableManager key=\"single\" ref={ref(this, \"moveable\")}\n                {...{ ...this.props, target: moveableTarget, ables: [...MOVEABLE_ABLES, ...ables] }} />;\n        }\n    }\n    public isMoveableElement(target: HTMLElement) {\n        return this.moveable.isMoveableElement(target);\n    }\n    public dragStart(e: MouseEvent | TouchEvent) {\n        this.moveable.dragStart(e);\n    }\n    public isInside(clientX: number, clientY: number) {\n        return this.moveable.isInside(clientX, clientY);\n    }\n    public updateRect() {\n        this.moveable.updateRect();\n    }\n    public updateTarget() {\n        this.moveable.updateTarget();\n    }\n    public getRect(): RectInfo {\n        return this.moveable.getRect();\n    }\n    public destroy() {\n        this.moveable.componentWillUnmount();\n    }\n}\n"],"names":["agent","getAgent","isWebkit","os","name","indexOf","browser","PREFIX","MOVEABLE_CSS","prefixCSS","NEARBY_POS","TINY_NUM","MIN_SCALE","MAX_NUM","Math","pow","MIN_NUM","DIRECTION_INDEXES","n","s","w","e","nw","ne","sw","se","multiply2","pos1","pos2","prefix","_i","classNames","prefixNames","createIdentityMatrix3","createIdentityMatrix","getTransformMatrix","transform","isObject","value","splitBracket","split","map","v","parseFloat","getAbsoluteMatrix","matrix","origin","multiplies","createOriginMatrix","a","measureSVGSize","el","unit","isHorizontal","viewBox","ownerSVGElement","baseVal","getBeforeTransformOrigin","relativeOrigin","getTransformOrigin","getComputedStyle","o","i","_a","style","transformOrigin","getOffsetInfo","lastParent","isParent","body","document","target","parentElement","isEnd","position","isStatic","offsetParent","caculateMatrixStack","container","prevMatrix","prevN","matrixes","isSVGGraphicElement","tagName","toLowerCase","originalContainer","is3d","targetMatrix","offsetContainer","isFixed","styleTransform","convertCSStoMatrix","length","matrixesLength","convertDimension","offsetLeft","offsetTop","containerRect","documentElement","getBoundingClientRect","left","top","isSVG","isUndefined","hasNotOffset","pos","push","getSVGMatrix","_b","isOffsetEnd","parentClientLeft","parentClientTop","clientLeft","clientTop","scrollLeft","scrollTop","mat","beforeMatrix","offsetMatrix","endContainer","reverse","forEach","slice","multiply","isMatrix3d","convertMatrixtoCSS","clientWidth","clientHeight","viewBoxWidth","width","viewBoxHeight","height","scaleX","scaleY","preserveAspectRatio","align","meetOrSlice","svgOrigin","scale","translate","xAlign","yAlign","floor","scaleDimension","max","min","scaleMatrix","createScaleMatrix","getSVGGraphicsOffset","getBBox","bbox","svgElement","x","y","caculatePosition","caculate","convertPositionMatrix","caculatePoses","pos3","pos4","getRect","poses","posesX","posesY","right","bottom","rectWidth","rectHeight","caculateRect","getSVGOffset","absoluteMatrix","rect","rectLeft","rectTop","_c","prevLeft","prevTop","prevWidth","prevHeight","posOrigin","prevOrigin","minus","rectOrigin","offset","count","inverseBeforeMatrix","invert","mat2","_d","nextLeft","nextTop","distLeft","distTop","abs","p","round","caculateMoveablePosition","x1","y1","x2","y2","x3","y3","_e","x4","y4","_f","originX","originY","center","pos1Rad","getRad","pos2Rad","direction","PI","getLineStyle","distX","distY","sqrt","rad","getControlTransform","rotation","reduce","prev","getCSSSize","window","getSize","isOffset","isBoxSizing","boxSizing","offsetWidth","offsetHeight","hasOffset","borderLeft","borderLeftWidth","borderRight","borderRightWidth","borderTop","borderTopWidth","borderBottom","borderBottomWidth","paddingLeft","paddingRight","paddingTop","paddingBottom","getRotationRad","getTargetInfo","parentContainer","state","beforeDirection","targetTransform","beforeOrigin","clientRect","undefined","beforePos","getClientRect","getDirection","direciton","getAttribute","dir","getAbsolutePoses","dist","plus","getAbsolutePosesByState","throttle","num","throttleArray","nums","_","unset","self","getOrientationDirection","isInside","k1","k2","k3","k4","k5","k6","signs1","signs2","every","sign","fillParams","moveable","params","datas","tslib_1","clientX","clientY","inputEvent","currentTarget","triggerEvent","pseudoElt","filterAbles","ables","methods","enabledAbles","ableGroups","filter","able","some","method","ableGroup","getKeepRatioHeight","isWidth","ratio","getKeepRatioWidth","equals","a1","a2","triggerRenderStart","isGroup","isPinch","eventAffix","targets","props","triggerRender","triggerRenderEnd","sPinch","isDrag","triggerAble","ableType","eventOperation","eventType","isStart","areaElement","eventName","conditionName","isAfter","updateRect","results","condition","isUpdate","dragger","forceUpdate","getAbleDragger","options","pinchThreshold","Dragger","ControlBoxElement","styler","renderLine","index","React","key","className","_this","conatainer","edge","parentPosition","checkUpdate","parentLeft","parentTop","ref","display","renderAbles","controlBox","getElement","parentMoveable","updateEvent","prevProps","getContainer","targetDragger","onDragStart","type","isTarget","isSetState","updateState","controlBoxElement","hasTargetAble","targetAbles","hasControlAble","controlAbles","prevTarget","dragArea","prevDragArea","isTargetChanged","isUnset","controlDragger","unsetAbles","stateTarget","stateContainer","updateAbles","isChanged","callback","dragStart","pinchStart","dragControlStart","nextState","setState","render","MoveableManager","keepRatio","getRotatiion","touches","pinchable","controlEventName","pinchAbles","canPinch","result","parentRotate","ableEvent","pinchFlag","snapDirection","pinch","pinchScale","distance","parentDistance","pinchEnd","pinchGroupStart","pinchGroup","pinchGroupEnd","triggerChildAble","eachEvent","ableDatas","match","childs","moveables","child","childDatas","childEvent","isFunction","parentFlag","directionCondition","hasClass","setDragStart","inverseMatrix","absoluteOrigin","startDragBeforeDist","startDragDist","getDragDist","isBefore","caculateTransformOrigin","prevSize","size","isNaN","measureRatio","getPosIndexesByDirection","indexes","getPosesByDirection","getPosByDirection","nextPoses","average","getPosByReverseDirection","getStartPos","startPos1","startPos2","startPos3","startPos4","getDist","startPos","getNextMatrix","getScaleDist","dragClient","groupable","nextMatrix","groupLeft","groupTop","getResizeDist","fixedPosition","nextOrigin","getStartDirection","baseDirection","getFixedPosition","snapStart","guidelines","horizontalGuidelines","verticalGuidelines","elementGuidelines","bounds","snapCenter","containerWidth","containerHeight","containerTop","containerLeft","targetLeft","targetTop","elementTop","elementBottom","elementLeft","elementRight","element","enableSnap","checkBounds","verticalPoses","horizontalPoses","snapThreshold","vertical","checkBound","horizontal","isVertical","endPos","minPos","maxPos","isBound","checkSnap","targetType","targetPoses","isSnapCenter","isSnap","snapPoses","snapGuidelines","snapDist","Infinity","snapOffset","posType","targetPos","guideline","isFinite","hasGuidelines","ableName","snappable","checkSnapPoses","customSnapThreshold","checkSnaps","isCenter","verticalNames","horizontalNames","checkBoundOneWayDist","isHorizontalBound","horizontalBoundOffset","isVerticalBound","verticalBoundOffset","solveNextDist","isDirectionVertical","sizeOffset","solveEquation","NaN","widthDist","heightDist","getFixedPoses","fixedPos","nextPos","checkBoundOneWayPos","reversePos","isHorizontalSnap","horizontalOffset","horizontalDist","isVerticalSnap","verticalOffset","verticalDist","fixedHorizontal","fixedVertical","checkOneWayPos","reversePoses","posOffset","boundInfo","boundIndex","boundInfos","info","nextDist","checkOneWayDist","directionIndex","directionPoses","reverseDirectionPoses","checkTwoWayDist","verticalDirection","horizontalDirection","verticalPos","horizontalPos","verticalBoundInfo","horizontalBoundInfo","isVeritcalDirectionBound","isHorizontalDirectionBound","checkSizeDist","checkSnapSize","checkSnapScale","sizeDist","dx","dy","b","getSnapInfosByDirection","middle","alignPoses","startCheckSnapDrag","absolutePoses","checkSnapDrag","snapVerticalInfo","snapHorizontalInfo","snapInfos","minLeft","minTop","verticalGuildelines","verticalSnapPoses","horizontalSnapPoses","_g","verticalBoundPos","_h","horizontalBoundPos","dragEnd","dragControlCondition","dragControlEnd","dragGroupStart","dragGroupEnd","dragGroupControlStart","dragGroupControlEnd","parentEvent","parentDragger","startTranslate","prevDist","prevBeforeDist","set","drag","throttleDrag","verticalInfo","horizontalInfo","passDistX","passDistY","beforeTranslate","beforeDist","delta","beforeDelta","nextTransform","events","nextParams","dragGroup","setCustomDrag","move","client","isFlag","prevX","prevY","startX","startY","deltaX","deltaY","setRotateStartInfo","rotationPos","startAbsoluteOrigin","prevDeg","startDeg","loop","getDeg","deg","startRotate","throttleRotate","prevLoop","absolutePrevDeg","absoluteDeg","getRotateInfo","getPositions","rotationPosition","getRotationPosition","relativeRotationPos","rotateMatrix","rotatable","rotationRad","beforeInfo","afterInfo","rotatation","isRotate","dragControl","rotate","beforeRotate","dragGroupControlCondition","parentBeforeOrigin","eventParams","childClient","prevClient","Draggable","CustomDragger","dragGroupControl","dragResult","renderControls","defaultDirections","directions","directionMap","renderAllDirections","renderDiagonalDirections","resizable","inputTarget","startOffsetWidth","startOffsetHeight","startDirection","fixedOriginalPosition","startWidth","startHeight","setOrigin","isResize","parentScale","throttleResize","distWidth","distHeight","standardRad","ratioRad","signSize","cos","sin","nextWidth","nextHeight","isNoSnap","inverseDelta","dragControlAfter","errorWidth","errorHeight","isErrorWidth","isErrorHeight","originalX","originalY","scalable","startScale","isScale","throttleScale","nowDist","stateDirection","isArray","snapHeight","snapWidth","prevPos","getMiddleLinePos","dot","getTriangleRad","rad1","rad2","isValidPos","poses1","poses2","pi","warpable","linePosFrom1","linePosFrom2","linePosFrom3","linePosFrom4","linePosTo1","linePosTo2","linePosTo3","linePosTo4","warpTargetMatrix","targetInverseMatrix","ignoreDimension","startMatrix","posIndexes","isWarp","selectedPoses","nearByPoses","h","createWarpMatrix","join","multiplyCSS","AREA","AREA_PIECES","AREA_PIECE","AVOID","restoreStyle","removeClass","cssText","renderPieces","isDragArea","relativeLeft","relativeTop","posX","posY","rects","children","call","nextElementSibling","addClass","isMoveableElement","containsTarget","contains","prevInputTarget","targetIndex","findIndex","parentTarget","getDefaultScrollPosition","scrollContainer","scrollClientRect","scrollRect","isScroll","checkScroll","prevClientX","prevClientY","scrollThreshold","getScrollPosition","requestAnimationFrame","offsetX","offsetY","scrollBy","setTimeout","onDrag","MOVEABLE_ABLES","Snappable","Pinchable","Rotatable","Resizable","Scalable","Warpable","Scrollable","DragArea","Origin","refs","getMaxPos","getMinPos","getGroupRect","moveablePoses","minX","minY","groupWidth","groupHeight","fixedRotation","rad_1","a1_1","tan","a2_1","b1s_1","b2s_1","b1","b2","rotatePoses","changedWidth","ChildrenDiffer","isContainerChanged","added","changed","removed","updateGroup","defaultGroupRotate","_super","Groupable","MoveableGroup","defaultProps","isArr","nextProps","moveableTarget","updateTarget","componentWillUnmount"],"mappings":"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"}