{"version":3,"file":"moveable.min.js","sources":["../src/InnerMoveable.tsx","../src/consts.ts","../src/Moveable.tsx","../src/index.umd.ts"],"sourcesContent":["import { Component, h } from \"preact\";\nimport { createPortal } from \"preact/compat\";\nimport Moveable, { MoveableProps, PreactMoveableInterface } from \"preact-moveable\";\nimport { ref } from \"framework-utils\";\n\nexport default class InnerMoveable extends Component<MoveableProps> {\n    public state: MoveableProps = {};\n    public preactMoveable: PreactMoveableInterface;\n    constructor(props: MoveableProps) {\n        super(props);\n        this.state = this.props;\n    }\n    public render() {\n        return createPortal(<Moveable ref={ref(this, \"preactMoveable\")} {...this.state} />, this.state.parentElement);\n    }\n}\n","import { MoveableEvents, MoveableOptions } from \"./types\";\n\nexport const PROPERTIES: Array<keyof MoveableOptions> = [\n    \"draggable\", \"resizable\", \"scalable\", \"rotatable\",\n    \"warpable\", \"pinchable\", \"snappable\", \"origin\", \"target\", \"edge\",\n    \"throttleDrag\", \"throttleResize\",\n    \"throttleScale\", \"throttleRotate\", \"keepRatio\",\n    \"dragArea\",\n    \"pinchThreshold\",\n    \"snapCenter\", \"snapThreshold\",\n    \"horizontalGuidelines\", \"verticalGuidelines\", \"elementGuidelines\",\n    \"bounds\",\n\n    \"className\",\n    \"renderDirections\",\n    \"scrollable\",\n    \"getScrollPosition\",\n    \"scrollContainer\",\n    \"scrollThreshold\",\n    \"baseDirection\",\n];\nexport const EVENTS: Array<keyof MoveableEvents> = [\n    \"dragStart\",\n    \"drag\",\n    \"dragEnd\",\n    \"resizeStart\",\n    \"resize\",\n    \"resizeEnd\",\n    \"scaleStart\",\n    \"scale\",\n    \"scaleEnd\",\n    \"rotateStart\",\n    \"rotate\",\n    \"rotateEnd\",\n    \"warpStart\",\n    \"warp\",\n    \"warpEnd\",\n    \"pinchStart\",\n    \"pinch\",\n    \"pinchEnd\",\n    \"dragGroupStart\",\n    \"dragGroup\",\n    \"dragGroupEnd\",\n    \"resizeGroupStart\",\n    \"resizeGroup\",\n    \"resizeGroupEnd\",\n    \"scaleGroupStart\",\n    \"scaleGroup\",\n    \"scaleGroupEnd\",\n    \"rotateGroupStart\",\n    \"rotateGroup\",\n    \"rotateGroupEnd\",\n    \"pinchGroupStart\",\n    \"pinchGroup\",\n    \"pinchGroupEnd\",\n    \"clickGroup\",\n\n    \"scroll\",\n    \"scrollGroup\",\n\n    \"renderStart\",\n    \"render\",\n    \"renderEnd\",\n    \"renderGroupStart\",\n    \"renderGroup\",\n    \"renderGroupEnd\",\n];\n","import EgComponent from \"@egjs/component\";\nimport { ref, Properties } from \"framework-utils\";\nimport { h, render } from \"preact\";\nimport InnerMoveable from \"./InnerMoveable\";\nimport { MoveableOptions, MoveableGetterSetter } from \"./types\";\nimport {\n    OnDragStart, OnDrag, OnResize, OnResizeStart,\n    OnResizeEnd, OnScaleStart, OnScaleEnd, OnRotateStart,\n    OnRotateEnd, OnDragEnd, OnRotate, OnScale,\n    OnWarpStart, OnWarpEnd, OnWarp, OnPinchStart,\n    OnPinch, OnPinchEnd, OnDragGroup, OnDragGroupStart,\n    OnDragGroupEnd, OnResizeGroup, OnResizeGroupStart,\n    OnResizeGroupEnd, OnScaleGroup, OnScaleGroupEnd,\n    OnRotateGroup, OnRotateGroupStart, OnRotateGroupEnd,\n    OnPinchGroup, OnPinchGroupStart, OnPinchGroupEnd, OnScaleGroupStart, OnClickGroup,\n    MoveableInterface,\n    RectInfo,\n    OnClick,\n    OnScroll,\n    OnScrollGroup,\n    OnRenderStart,\n    OnRender,\n    OnRenderEnd,\n    OnRenderGroupStart,\n    OnRenderGroup,\n    OnRenderGroupEnd,\n} from \"react-moveable/declaration/types\";\nimport { PROPERTIES, EVENTS } from \"./consts\";\nimport { camelize, isArray } from \"@daybrush/utils\";\n\n/**\n * Moveable is Draggable! Resizable! Scalable! Rotatable!\n * @sort 1\n * @extends eg.Component\n */\n@Properties(PROPERTIES, (prototype, property) => {\n    Object.defineProperty(prototype, property, {\n        get() {\n            return this.getMoveable().props[property];\n        },\n        set(value) {\n            this.setState({\n                [property]: value,\n            });\n        },\n        enumerable: true,\n        configurable: true,\n    });\n})\nclass Moveable extends EgComponent implements MoveableInterface {\n    private innerMoveable!: InnerMoveable;\n    private tempElement = document.createElement(\"div\");\n\n    /**\n     *\n     */\n    constructor(parentElement: HTMLElement | SVGElement, options: MoveableOptions = {}) {\n        super();\n        const nextOptions = { container: parentElement, ...options };\n\n        const events: any = {};\n\n        EVENTS.forEach(name => {\n            events[camelize(`on ${name}`)] = (e: any) => this.trigger(name, e);\n        });\n\n        render(\n            <InnerMoveable\n                ref={ref(this, \"innerMoveable\")}\n                parentElement={parentElement}\n                {...nextOptions}\n                {...events}\n            />,\n            this.tempElement,\n        );\n        const target = nextOptions.target!;\n        if (isArray(target) && target.length > 1) {\n            this.updateRect();\n        }\n    }\n    /**\n     * Check if the target is an element included in the moveable.\n     * @param - the target\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"click\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *         moveable.target = e.target;\n     *     }\n     * });\n     */\n    public isMoveableElement(target: HTMLElement | SVGElement) {\n        return this.getMoveable().isMoveableElement(target);\n    }\n    /**\n     * If the width, height, left, and top of all elements change, update the shape of the moveable.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"resize\", e => {\n     *     moveable.updateRect();\n     * });\n     */\n    public updateRect() {\n        this.getMoveable().updateRect();\n    }\n    /**\n     * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n     * @param - external `MouseEvent`or `TouchEvent`\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *          moveable.dragStart(e);\n     *     }\n     * });\n     */\n    public dragStart(e: MouseEvent | TouchEvent): void {\n        this.getMoveable().dragStart(e);\n    }\n\n    /**\n     * Whether the coordinates are inside Moveable\n     * @param - x coordinate\n     * @param - y coordinate\n     * @return - True if the coordinate is in moveable or false\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.isInside(e.clientX, e.clientY)) {\n     *          console.log(\"inside\");\n     *     }\n     * });\n     */\n    public isInside(clientX: number, clientY: number): boolean {\n        return this.getMoveable().isInside(clientX, clientY);\n    }\n    /**\n     * You can get the vertex information, position and offset size information of the target based on the container.\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const rectInfo = moveable.getRect();\n     */\n    public getRect(): RectInfo {\n        return this.getMoveable().getRect();\n    }\n    /**\n     * You can change options or properties dynamically.\n     * @param - options or properties\n     * @param - After the change, the callback function is executed when the update is completed.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.setState({\n     *   target: document.querySelector(\".target\"),\n     * }, () => {\n     *   moveable.dragStart(e);\n     * })\n     */\n    public setState(state: Partial<MoveableOptions>, callback?: () => any) {\n        this.innerMoveable.setState(state, callback);\n    }\n    /**\n     * If the width, height, left, and top of the only target change, update the shape of the moveable.\n     * @param - the values of x and y to move moveable.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.updateTarget();\n     */\n    public updateTarget(): void {\n        this.getMoveable().updateTarget();\n    }\n    /**\n     * Remove the Moveable object and the events.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.destroy();\n     */\n    public destroy() {\n        render(\"\", this.tempElement);\n        this.off();\n        this.tempElement = null;\n        this.innerMoveable = null;\n    }\n    private getMoveable() {\n        return this.innerMoveable.preactMoveable;\n    }\n}\n/**\n * Whether or not the origin controlbox will be visible or not (default: true)\n * @name Moveable#origin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.origin = true;\n */\n/**\n * The target to indicate Moveable Control Box.\n * @name Moveable#target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n */\n/**\n * Whether or not target can be dragged. (default: false)\n * @name Moveable#draggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.draggable = true;\n */\n/**\n * Whether or not target can be resized. (default: false)\n * @name Moveable#resizable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.resizable = true;\n */\n/**\n * Whether or not target can scaled. (default: false)\n * @name Moveable#scalable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.scalable = true;\n */\n/**\n * Whether or not target can be rotated. (default: false)\n * @name Moveable#rotatable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.rotatable = true;\n */\n/**\n * Whether or not target can be warped. (default: false)\n * @name Moveable#warpable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.warpable = true;\n */\n/**\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n * @name Moveable#pinchable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.pinchable = true;\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.keepRatio = true;\n */\n/**\n * Resize, Scale Events at edges\n * @name Moveable#edge\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.edge = true;\n */\n/**\n * throttle of x, y when drag.\n * @name Moveable#throttleDrag\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDrag = 1;\n */\n/**\n * throttle of width, height when resize.\n * @name Moveable#throttleResize\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleResize = 1;\n */\n/**\n * throttle of scaleX, scaleY when scale.\n * @name Moveable#throttleScale\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleScale = 0.1;\n */\n/**\n * throttle of angle(degree) when rotate.\n * @name Moveable#throttleRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleRotate = 1;\n */\n\n /**\n * Whether or not target can be snapped to the guideline. (default: false)\n * @name Moveable#snappable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snappable = true;\n */\n/**\n * When you drag, make the snap in the center of the target. (default: false)\n * @name Moveable#snapCenter\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapCenter = true;\n */\n\n/**\n * Distance value that can snap to guidelines. (default: 5)\n * @name Moveable#snapThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapThreshold = 5;\n */\n\n/**\n * Add guidelines in the horizontal direction. (default: [])\n * @name Moveable#horizontalGuidlines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.horizontalGuidlines = [100, 200, 500];\n */\n\n/**\n * Add guidelines in the vertical direction. (default: [])\n * @name Moveable#\n * moveable.verticalGuidlines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.verticalGuidlines = [100, 200, 500];\n */\n/**\n * Add guidelines for the element. (default: [])\n * @name Moveable#elementGuidelines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.elementGuidelines = [\n *   document.querySelector(\".element\"),\n * ];\n */\n/**\n * You can set up boundaries. (default: [])\n * @name Moveable#bounds\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\n */\n/**\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false)\n * @name Moveable#dragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n/**\n * You can specify the position of the rotation. (default: \"top\")\n * @name Moveable#rotationPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   rotationPosition: \"top\",\n * });\n *\n * moveable.rotationPosition = \"bottom\"\n */\n/**\n * You can specify the className of the moveable controlbox. (default: \"\")\n * @name Moveable#className\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   className: \"\",\n * });\n *\n * moveable.className = \"moveable1\";\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n /**\n * Set target's base direciton using top, left, right, bottom\n * (top: -1, left: -1, right: 1, bottom: 1) (default: [-1, -1])\n * @name Moveable#baseDirection\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   baseDirection: [-1, -1]\n * });\n *\n * moveable.baseDirection = [-1, -1];\n */\n\n /**\n * Sets the initial rotation of the group. (default 0)\n * @name Moveable#defaultGroupRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupRotate: 0,\n * });\n *\n * moveable.defaultGroupRotate = 40;\n */\n\n/**\n * Whether or not target can be scrolled to the scroll container (default: false)\n * @name Moveable#scrollable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n * moveable.scrollable = true;\n */\n\n/**\n * The container to which scroll is applied (default: container)\n * @name Moveable#scrollContainer\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n/**\n * Expand the range of the scroll check area. (default: 0)\n * @name Moveable#scrollThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n\n/**\n * Sets a function to get the scroll position. (default: Function)\n * @name Moveable#getScrollPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n */\n\n/**\n * When the drag starts, the dragStart event is called.\n * @memberof Moveable\n * @event dragStart\n * @param {Moveable.OnDragStart} - Parameters for the dragStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When dragging, the drag event is called.\n * @memberof Moveable\n * @event drag\n * @param {Moveable.OnDrag} - Parameters for the drag event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"drag\", ({ target, transform }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the drag finishes, the dragEnd event is called.\n * @memberof Moveable\n * @event dragEnd\n * @param {Moveable.OnDragEnd} - Parameters for the dragEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n /**\n * When the group drag starts, the `dragGroupStart` event is called.\n * @memberof Moveable\n * @event dragGroupStart\n * @param {Moveable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupStart\", ({ targets }) => {\n *     console.log(\"onDragGroupStart\", targets);\n * });\n */\n\n /**\n * When the group drag, the `dragGroup` event is called.\n * @memberof Moveable\n * @event dragGroup\n * @param {Moveable.onDragGroup} - Parameters for the `dragGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroup\", ({ targets, events }) => {\n *     console.log(\"onDragGroup\", targets);\n *     events.forEach(ev => {\n *          // drag event\n *          console.log(\"onDrag left, top\", ev.left, ev.top);\n *          // ev.target!.style.left = `${ev.left}px`;\n *          // ev.target!.style.top = `${ev.top}px`;\n *          console.log(\"onDrag translate\", ev.dist);\n *          ev.target!.style.transform = ev.transform;)\n *     });\n * });\n */\n\n/**\n * When the group drag finishes, the `dragGroupEnd` event is called.\n * @memberof Moveable\n * @event dragGroupEnd\n * @param {Moveable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\n * });\n */\n\n/**\n * When the resize starts, the resizeStart event is called.\n * @memberof Moveable\n * @event resizeStart\n * @param {Moveable.OnResizeStart} - Parameters for the resizeStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When resizing, the resize event is called.\n * @memberof Moveable\n * @event resize\n * @param {Moveable.OnResize} - Parameters for the resize event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resize\", ({ target, width, height }) => {\n *     target.style.width = `${e.width}px`;\n *     target.style.height = `${e.height}px`;\n * });\n */\n/**\n * When the resize finishes, the resizeEnd event is called.\n * @memberof Moveable\n * @event resizeEnd\n * @param {Moveable.OnResizeEnd} - Parameters for the resizeEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n/**\n * When the scale starts, the scaleStart event is called.\n * @memberof Moveable\n * @event scaleStart\n * @param {Moveable.OnScaleStart} - Parameters for the scaleStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When scaling, the scale event is called.\n * @memberof Moveable\n * @event scale\n * @param {Moveable.OnScale} - Parameters for the scale event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the scale finishes, the scaleEnd event is called.\n * @memberof Moveable\n * @event scaleEnd\n * @param {Moveable.OnScaleEnd} - Parameters for the scaleEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n/**\n * When the rotate starts, the rotateStart event is called.\n * @memberof Moveable\n * @event rotateStart\n * @param {Moveable.OnRotateStart} - Parameters for the rotateStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When rotating, the rotate event is called.\n * @memberof Moveable\n * @event rotate\n * @param {Moveable.OnRotate} - Parameters for the rotate event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotate\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the rotate finishes, the rotateEnd event is called.\n * @memberof Moveable\n * @event rotateEnd\n * @param {Moveable.OnRotateEnd} - Parameters for the rotateEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the warp starts, the warpStart event is called.\n* @memberof Moveable\n* @event warpStart\n* @param {Moveable.OnWarpStart} - Parameters for the warpStart event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { warpable: true });\n* moveable.on(\"warpStart\", ({ target }) => {\n*     console.log(target);\n* });\n*/\n/**\n * When warping, the warp event is called.\n * @memberof Moveable\n * @event warp\n * @param {Moveable.OnWarp} - Parameters for the warp event\n * @example\n * import Moveable from \"moveable\";\n * let matrix = [\n *  1, 0, 0, 0,\n *  0, 1, 0, 0,\n *  0, 0, 1, 0,\n *  0, 0, 0, 1,\n * ];\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\n *    // target.style.transform = transform;\n *    matrix = multiply(matrix, delta);\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\n * });\n */\n/**\n * When the warp finishes, the warpEnd event is called.\n * @memberof Moveable\n * @event warpEnd\n * @param {Moveable.OnWarpEnd} - Parameters for the warpEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n/**\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\n * @memberof Moveable\n * @event pinchStart\n * @param {Moveable.OnPinchStart} - Parameters for the pinchStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When pinching, the pinch event is called with part of scale, rotate, resize\n * @memberof Moveable\n * @event pinch\n * @param {Moveable.OnPinch} - Parameters for the pinch event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinch\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotate\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scale\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When the pinch finishes, the pinchEnd event is called.\n * @memberof Moveable\n * @event pinchEnd\n * @param {Moveable.OnPinchEnd} - Parameters for the pinchEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleEnd\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n /**\n * When the group resize starts, the `resizeGroupStart` event is called.\n * @memberof Moveable\n * @event resizeGroupStart\n * @param {Moveable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupStart\", ({ targets }) => {\n *     console.log(\"onResizeGroupStart\", targets);\n * });\n */\n\n /**\n * When the group resize, the `resizeGroup` event is called.\n * @memberof Moveable\n * @event resizeGroup\n * @param {Moveable.onResizeGroup} - Parameters for the `resizeGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroup\", ({ targets, events }) => {\n *     console.log(\"onResizeGroup\", targets);\n *     events.forEach(ev => {\n *         const offset = [\n *             direction[0] < 0 ? -ev.delta[0] : 0,\n *             direction[1] < 0 ? -ev.delta[1] : 0,\n *         ];\n *         // ev.drag is a drag event that occurs when the group resize.\n *         const left = offset[0] + ev.drag.beforeDist[0];\n *         const top = offset[1] + ev.drag.beforeDist[1];\n *         const width = ev.width;\n *         const top = ev.top;\n *     });\n * });\n */\n\n/**\n * When the group resize finishes, the `resizeGroupEnd` event is called.\n * @memberof Moveable\n * @event resizeGroupEnd\n * @param {Moveable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\n * });\n */\n\n /**\n * When the group scale starts, the `scaleGroupStart` event is called.\n * @memberof Moveable\n * @event scaleGroupStart\n * @param {Moveable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupStart\", ({ targets }) => {\n *     console.log(\"onScaleGroupStart\", targets);\n * });\n */\n\n /**\n * When the group scale, the `scaleGroup` event is called.\n * @memberof Moveable\n * @event scaleGroup\n * @param {Moveable.OnScaleGroup} - Parameters for the `scaleGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroup\", ({ targets, events }) => {\n *     console.log(\"onScaleGroup\", targets);\n *     events.forEach(ev => {\n *         const target = ev.target;\n *         // ev.drag is a drag event that occurs when the group scale.\n *         const left = ev.drag.beforeDist[0];\n *         const top = ev.drag.beforeDist[1];\n *         const scaleX = ev.scale[0];\n *         const scaleY = ev.scale[1];\n *     });\n * });\n */\n\n/**\n * When the group scale finishes, the `scaleGroupEnd` event is called.\n * @memberof Moveable\n * @event scaleGroupEnd\n * @param {Moveable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\n * });\n */\n\n/**\n * When the group rotate starts, the `rotateGroupStart` event is called.\n * @memberof Moveable\n * @event rotateGroupStart\n * @param {Moveable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\n *     console.log(\"onRotateGroupStart\", targets);\n * });\n */\n\n /**\n * When the group rotate, the `rotateGroup` event is called.\n * @memberof Moveable\n * @event rotateGroup\n * @param {Moveable.OnRotateGroup} - Parameters for the `rotateGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroup\", ({ targets, events }) => {\n *     console.log(\"onRotateGroup\", targets);\n *     events.forEach(ev => {\n *         const target = ev.target;\n *         // ev.drag is a drag event that occurs when the group rotate.\n *         const left = ev.drag.beforeDist[0];\n *         const top = ev.drag.beforeDist[1];\n *         const deg = ev.beforeDist;\n *     });\n * });\n */\n\n/**\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\n * @memberof Moveable\n * @event rotateGroupEnd\n * @param {Moveable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\n * });\n */\n\n/**\n * When the group pinch starts, the `pinchGroupStart` event is called.\n * @memberof Moveable\n * @event pinchGroupStart\n * @param {Moveable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\n *     console.log(\"onPinchGroupStart\", targets);\n * });\n */\n\n/**\n * When the group pinch, the `pinchGroup` event is called.\n * @memberof Moveable\n * @event pinchGroup\n * @param {Moveable.OnPinchGroup} - Parameters for the `pinchGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\n *     console.log(\"onPinchGroup\", targets);\n * });\n */\n\n/**\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\n * @memberof Moveable\n * @event pinchGroupEnd\n * @param {Moveable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\n * });\n */\n\n/**\n * When you click on the element, the `click` event is called.\n * @memberof Moveable\n * @event click\n * @param {Moveable.OnClick} - Parameters for the `click` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * When you click on the element inside the group, the `clickGroup` event is called.\n * @memberof Moveable\n * @event clickGroup\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * `renderStart` event occurs at the first start of all events.\n * @memberof Moveable\n * @event renderStart\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderStart\", ({ target }) => {\n *     console.log(\"onRenderStart\", target);\n * });\n */\n\n/**\n * `render` event occurs before the target is drawn on the screen.\n * @memberof Moveable\n * @event render\n * @param {Moveable.OnRender} - Parameters for the `render` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"render\", ({ target }) => {\n *     console.log(\"onRender\", target);\n * });\n */\n\n/**\n * `renderEnd` event occurs at the end of all events.\n * @memberof Moveable\n * @event renderEnd\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderEnd\", ({ target }) => {\n *     console.log(\"onRenderEnd\", target);\n * });\n */\n\n/**\n * `renderGroupStart` event occurs at the first start of all events in group.\n * @memberof Moveable\n * @event renderGroupStart\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\n *     console.log(\"onRenderGroupStart\", targets);\n * });\n */\n\n/**\n * `renderGroup` event occurs before the target is drawn on the screen in group.\n * @memberof Moveable\n * @event renderGroup\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroup\", ({ targets }) => {\n *     console.log(\"onRenderGroup\", targets);\n * });\n */\n\n/**\n * `renderGroupEnd` event occurs at the end of all events in group.\n * @memberof Moveable\n * @event renderGroupEnd\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\n *     console.log(\"onRenderGroupEnd\", targets);\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\n * @memberof Moveable\n * @event scroll\n * @param {Moveable.OnScroll} - Parameters for the `scroll` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\n * @memberof Moveable\n * @event scrollGroup\n * @param {Moveable.OnScrollGroup} - Parameters for the `scrollGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\ninterface Moveable extends MoveableGetterSetter {\n    on(eventName: \"drag\", handlerToAttach: (event: OnDrag) => any): this;\n    on(eventName: \"dragStart\", handlerToAttach: (event: OnDragStart) => any): this;\n    on(eventName: \"dragEnd\", handlerToAttach: (event: OnDragEnd) => any): this;\n    on(eventName: \"dragGroup\", handlerToAttach: (event: OnDragGroup) => any): this;\n    on(eventName: \"dragGroupStart\", handlerToAttach: (event: OnDragGroupStart) => any): this;\n    on(eventName: \"dragGroupEnd\", handlerToAttach: (event: OnDragGroupEnd) => any): this;\n\n    on(eventName: \"resize\", handlerToAttach: (event: OnResize) => any): this;\n    on(eventName: \"resizeStart\", handlerToAttach: (event: OnResizeStart) => any): this;\n    on(eventName: \"resizeEnd\", handlerToAttach: (event: OnResizeEnd) => any): this;\n    on(eventName: \"resizeGroup\", handlerToAttach: (event: OnResizeGroup) => any): this;\n    on(eventName: \"resizeGroupStart\", handlerToAttach: (event: OnResizeGroupStart) => any): this;\n    on(eventName: \"resizeGroupEnd\", handlerToAttach: (event: OnResizeGroupEnd) => any): this;\n\n    on(eventName: \"scale\", handlerToAttach: (event: OnScale) => any): this;\n    on(eventName: \"scaleStart\", handlerToAttach: (event: OnScaleStart) => any): this;\n    on(eventName: \"scaleEnd\", handlerToAttach: (event: OnScaleEnd) => any): this;\n    on(eventName: \"scaleGroup\", handlerToAttach: (event: OnScaleGroup) => any): this;\n    on(eventName: \"scaleGroupStart\", handlerToAttach: (event: OnScaleGroupStart) => any): this;\n    on(eventName: \"scaleGroupEnd\", handlerToAttach: (event: OnScaleGroupEnd) => any): this;\n\n    on(eventName: \"rotate\", handlerToAttach: (event: OnRotate) => any): this;\n    on(eventName: \"rotateStart\", handlerToAttach: (event: OnRotateStart) => any): this;\n    on(eventName: \"rotateEnd\", handlerToAttach: (event: OnRotateEnd) => any): this;\n    on(eventName: \"rotateGroup\", handlerToAttach: (event: OnRotateGroup) => any): this;\n    on(eventName: \"rotateGroupStart\", handlerToAttach: (event: OnRotateGroupStart) => any): this;\n    on(eventName: \"rotateGroupEnd\", handlerToAttach: (event: OnRotateGroupEnd) => any): this;\n\n    on(eventName: \"warp\", handlerToAttach: (event: OnWarp) => any): this;\n    on(eventName: \"warpStart\", handlerToAttach: (event: OnWarpStart) => any): this;\n    on(eventName: \"warpEnd\", handlerToAttach: (event: OnWarpEnd) => any): this;\n\n    on(eventName: \"pinch\", handlerToAttach: (event: OnPinch) => any): this;\n    on(eventName: \"pinchStart\", handlerToAttach: (event: OnPinchStart) => any): this;\n    on(eventName: \"pinchEnd\", handlerToAttach: (event: OnPinchEnd) => any): this;\n    on(eventName: \"pinchGroup\", handlerToAttach: (event: OnPinchGroup) => any): this;\n    on(eventName: \"pinchGroupStart\", handlerToAttach: (event: OnPinchGroupStart) => any): this;\n    on(eventName: \"pinchGroupEnd\", handlerToAttach: (event: OnPinchGroupEnd) => any): this;\n\n    on(eventName: \"click\", handlerToAttach: (event: OnClick) => any): this;\n    on(eventName: \"clickGroup\", handlerToAttach: (event: OnClickGroup) => any): this;\n\n    on(eventName: \"scroll\", handlerToAttach: (event: OnScroll) => any): this;\n    on(eventName: \"scrollGroup\", handlerToAttach: (event: OnScrollGroup) => any): this;\n\n    on(eventName: \"renderStart\", handlerToAttach: (event: OnRenderStart) => any): this;\n    on(eventName: \"render\", handlerToAttach: (event: OnRender) => any): this;\n    on(eventName: \"renderEnd\", handlerToAttach: (event: OnRenderEnd) => any): this;\n    on(eventName: \"renderGroupStart\", handlerToAttach: (event: OnRenderGroupStart) => any): this;\n    on(eventName: \"renderGroup\", handlerToAttach: (event: OnRenderGroup) => any): this;\n    on(eventName: \"renderGroupEnd\", handlerToAttach: (event: OnRenderGroupEnd) => any): this;\n\n    on(eventName: string, handlerToAttach: (event: { [key: string]: any }) => any): this;\n    on(events: { [key: string]: (event: { [key: string]: any }) => any }): this;\n}\n\nexport default Moveable;\n","import Moveable from \"./Moveable\";\nimport { PROPERTIES, EVENTS } from \"./consts\";\n\n(Moveable as any).PROPERTIES = PROPERTIES;\n(Moveable as any).EVENTS = EVENTS;\n\nexport default Moveable;\n"],"names":["props","_super","_this","state","__extends","createPortal","h","Moveable","ref","this","parentElement","Component","PROPERTIES","EVENTS","options","document","createElement","nextOptions","container","events","forEach","name","camelize","e","trigger","render","InnerMoveable","tempElement","target","isArray","length","updateRect","getMoveable","isMoveableElement","dragStart","clientX","clientY","isInside","getRect","callback","innerMoveable","setState","updateTarget","off","preactMoveable","Properties","prototype","property","Object","defineProperty","get","set","value","enumerable","configurable","EgComponent"],"mappings":";;;;;;;;w9hGAQgBA,SACRC,YAAMD,gBAHHE,QAAuB,GAI1BA,EAAKC,MAAQD,EAAKF,eALiBI,0BAOvC,kBACWC,GAAaC,EAACC,MAASC,IAAKA,EAAIC,KAAM,mBAAuBA,KAAKN,QAAWM,KAAKN,MAAMO,mBAR5DC,GCH9BC,GAA2C,CACpD,YAAa,YAAa,WAAY,YACtC,WAAY,YAAa,YAAa,SAAU,SAAU,OAC1D,eAAgB,iBAChB,gBAAiB,iBAAkB,YACnC,WACA,iBACA,aAAc,gBACd,uBAAwB,qBAAsB,oBAC9C,SAEA,YACA,mBACA,aACA,oBACA,kBACA,kBACA,iBAESC,GAAsC,CAC/C,YACA,OACA,UACA,cACA,SACA,YACA,aACA,QACA,WACA,cACA,SACA,YACA,YACA,OACA,UACA,aACA,QACA,WACA,iBACA,YACA,eACA,mBACA,cACA,iBACA,kBACA,aACA,gBACA,mBACA,cACA,iBACA,kBACA,aACA,gBACA,aAEA,SACA,cAEA,cACA,SACA,YACA,mBACA,cACA,4CCTYH,EAAyCI,gBAAAA,YACjDb,mBANIC,cAAca,SAASC,cAAc,WAOnCC,KAAgBC,UAAWR,GAAkBI,GAE7CK,EAAc,GAEpBN,GAAOO,QAAQ,SAAAC,GACXF,uFAAOG,CAAS,MAAMD,IAAW,SAACE,UAAWrB,EAAKsB,QAAQH,EAAME,MAGpEE,EACInB,EAACoB,MACGlB,IAAKA,EAAIN,EAAM,iBACfQ,cAAeA,GACXO,EACAE,IAERjB,EAAKyB,iBAEHC,EAASX,EAAYW,cACvBC,GAAQD,IAA2B,EAAhBA,EAAOE,QAC1B5B,EAAK6B,eA5BM3B,oDA6CnB,SAAyBwB,UACdnB,KAAKuB,cAAcC,kBAAkBL,iBAahD,gBACSI,cAAcD,0BAgBvB,SAAiBR,QACRS,cAAcE,UAAUX,eAmBjC,SAAgBY,EAAiBC,UACtB3B,KAAKuB,cAAcK,SAASF,EAASC,cAYhD,kBACW3B,KAAKuB,cAAcM,sBAiB9B,SAAgBnC,EAAiCoC,QACxCC,cAAcC,SAAStC,EAAOoC,mBAYvC,gBACSP,cAAcU,0BAWvB,WACIjB,EAAO,GAAIhB,KAAKkB,kBACXgB,WACAhB,YAAc,UACda,cAAgB,oBAEzB,kBACW/B,KAAK+B,cAAcI,gBA/J5BrC,0ZAdLsC,CAAWjC,GAAY,SAACkC,EAAWC,GAChCC,OAAOC,eAAeH,EAAWC,EAAU,CACvCG,sBACWzC,KAAKuB,cAAchC,MAAM+C,IAEpCI,aAAIC,cACKX,iBACAM,GAAWK,OAGpBC,YAAY,EACZC,cAAc,OAGhB/C,IAAiBgD,aC9CL3C,WAAaA,MACbC,OAASA"}